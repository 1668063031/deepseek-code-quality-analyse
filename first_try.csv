slug,title,generated_code,status,error
maximum-containers-on-a-ship,Maximum Containers on a Ship,"```python
class Solution:
    def maxContainers(self, n: int, w: int, maxWeight: int) -> int:
        max_possible = n * n
        if w == 0:
            return max_possible
        max_containers = maxWeight // w
        return min(max_containers, max_possible)
```",Y,
unique-3-digit-even-numbers,Unique 3-Digit Even Numbers,"```python
from typing import List

class Solution:
    def totalNumbers(self, digits: List[int]) -> int:
        from collections import defaultdict
        
        count = defaultdict(int)
        for d in digits:
            count[d] += 1
        
        res = 0
        
        for first in range(1, 10):
            if count[first] == 0:
                continue
            count[first] -= 1
            
            for second in range(0, 10):
                if count[second] == 0:
                    continue
                count[second] -= 1
                
                for third in range(0, 10, 2):
                    if count[third] > 0:
                        res += 1
                
                count[second] += 1
            
            count[first] += 1
        
        return res
```",Y,
fruits-into-baskets-ii,Fruits Into Baskets II,"```python
from typing import List

class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        unplaced = 0
        used_baskets = [False] * len(baskets)
        
        for fruit in fruits:
            placed = False
            for i in range(len(baskets)):
                if not used_baskets[i] and baskets[i] >= fruit:
                    used_baskets[i] = True
                    placed = True
                    break
            if not placed:
                unplaced += 1
                
        return unplaced
```",Y,
maximum-unique-subarray-sum-after-deletion,Maximum Unique Subarray Sum After Deletion,"```python
class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_sum = -float('inf')
        n = len(nums)
        
        for i in range(n):
            current_sum = 0
            seen = set()
            for j in range(i, n):
                if nums[j] in seen:
                    break
                seen.add(nums[j])
                current_sum += nums[j]
                if current_sum > max_sum:
                    max_sum = current_sum
        
        return max_sum if max_sum != -float('inf') else 0
```",Y,
transform-array-by-parity,Transform Array by Parity,"```python
class Solution:
    def transformArray(self, nums: List[int]) -> List[int]:
        transformed = [0 if num % 2 == 0 else 1 for num in nums]
        transformed.sort()
        return transformed
```",Y,
check-if-digits-are-equal-in-string-after-operations-i,Check If Digits Are Equal in String After Operations I,"```python
class Solution:
    def hasSameDigits(self, s: str) -> bool:
        while len(s) > 2:
            new_s = []
            for i in range(len(s) - 1):
                new_digit = (int(s[i]) + int(s[i+1])) % 10
                new_s.append(str(new_digit))
            s = ''.join(new_s)
        return s[0] == s[1]
```",Y,
maximum-difference-between-even-and-odd-frequency-i,Maximum Difference Between Even and Odd Frequency I,"```python
class Solution:
    def maxDifference(self, s: str) -> int:
        freq = {}
        for char in s:
            freq[char] = freq.get(char, 0) + 1
        
        even_freq = []
        odd_freq = []
        
        for count in freq.values():
            if count % 2 == 0:
                even_freq.append(count)
            else:
                odd_freq.append(count)
        
        if not even_freq or not odd_freq:
            return 0
        
        max_odd = max(odd_freq)
        min_even = min(even_freq)
        
        return max_odd - min_even
```",Y,
maximum-difference-between-adjacent-elements-in-a-circular-array,Maximum Difference Between Adjacent Elements in a Circular Array,"```python
from typing import List

class Solution:
    def maxAdjacentDistance(self, nums: List[int]) -> int:
        max_diff = 0
        n = len(nums)
        for i in range(n):
            diff = abs(nums[i] - nums[(i + 1) % n])
            if diff > max_diff:
                max_diff = diff
        return max_diff
```",Y,
find-valid-pair-of-adjacent-digits-in-string,Find Valid Pair of Adjacent Digits in String,"```python
class Solution:
    def findValidPair(self, s: str) -> str:
        from collections import defaultdict
        
        count = defaultdict(int)
        for ch in s:
            count[ch] += 1
        
        for i in range(len(s) - 1):
            first = s[i]
            second = s[i+1]
            if first != second:
                if int(first) == count[first] and int(second) == count[second]:
                    return first + second
        return """"
```",Y,
sum-of-variable-length-subarrays,Sum of Variable Length Subarrays,"```python
class Solution:
    def subarraySum(self, nums: List[int]) -> int:
        total = 0
        n = len(nums)
        for i in range(n):
            start = max(0, i - nums[i] + 1)
            subarray = nums[start:i+1]
            total += sum(subarray)
        return total
```",Y,
sum-of-good-numbers,Sum of Good Numbers,"```python
from typing import List

class Solution:
    def sumOfGoodNumbers(self, nums: List[int], k: int) -> int:
        total = 0
        n = len(nums)
        for i in range(n):
            left = i - k
            right = i + k
            is_good = True
            if left >= 0 and nums[i] <= nums[left]:
                is_good = False
            if right < n and nums[i] <= nums[right]:
                is_good = False
            if is_good:
                total += nums[i]
        return total
```",Y,
find-special-substring-of-length-k,Find Special Substring of Length K,"```python
class Solution:
    def hasSpecialSubstring(self, s: str, k: int) -> bool:
        n = len(s)
        for i in range(n - k + 1):
            substring = s[i:i+k]
            if len(set(substring)) == 1:
                left_ok = (i == 0) or (s[i-1] != substring[0])
                right_ok = (i + k == n) or (s[i+k] != substring[0])
                if left_ok and right_ok:
                    return True
        return False
```",Y,
zigzag-grid-traversal-with-skip,Zigzag Grid Traversal With Skip,"```python
from typing import List

class Solution:
    def zigzagTraversal(self, grid: List[List[int]]) -> List[int]:
        result = []
        m = len(grid)
        if m == 0:
            return result
        n = len(grid[0])
        
        for i in range(m):
            if i % 2 == 0:
                for j in range(0, n, 2):
                    result.append(grid[i][j])
            else:
                for j in range(n-1, -1, -2):
                    result.append(grid[i][j])
        
        return result
```",Y,
find-the-largest-almost-missing-integer,Find the Largest Almost Missing Integer,"```python
from typing import List

class Solution:
    def largestInteger(self, nums: List[int], k: int) -> int:
        count = {}
        n = len(nums)
        if k > n:
            return -1
        
        for i in range(n - k + 1):
            subarray = nums[i:i+k]
            unique_in_sub = set(subarray)
            for num in unique_in_sub:
                count[num] = count.get(num, 0) + 1
        
        result = -1
        for num in count:
            if count[num] == 1 and num > result:
                result = num
        
        return result
```",Y,
count-partitions-with-even-sum-difference,Count Partitions with Even Sum Difference,"```python
class Solution:
    def countPartitions(self, nums: List[int]) -> int:
        total_sum = sum(nums)
        prefix_sum = 0
        count = 0
        for num in nums[:-1]:
            prefix_sum += num
            right_sum = total_sum - prefix_sum
            if (prefix_sum - right_sum) % 2 == 0:
                count += 1
        return count
```",Y,
maximum-subarray-with-equal-products,Maximum Subarray With Equal Products,"```python
import math
from typing import List

class Solution:
    def maxLength(self, nums: List[int]) -> int:
        max_len = 0
        n = len(nums)
        
        for i in range(n):
            current_gcd = nums[i]
            current_lcm = nums[i]
            current_prod = nums[i]
            
            for j in range(i + 1, n):
                current_gcd = math.gcd(current_gcd, nums[j])
                current_lcm = (current_lcm * nums[j]) // math.gcd(current_lcm, nums[j])
                current_prod *= nums[j]
                
                if current_prod == current_lcm * current_gcd:
                    max_len = max(max_len, j - i + 1)
        
        return max_len
```",Y,
minimum-operations-to-make-columns-strictly-increasing,Minimum Operations to Make Columns Strictly Increasing,"```python
from typing import List

class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        m, n = len(grid), len(grid[0])
        operations = 0
        
        for j in range(n):
            for i in range(1, m):
                if grid[i][j] <= grid[i-1][j]:
                    diff = grid[i-1][j] - grid[i][j] + 1
                    operations += diff
                    grid[i][j] += diff
        
        return operations
```",Y,
count-subarrays-of-length-three-with-a-condition,Count Subarrays of Length Three With a Condition,"```python
from typing import List

class Solution:
    def countSubarrays(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums) - 2):
            first = nums[i]
            second = nums[i+1]
            third = nums[i+2]
            if first + third == second / 2:
                count += 1
        return count
```",Y,
substring-matching-pattern,Substring Matching Pattern,"```python
class Solution:
    def hasMatch(self, s: str, p: str) -> bool:
        star_index = p.find('*')
        prefix = p[:star_index]
        suffix = p[star_index + 1:]
        
        for i in range(len(s) + 1):
            if i < len(prefix):
                continue
            if len(s) - i < len(suffix):
                continue
            if s.startswith(prefix, i - len(prefix)) and s.endswith(suffix, i + len(suffix)):
                return True
        return False
```",Y,
smallest-number-with-all-set-bits,Smallest Number With All Set Bits,"```python
class Solution:
    def smallestNumber(self, n: int) -> int:
        if n == 0:
            return 1
        m = 1
        while m <= n:
            m = (m << 1) | 1
        return m
```",Y,
minimum-number-of-operations-to-make-elements-in-array-distinct,Minimum Number of Operations to Make Elements in Array Distinct,"```python
from typing import List

class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        operations = 0
        while True:
            if len(set(nums)) == len(nums):
                return operations
            operations += 1
            nums = nums[3:] if len(nums) >= 3 else []
```",Y,
transformed-array,Transformed Array,"```python
from typing import List

class Solution:
    def constructTransformedArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        result = [0] * n
        for i in range(n):
            if nums[i] == 0:
                result[i] = 0
            else:
                steps = nums[i]
                new_pos = (i + steps) % n
                result[i] = nums[new_pos]
        return result
```",Y,
minimum-positive-sum-subarray,Minimum Positive Sum Subarray ,"```python
from typing import List

class Solution:
    def minimumSumSubarray(self, nums: List[int], l: int, r: int) -> int:
        min_sum = float('inf')
        n = len(nums)
        
        for length in range(l, r + 1):
            current_sum = sum(nums[:length])
            if current_sum > 0:
                min_sum = min(min_sum, current_sum)
            
            for i in range(1, n - length + 1):
                current_sum = current_sum - nums[i-1] + nums[i + length - 1]
                if current_sum > 0:
                    min_sum = min(min_sum, current_sum)
        
        return min_sum if min_sum != float('inf') else -1
```",Y,
check-balanced-string,Check Balanced String,"```python
class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        for i, c in enumerate(num):
            digit = int(c)
            if i % 2 == 0:
                even_sum += digit
            else:
                odd_sum += digit
        return even_sum == odd_sum
```",Y,
button-with-longest-push-time,Button with Longest Push Time,"```python
from typing import List

class Solution:
    def buttonWithLongestTime(self, events: List[List[int]]) -> int:
        if not events:
            return -1
        
        max_time = -1
        result = events[0][0]
        prev_time = events[0][1]
        time_dict = {}
        
        for i in range(1, len(events)):
            index, time = events[i]
            duration = time - prev_time
            if index in time_dict:
                if duration > time_dict[index]:
                    time_dict[index] = duration
            else:
                time_dict[index] = duration
            prev_time = time
        
        first_index = events[0][0]
        first_time = events[0][1]
        if first_index in time_dict:
            if first_time > time_dict[first_index]:
                time_dict[first_index] = first_time
        else:
            time_dict[first_index] = first_time
        
        for button, duration in time_dict.items():
            if duration > max_time or (duration == max_time and button < result):
                max_time = duration
                result = button
        
        return result
```",Y,
smallest-divisible-digit-product-i,Smallest Divisible Digit Product I,"```python
class Solution:
    def smallestNumber(self, n: int, t: int) -> int:
        def product_digits(num):
            product = 1
            for digit in str(num):
                product *= int(digit)
            return product
        
        while True:
            if product_digits(n) % t == 0:
                return n
            n += 1
```",Y,
stone-removal-game,Stone Removal Game,"```python
class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False
        remaining = n - 10
        if remaining <= 0:
            return True
        return remaining > 9
```",Y,
minimum-operations-to-make-array-values-equal-to-k,Minimum Operations to Make Array Values Equal to K,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        operations = 0
        current_max = max(nums)
        
        if current_max < k:
            return -1
        
        while current_max > k:
            next_max = k
            for num in nums:
                if num > k and num < current_max:
                    next_max = max(next_max, num)
            operations += 1
            current_max = next_max
        
        return operations
```",Y,
find-the-original-typed-string-i,Find the Original Typed String I,"```python
class Solution:
    def possibleStringCount(self, word: str) -> int:
        if not word:
            return 0
        
        count = 0
        n = len(word)
        i = 0
        
        while i < n:
            current_char = word[i]
            j = i + 1
            while j < n and word[j] == current_char:
                j += 1
            length = j - i
            if length > 1:
                count += 1
            i = j
        
        if count == 0:
            return 1
        
        total = 0
        i = 0
        while i < n:
            current_char = word[i]
            j = i + 1
            while j < n and word[j] == current_char:
                j += 1
            length = j - i
            if length > 1:
                total += (length - 1)
            i = j
        
        return total + 1
```",Y,
make-array-elements-equal-to-zero,Make Array Elements Equal to Zero,"```python
from typing import List

class Solution:
    def countValidSelections(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        
        for start in range(n):
            if nums[start] == 0:
                for direction in [-1, 1]:  # -1 for left, 1 for right
                    temp_nums = nums.copy()
                    curr = start
                    dir_ = direction
                    valid = True
                    
                    while True:
                        if curr < 0 or curr >= n:
                            break
                        if temp_nums[curr] == 0:
                            curr += dir_
                        else:
                            temp_nums[curr] -= 1
                            dir_ *= -1
                            curr += dir_
                    
                    if all(x == 0 for x in temp_nums):
                        count += 1
        
        return count
```",Y,
adjacent-increasing-subarrays-detection-i,Adjacent Increasing Subarrays Detection I,"```python
from typing import List

class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        increasing = []
        
        for i in range(n - k + 1):
            is_increasing = True
            for j in range(i + 1, i + k):
                if nums[j] <= nums[j - 1]:
                    is_increasing = False
                    break
            if is_increasing:
                increasing.append(i)
        
        for i in range(len(increasing) - 1):
            if increasing[i + 1] == increasing[i] + k:
                return True
        
        return False
```",Y,
find-x-sum-of-all-k-long-subarrays-i,Find X-Sum of All K-Long Subarrays I,"```python
from typing import List
from collections import defaultdict

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        answer = []
        n = len(nums)
        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            freq = defaultdict(int)
            for num in subarray:
                freq[num] += 1
            
            sorted_items = sorted(freq.items(), key=lambda item: (-item[1], -item[0]))
            
            selected = []
            for item in sorted_items[:x]:
                selected.extend([item[0]] * item[1])
            
            answer.append(sum(selected))
        return answer
```",Y,
minimum-element-after-replacement-with-digit-sum,Minimum Element After Replacement With Digit Sum,"```python
from typing import List

class Solution:
    def minElement(self, nums: List[int]) -> int:
        min_val = float('inf')
        for num in nums:
            digit_sum = 0
            n = num
            while n > 0:
                digit_sum += n % 10
                n = n // 10
            if digit_sum < min_val:
                min_val = digit_sum
        return min_val
```",Y,
construct-the-minimum-bitwise-array-i,Construct the Minimum Bitwise Array I,"```python
from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            found = -1
            for x in range(num):
                if (x | (x + 1)) == num:
                    found = x
                    break
            ans.append(found)
        return ans
```",Y,
find-the-k-th-character-in-string-game-i,Find the K-th Character in String Game I,"```python
class Solution:
    def kthCharacter(self, k: int) -> str:
        word = ""a""
        while len(word) < k:
            next_part = []
            for c in word:
                if c == 'z':
                    next_part.append('a')
                else:
                    next_part.append(chr(ord(c) + 1))
            word += ''.join(next_part)
        return word[k-1]
```",Y,
find-indices-of-stable-mountains,Find Indices of Stable Mountains,"```python
from typing import List

class Solution:
    def stableMountains(self, height: List[int], threshold: int) -> List[int]:
        result = []
        for i in range(1, len(height)):
            if height[i-1] > threshold:
                result.append(i)
        return result
```",Y,
the-two-sneaky-numbers-of-digitville,The Two Sneaky Numbers of Digitville,"```python
from typing import List

class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        count = {}
        result = []
        for num in nums:
            if num in count:
                count[num] += 1
            else:
                count[num] = 1
        for num, freq in count.items():
            if freq == 2:
                result.append(num)
        return result
```",Y,
find-the-key-of-the-numbers,Find the Key of the Numbers,"```python
class Solution:
    def generateKey(self, num1: int, num2: int, num3: int) -> int:
        s1 = f""{num1:04d}""
        s2 = f""{num2:04d}""
        s3 = f""{num3:04d}""
        key_digits = []
        for i in range(4):
            min_digit = min(s1[i], s2[i], s3[i])
            key_digits.append(min_digit)
        key_str = ''.join(key_digits)
        return int(key_str)
```",Y,
convert-date-to-binary,Convert Date to Binary,"```python
class Solution:
    def convertDateToBinary(self, date: str) -> str:
        year, month, day = date.split('-')
        binary_year = bin(int(year))[2:]
        binary_month = bin(int(month))[2:]
        binary_day = bin(int(day))[2:]
        return f""{binary_year}-{binary_month}-{binary_day}""
```",Y,
final-array-state-after-k-multiplication-operations-i,Final Array State After K Multiplication Operations I,"```python
from typing import List

class Solution:
    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:
        for _ in range(k):
            min_val = min(nums)
            index = nums.index(min_val)
            nums[index] = min_val * multiplier
        return nums
```",Y,
check-if-two-chessboard-squares-have-the-same-color,Check if Two Chessboard Squares Have the Same Color,"```python
class Solution:
    def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:
        def get_color(coordinate):
            x = ord(coordinate[0]) - ord('a')
            y = int(coordinate[1]) - 1
            return (x + y) % 2 == 0
        
        return get_color(coordinate1) == get_color(coordinate2)
```",Y,
count-substrings-that-satisfy-k-constraint-i,Count Substrings That Satisfy K-Constraint I,"```python
class Solution:
    def countKConstraintSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        count = 0
        for i in range(n):
            zeros = 0
            ones = 0
            for j in range(i, n):
                if s[j] == '0':
                    zeros += 1
                else:
                    ones += 1
                if zeros <= k or ones <= k:
                    count += 1
                else:
                    break
        return count
```",Y,
snake-in-matrix,Snake in Matrix,"```python
class Solution:
    def finalPositionOfSnake(self, n: int, commands: List[str]) -> int:
        x, y = 0, 0
        for cmd in commands:
            if cmd == ""UP"":
                x -= 1
            elif cmd == ""DOWN"":
                x += 1
            elif cmd == ""LEFT"":
                y -= 1
            elif cmd == ""RIGHT"":
                y += 1
        return x * n + y
```",Y,
find-the-number-of-winning-players,Find the Number of Winning Players,"```python
from typing import List

class Solution:
    def winningPlayerCount(self, n: int, pick: List[List[int]]) -> int:
        color_counts = {}
        for player, color in pick:
            if player not in color_counts:
                color_counts[player] = {}
            if color not in color_counts[player]:
                color_counts[player][color] = 0
            color_counts[player][color] += 1
        
        winners = 0
        for player in range(n):
            max_count = max(color_counts.get(player, {}).values(), default=0)
            if max_count > player:
                winners += 1
        return winners
```",Y,
design-neighbor-sum-service,Design Neighbor Sum Service,"```python
from typing import List

class NeighborSum:

    def __init__(self, grid: List[List[int]]):
        self.grid = grid
        self.n = len(grid)
        self.pos = {}
        for i in range(self.n):
            for j in range(self.n):
                self.pos[grid[i][j]] = (i, j)

    def adjacentSum(self, value: int) -> int:
        i, j = self.pos[value]
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        total = 0
        for di, dj in directions:
            ni, nj = i + di, j + dj
            if 0 <= ni < self.n and 0 <= nj < self.n:
                total += self.grid[ni][nj]
        return total

    def diagonalSum(self, value: int) -> int:
        i, j = self.pos[value]
        directions = [(-1, -1), (-1, 1), (1, -1), (1, 1)]
        total = 0
        for di, dj in directions:
            ni, nj = i + di, j + dj
            if 0 <= ni < self.n and 0 <= nj < self.n:
                total += self.grid[ni][nj]
        return total
```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
find-if-digit-game-can-be-won,Find if Digit Game Can Be Won,"```python
from typing import List

class Solution:
    def canAliceWin(self, nums: List[int]) -> bool:
        single_sum = sum(num for num in nums if num < 10)
        double_sum = sum(num for num in nums if num >= 10)
        total_sum = sum(nums)
        return single_sum > (total_sum - single_sum) or double_sum > (total_sum - double_sum)
```",Y,
find-the-winning-player-in-coin-game,Find the Winning Player in Coin Game,"```python
class Solution:
    def winningPlayer(self, x: int, y: int) -> str:
        max_turns = min(x, y // 4)
        if max_turns == 0:
            if x >= 1 and y >= 4:
                return ""Alice""
            else:
                return ""Bob""
        remaining_x = x - max_turns
        remaining_y = y - 4 * max_turns
        if (remaining_x >= 1 and remaining_y >= 4) or (remaining_x == 0 and remaining_y == 0):
            return ""Alice"" if max_turns % 2 == 1 else ""Bob""
        else:
            return ""Alice"" if max_turns % 2 == 0 else ""Bob""
```",Y,
number-of-bit-changes-to-make-two-integers-equal,Number of Bit Changes to Make Two Integers Equal,"```python
class Solution:
    def minChanges(self, n: int, k: int) -> int:
        if n == k:
            return 0
        if n < k:
            return -1
        count = 0
        while n > 0 or k > 0:
            bit_n = n & 1
            bit_k = k & 1
            if bit_n == 0 and bit_k == 1:
                return -1
            if bit_n == 1 and bit_k == 0:
                count += 1
            n = n >> 1
            k = k >> 1
        return count
```",Y,
lexicographically-smallest-string-after-a-swap,Lexicographically Smallest String After a Swap,"```python
class Solution:
    def getSmallestString(self, s: str) -> str:
        s_list = list(s)
        n = len(s_list)
        for i in range(n - 1):
            if (int(s_list[i]) % 2) == (int(s_list[i + 1]) % 2):
                if s_list[i] > s_list[i + 1]:
                    s_list[i], s_list[i + 1] = s_list[i + 1], s_list[i]
                    return ''.join(s_list)
        return s
```",Y,
find-minimum-operations-to-make-all-elements-divisible-by-three,Find Minimum Operations to Make All Elements Divisible by Three,"```python
from typing import List

class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        operations = 0
        for num in nums:
            remainder = num % 3
            if remainder == 1:
                operations += 1
            elif remainder == 2:
                operations += 1
        return operations
```",Y,
minimum-average-of-smallest-and-largest-elements,Minimum Average of Smallest and Largest Elements,"```python
from typing import List

class Solution:
    def minimumAverage(self, nums: List[int]) -> float:
        averages = []
        nums_sorted = sorted(nums)
        left, right = 0, len(nums_sorted) - 1
        while left < right:
            min_element = nums_sorted[left]
            max_element = nums_sorted[right]
            average = (min_element + max_element) / 2
            averages.append(average)
            left += 1
            right -= 1
        return min(averages)
```",Y,
maximum-height-of-a-triangle,Maximum Height of a Triangle,"```python
class Solution:
    def maxHeightOfTriangle(self, red: int, blue: int) -> int:
        max_height = 0
        r, b = red, blue
        height = 0
        turn = 0  # 0 for red, 1 for blue
        while True:
            needed = height + 1
            if turn == 0:
                if r >= needed:
                    r -= needed
                    height += 1
                    turn = 1
                else:
                    break
            else:
                if b >= needed:
                    b -= needed
                    height += 1
                    turn = 0
                else:
                    break
        max_height = max(max_height, height)
        
        r, b = red, blue
        height = 0
        turn = 1  # 0 for red, 1 for blue
        while True:
            needed = height + 1
            if turn == 0:
                if r >= needed:
                    r -= needed
                    height += 1
                    turn = 1
                else:
                    break
            else:
                if b >= needed:
                    b -= needed
                    height += 1
                    turn = 0
                else:
                    break
        max_height = max(max_height, height)
        
        return max_height
```",Y,
find-the-encrypted-string,Find the Encrypted String,"```python
class Solution:
    def getEncryptedString(self, s: str, k: int) -> str:
        encrypted = []
        n = len(s)
        for c in s:
            original_pos = ord(c) - ord('a')
            new_pos = (original_pos + k) % 26
            new_char = chr(ord('a') + new_pos)
            encrypted.append(new_char)
        return ''.join(encrypted)
```",Y,
alternating-groups-i,Alternating Groups I,"```python
from typing import List

class Solution:
    def numberOfAlternatingGroups(self, colors: List[int]) -> int:
        n = len(colors)
        count = 0
        for i in range(n):
            left = colors[i]
            middle = colors[(i + 1) % n]
            right = colors[(i + 2) % n]
            if middle != left and middle != right:
                count += 1
        return count
```",Y,
find-the-child-who-has-the-ball-after-k-seconds,Find the Child Who Has the Ball After K Seconds,"```python
class Solution:
    def numberOfChild(self, n: int, k: int) -> int:
        cycle_length = (n - 1) * 2
        k %= cycle_length
        if k < n:
            return k
        else:
            return 2 * (n - 1) - k
```",Y,
clear-digits,Clear Digits,"```python
class Solution:
    def clearDigits(self, s: str) -> str:
        stack = []
        for char in s:
            if char.isdigit():
                if stack and not stack[-1].isdigit():
                    stack.pop()
            else:
                stack.append(char)
        return ''.join(stack)
```",Y,
find-the-number-of-good-pairs-i,Find the Number of Good Pairs I,"```python
from typing import List

class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:
        count = 0
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                if nums1[i] % (nums2[j] * k) == 0:
                    count += 1
        return count
```",Y,
special-array-i,Special Array I,"```python
from typing import List

class Solution:
    def isArraySpecial(self, nums: List[int]) -> bool:
        for i in range(len(nums) - 1):
            if (nums[i] % 2) == (nums[i + 1] % 2):
                return False
        return True
```",Y,
find-the-xor-of-numbers-which-appear-twice,Find the XOR of Numbers Which Appear Twice,"```python
from typing import List

class Solution:
    def duplicateNumbersXOR(self, nums: List[int]) -> int:
        seen = set()
        result = 0
        for num in nums:
            if num in seen:
                result ^= num
            else:
                seen.add(num)
        return result
```",Y,
minimum-number-of-chairs-in-a-waiting-room,Minimum Number of Chairs in a Waiting Room,"```python
class Solution:
    def minimumChairs(self, s: str) -> int:
        current = 0
        max_chairs = 0
        for event in s:
            if event == 'E':
                current += 1
                if current > max_chairs:
                    max_chairs = current
            else:
                current -= 1
        return max_chairs
```",Y,
count-pairs-that-form-a-complete-day-i,Count Pairs That Form a Complete Day I,"```python
from typing import List

class Solution:
    def countCompleteDayPairs(self, hours: List[int]) -> int:
        count = 0
        n = len(hours)
        for i in range(n):
            for j in range(i + 1, n):
                if (hours[i] + hours[j]) % 24 == 0:
                    count += 1
        return count
```",Y,
check-if-grid-satisfies-conditions,Check if Grid Satisfies Conditions,"```python
from typing import List

class Solution:
    def satisfiesConditions(self, grid: List[List[int]]) -> bool:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        
        for i in range(m):
            for j in range(n):
                if i + 1 < m and grid[i][j] != grid[i + 1][j]:
                    return False
                if j + 1 < n and grid[i][j] == grid[i][j + 1]:
                    return False
        return True
```",Y,
permutation-difference-between-two-strings,Permutation Difference between Two Strings,"```python
class Solution:
    def findPermutationDifference(self, s: str, t: str) -> int:
        s_indices = {char: idx for idx, char in enumerate(s)}
        t_indices = {char: idx for idx, char in enumerate(t)}
        total = 0
        for char in s:
            total += abs(s_indices[char] - t_indices[char])
        return total
```",Y,
count-the-number-of-special-characters-i,Count the Number of Special Characters I,"```python
class Solution:
    def numberOfSpecialChars(self, word: str) -> int:
        lowercase = set()
        uppercase = set()
        for c in word:
            if c.islower():
                lowercase.add(c)
            else:
                uppercase.add(c.lower())
        return len(lowercase & uppercase)
```",Y,
make-a-square-with-the-same-color,Make a Square with the Same Color,"```python
from typing import List

class Solution:
    def canMakeSquare(self, grid: List[List[str]]) -> bool:
        for i in range(2):
            for j in range(2):
                b_count = 0
                w_count = 0
                for x in range(i, i+2):
                    for y in range(j, j+2):
                        if grid[x][y] == 'B':
                            b_count += 1
                        else:
                            w_count += 1
                if b_count >= 3 or w_count >= 3 or b_count == 0 or w_count == 0:
                    return True
        return False
```",Y,
find-the-integer-added-to-array-i,Find the Integer Added to Array I,"```python
from typing import List

class Solution:
    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:
        return min(nums2) - min(nums1)
```",Y,
valid-word,Valid Word,"```python
class Solution:
    def isValid(self, word: str) -> bool:
        if len(word) < 3:
            return False
        
        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}
        has_vowel = False
        has_consonant = False
        
        for c in word:
            if not (c.isalpha() or c.isdigit()):
                return False
            if c.isalpha():
                if c in vowels:
                    has_vowel = True
                else:
                    has_consonant = True
        
        return has_vowel and has_consonant
```",Y,
shortest-subarray-with-or-at-least-k-i,Shortest Subarray With OR at Least K I,"```python
from typing import List

class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
        min_len = float('inf')
        n = len(nums)
        
        for i in range(n):
            current_or = 0
            for j in range(i, n):
                current_or |= nums[j]
                if current_or >= k:
                    min_len = min(min_len, j - i + 1)
                    break  # Once found, break to find shorter subarrays
        
        return min_len if min_len != float('inf') else -1
```",Y,
score-of-a-string,Score of a String,"```python
class Solution:
    def scoreOfString(self, s: str) -> int:
        score = 0
        for i in range(len(s) - 1):
            score += abs(ord(s[i]) - ord(s[i + 1]))
        return score
```",Y,
longest-strictly-increasing-or-strictly-decreasing-subarray,Longest Strictly Increasing or Strictly Decreasing Subarray,"```python
from typing import List

class Solution:
    def longestMonotonicSubarray(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        max_len = 1
        inc_len = 1
        dec_len = 1
        
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                inc_len += 1
                dec_len = 1
            elif nums[i] < nums[i-1]:
                dec_len += 1
                inc_len = 1
            else:
                inc_len = 1
                dec_len = 1
            max_len = max(max_len, inc_len, dec_len)
        
        return max_len
```",Y,
harshad-number,Harshad Number,"```python
class Solution:
    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:
        digit_sum = sum(int(d) for d in str(x))
        if x % digit_sum == 0:
            return digit_sum
        else:
            return -1
```",Y,
find-the-sum-of-encrypted-integers,Find the Sum of Encrypted Integers,"```python
from typing import List

class Solution:
    def sumOfEncryptedInt(self, nums: List[int]) -> int:
        total = 0
        for num in nums:
            s = str(num)
            max_digit = max(s)
            encrypted = int(max_digit * len(s))
            total += encrypted
        return total
```",Y,
latest-time-you-can-obtain-after-replacing-characters,Latest Time You Can Obtain After Replacing Characters,"```python
class Solution:
    def findLatestTime(self, s: str) -> str:
        time = list(s)
        if time[0] == '?':
            if time[1] == '?':
                time[0] = '1'
                time[1] = '1'
            else:
                if int(time[1]) > 1:
                    time[0] = '0'
                else:
                    time[0] = '1'
        if time[1] == '?':
            if time[0] == '1':
                time[1] = '1'
            else:
                time[1] = '9'
        
        if time[3] == '?':
            time[3] = '5'
        if time[4] == '?':
            time[4] = '9'
        
        return ''.join(time)
```",Y,
existence-of-a-substring-in-a-string-and-its-reverse,Existence of a Substring in a String and Its Reverse,"```python
class Solution:
    def isSubstringPresent(self, s: str) -> bool:
        reversed_s = s[::-1]
        substrings = set()
        for i in range(len(s) - 1):
            substrings.add(s[i:i+2])
        for i in range(len(reversed_s) - 1):
            if reversed_s[i:i+2] in substrings:
                return True
        return False
```",Y,
maximum-length-substring-with-two-occurrences,Maximum Length Substring With Two Occurrences,"```python
class Solution:
    def maximumLengthSubstring(self, s: str) -> int:
        max_len = 0
        n = len(s)
        for i in range(n):
            freq = {}
            for j in range(i, n):
                char = s[j]
                freq[char] = freq.get(char, 0) + 1
                if freq[char] > 2:
                    break
                current_len = j - i + 1
                if current_len > max_len:
                    max_len = current_len
        return max_len
```",Y,
distribute-elements-into-two-arrays-i,Distribute Elements Into Two Arrays I,"```python
from typing import List

class Solution:
    def resultArray(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        arr1 = [nums[0]]
        arr2 = [nums[1]] if len(nums) > 1 else []
        
        for i in range(2, len(nums)):
            if arr1[-1] > arr2[-1]:
                arr1.append(nums[i])
            else:
                arr2.append(nums[i])
        
        return arr1 + arr2
```",Y,
apple-redistribution-into-boxes,Apple Redistribution into Boxes,"```python
from typing import List

class Solution:
    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        total_apples = sum(apple)
        capacity.sort(reverse=True)
        boxes_used = 0
        current_capacity = 0
        
        for cap in capacity:
            if current_capacity >= total_apples:
                break
            current_capacity += cap
            boxes_used += 1
        
        return boxes_used
```",Y,
minimum-operations-to-exceed-threshold-value-i,Minimum Operations to Exceed Threshold Value I,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        nums_sorted = sorted(nums)
        operations = 0
        for num in nums_sorted:
            if num < k:
                operations += 1
            else:
                break
        return operations
```",Y,
modify-the-matrix,Modify the Matrix,"```python
from typing import List

class Solution:
    def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        n = len(matrix[0]) if m > 0 else 0
        answer = [row[:] for row in matrix]
        
        for j in range(n):
            max_val = -1
            for i in range(m):
                if matrix[i][j] != -1 and matrix[i][j] > max_val:
                    max_val = matrix[i][j]
            for i in range(m):
                if answer[i][j] == -1:
                    answer[i][j] = max_val
        return answer
```",Y,
split-the-array,Split the Array,"```python
from typing import List
from collections import defaultdict

class Solution:
    def isPossibleToSplit(self, nums: List[int]) -> bool:
        freq = defaultdict(int)
        for num in nums:
            freq[num] += 1
            if freq[num] > 2:
                return False
        return True
```",Y,
type-of-triangle,Type of Triangle,"```python
from typing import List

class Solution:
    def triangleType(self, nums: List[int]) -> str:
        a, b, c = sorted(nums)
        if a + b <= c:
            return ""none""
        if a == b == c:
            return ""equilateral""
        if a == b or b == c or a == c:
            return ""isosceles""
        return ""scalene""
```",Y,
maximum-number-of-operations-with-the-same-score-i,Maximum Number of Operations With the Same Score I,"```python
from typing import List

class Solution:
    def maxOperations(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return 0
        target = nums[0] + nums[1]
        count = 1
        i = 2
        while i + 1 <= len(nums):
            current_sum = nums[i] + nums[i+1] if i + 1 < len(nums) else 0
            if current_sum == target:
                count += 1
                i += 2
            else:
                break
        return count
```",Y,
number-of-changing-keys,Number of Changing Keys,"```python
class Solution:
    def countKeyChanges(self, s: str) -> int:
        if not s:
            return 0
        count = 0
        prev = s[0].lower()
        for c in s[1:]:
            current = c.lower()
            if current != prev:
                count += 1
                prev = current
        return count
```",Y,
ant-on-the-boundary,Ant on the Boundary,"```python
from typing import List

class Solution:
    def returnToBoundaryCount(self, nums: List[int]) -> int:
        position = 0
        count = 0
        for num in nums:
            position += num
            if position == 0:
                count += 1
        return count
```",Y,
count-prefix-and-suffix-pairs-i,Count Prefix and Suffix Pairs I,"```python
class Solution:
    def countPrefixSuffixPairs(self, words: List[str]) -> int:
        count = 0
        n = len(words)
        for i in range(n):
            for j in range(i + 1, n):
                s1 = words[i]
                s2 = words[j]
                if s2.startswith(s1) and s2.endswith(s1):
                    count += 1
        return count
```",Y,
minimum-number-of-pushes-to-type-word-i,Minimum Number of Pushes to Type Word I,"```python
class Solution:
    def minimumPushes(self, word: str) -> int:
        n = len(word)
        res = 0
        for i in range(n):
            res += (i // 8) + 1
        return res
```",Y,
divide-an-array-into-subarrays-with-minimum-cost-i,Divide an Array Into Subarrays With Minimum Cost I,"```python
from typing import List

class Solution:
    def minimumCost(self, nums: List[int]) -> int:
        n = len(nums)
        min_sum = float('inf')
        
        for i in range(1, n):
            for j in range(i + 1, n):
                current_sum = nums[0] + nums[i] + nums[j]
                if current_sum < min_sum:
                    min_sum = current_sum
        
        return min_sum
```",Y,
count-the-number-of-incremovable-subarrays-i,Count the Number of Incremovable Subarrays I,"```python
from typing import List

class Solution:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        
        for i in range(n):
            for j in range(i, n):
                remaining = nums[:i] + nums[j+1:]
                strictly_increasing = True
                for k in range(len(remaining) - 1):
                    if remaining[k] >= remaining[k+1]:
                        strictly_increasing = False
                        break
                if strictly_increasing:
                    count += 1
        
        return count
```",Y,
maximum-area-of-longest-diagonal-rectangle,Maximum Area of Longest Diagonal Rectangle,"```python
from typing import List

class Solution:
    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -> int:
        max_diag = 0
        max_area = 0
        for length, width in dimensions:
            diag = length ** 2 + width ** 2
            area = length * width
            if diag > max_diag:
                max_diag = diag
                max_area = area
            elif diag == max_diag and area > max_area:
                max_area = area
        return max_area
```",Y,
check-if-bitwise-or-has-trailing-zeros,Check if Bitwise OR Has Trailing Zeros,"```python
from typing import List

class Solution:
    def hasTrailingZeros(self, nums: List[int]) -> bool:
        count = 0
        for num in nums:
            if num % 2 == 0:
                count += 1
                if count >= 2:
                    return True
        return False
```",Y,
count-elements-with-maximum-frequency,Count Elements With Maximum Frequency,"```python
from typing import List
from collections import defaultdict

class Solution:
    def maxFrequencyElements(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for num in nums:
            freq[num] += 1
        max_freq = max(freq.values()) if freq else 0
        return sum(count for count in freq.values() if count == max_freq)
```",Y,
smallest-missing-integer-greater-than-sequential-prefix-sum,Smallest Missing Integer Greater Than Sequential Prefix Sum,"```python
from typing import List

class Solution:
    def missingInteger(self, nums: List[int]) -> int:
        if not nums:
            return 1
        
        max_prefix_len = 1
        current_len = 1
        
        for i in range(1, len(nums)):
            if nums[i] == nums[i-1] + 1:
                current_len += 1
                if current_len > max_prefix_len:
                    max_prefix_len = current_len
            else:
                break
        
        prefix_sum = sum(nums[:max_prefix_len])
        num_set = set(nums)
        
        x = prefix_sum
        while x in num_set:
            x += 1
        
        return x
```",Y,
find-missing-and-repeated-values,Find Missing and Repeated Values,"```python
from typing import List

class Solution:
    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:
        n = len(grid)
        total_numbers = n * n
        count = [0] * (total_numbers + 1)
        
        for row in grid:
            for num in row:
                count[num] += 1
        
        a, b = 0, 0
        for num in range(1, total_numbers + 1):
            if count[num] == 2:
                a = num
            if count[num] == 0:
                b = num
        
        return [a, b]
```",Y,
minimum-number-game,Minimum Number Game,"```python
from typing import List

class Solution:
    def numberGame(self, nums: List[int]) -> List[int]:
        nums_sorted = sorted(nums)
        arr = []
        for i in range(0, len(nums_sorted), 2):
            if i + 1 < len(nums_sorted):
                arr.append(nums_sorted[i+1])
                arr.append(nums_sorted[i])
        return arr
```",Y,
find-the-peaks,Find the Peaks,"```python
from typing import List

class Solution:
    def findPeaks(self, mountain: List[int]) -> List[int]:
        peaks = []
        for i in range(1, len(mountain) - 1):
            if mountain[i] > mountain[i - 1] and mountain[i] > mountain[i + 1]:
                peaks.append(i)
        return peaks
```",Y,
count-tested-devices-after-test-operations,Count Tested Devices After Test Operations,"```python
from typing import List

class Solution:
    def countTestedDevices(self, batteryPercentages: List[int]) -> int:
        count = 0
        for i in range(len(batteryPercentages)):
            if batteryPercentages[i] > 0:
                count += 1
                for j in range(i + 1, len(batteryPercentages)):
                    batteryPercentages[j] = max(0, batteryPercentages[j] - 1)
        return count
```",Y,
matrix-similarity-after-cyclic-shifts,Matrix Similarity After Cyclic Shifts,"```python
from typing import List

class Solution:
    def areSimilar(self, mat: List[List[int]], k: int) -> bool:
        if not mat:
            return True
        
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        
        original = [row.copy() for row in mat]
        
        for _ in range(k):
            for i in range(m):
                if i % 2 == 0:
                    shift = k % n
                    mat[i] = mat[i][shift:] + mat[i][:shift]
                else:
                    shift = k % n
                    mat[i] = mat[i][-shift:] + mat[i][:-shift]
        
        return mat == original
```",Y,
make-three-strings-equal,Make Three Strings Equal,"```python
class Solution:
    def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:
        min_len = min(len(s1), len(s2), len(s3))
        common_len = 0
        for i in range(min_len):
            if s1[i] == s2[i] == s3[i]:
                common_len += 1
            else:
                break
        if common_len == 0:
            return -1
        return (len(s1) - common_len) + (len(s2) - common_len) + (len(s3) - common_len)
```",Y,
find-common-elements-between-two-arrays,Find Common Elements Between Two Arrays,"```python
class Solution:
    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:
        set1 = set(nums1)
        set2 = set(nums2)
        answer1 = sum(1 for num in nums1 if num in set2)
        answer2 = sum(1 for num in nums2 if num in set1)
        return [answer1, answer2]
```",Y,
distribute-candies-among-children-i,Distribute Candies Among Children I,"```python
class Solution:
    def distributeCandies(self, n: int, limit: int) -> int:
        count = 0
        for a in range(0, min(n, limit) + 1):
            for b in range(0, min(n - a, limit) + 1):
                c = n - a - b
                if c >= 0 and c <= limit:
                    count += 1
        return count
```",Y,
find-words-containing-character,Find Words Containing Character,"```python
class Solution:
    def findWordsContaining(self, words: List[str], x: str) -> List[int]:
        result = []
        for index, word in enumerate(words):
            if x in word:
                result.append(index)
        return result
```",Y,
maximum-strong-pair-xor-i,Maximum Strong Pair XOR I,"```python
from typing import List

class Solution:
    def maximumStrongPairXor(self, nums: List[int]) -> int:
        max_xor = 0
        n = len(nums)
        for i in range(n):
            for j in range(i, n):
                x, y = nums[i], nums[j]
                if abs(x - y) <= min(x, y):
                    max_xor = max(max_xor, x ^ y)
        return max_xor
```",Y,
find-champion-i,Find Champion I,"```python
from typing import List

class Solution:
    def findChampion(self, grid: List[List[int]]) -> int:
        n = len(grid)
        for i in range(n):
            is_champion = True
            for j in range(n):
                if i != j and grid[j][i] == 1:
                    is_champion = False
                    break
            if is_champion:
                return i
        return -1
```",Y,
find-the-k-or-of-an-array,Find the K-or of an Array,"```python
from typing import List

class Solution:
    def findKOr(self, nums: List[int], k: int) -> int:
        result = 0
        for i in range(32):
            mask = 1 << i
            count = 0
            for num in nums:
                if num & mask:
                    count += 1
                    if count >= k:
                        break
            if count >= k:
                result |= mask
        return result
```",Y,
minimum-sum-of-mountain-triplets-i,Minimum Sum of Mountain Triplets I,"```python
from typing import List

class Solution:
    def minimumSum(self, nums: List[int]) -> int:
        min_sum = float('inf')
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j + 1, n):
                    if nums[i] < nums[j] and nums[k] < nums[j]:
                        current_sum = nums[i] + nums[j] + nums[k]
                        if current_sum < min_sum:
                            min_sum = current_sum
        return min_sum if min_sum != float('inf') else -1
```",Y,
divisible-and-non-divisible-sums-difference,Divisible and Non-divisible Sums Difference,"```python
class Solution:
    def differenceOfSums(self, n: int, m: int) -> int:
        total_sum = n * (n + 1) // 2
        k = n // m
        divisible_sum = m * k * (k + 1) // 2
        non_divisible_sum = total_sum - divisible_sum
        return non_divisible_sum - divisible_sum
```",Y,
find-indices-with-index-and-value-difference-i,Find Indices With Index and Value Difference I,"```python
from typing import List

class Solution:
    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:
        n = len(nums)
        for i in range(n):
            for j in range(n):
                if abs(i - j) >= indexDifference and abs(nums[i] - nums[j]) >= valueDifference:
                    return [i, j]
        return [-1, -1]
```",Y,
last-visited-integers,Last Visited Integers,"```python
from typing import List

class Solution:
    def lastVisitedIntegers(self, nums: List[int]) -> List[int]:
        seen = []
        ans = []
        k = 0
        
        for num in nums:
            if num != -1:
                seen.insert(0, num)
                k = 0
            else:
                k += 1
                if k <= len(seen):
                    ans.append(seen[k - 1])
                else:
                    ans.append(-1)
        
        return ans
```",Y,
subarrays-distinct-element-sum-of-squares-i,Subarrays Distinct Element Sum of Squares I,"```python
class Solution:
    def sumCounts(self, nums: List[int]) -> int:
        total = 0
        n = len(nums)
        for i in range(n):
            distinct = set()
            for j in range(i, n):
                distinct.add(nums[j])
                total += len(distinct) ** 2
        return total
```",Y,
maximum-value-of-an-ordered-triplet-i,Maximum Value of an Ordered Triplet I,"```python
from typing import List

class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        max_val = 0
        n = len(nums)
        for i in range(n - 2):
            for j in range(i + 1, n - 1):
                for k in range(j + 1, n):
                    current = (nums[i] - nums[j]) * nums[k]
                    if current > max_val:
                        max_val = current
        return max_val if max_val > 0 else 0
```",Y,
longest-unequal-adjacent-groups-subsequence-i,Longest Unequal Adjacent Groups Subsequence I,"```python
from typing import List

class Solution:
    def getLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:
        if not words:
            return []
        
        n = len(words)
        dp = [1] * n
        prev = [-1] * n
        
        for i in range(1, n):
            for j in range(i):
                if groups[i] != groups[j] and dp[j] + 1 > dp[i]:
                    dp[i] = dp[j] + 1
                    prev[i] = j
        
        max_len = max(dp)
        max_index = dp.index(max_len)
        
        subsequence = []
        current = max_index
        while current != -1:
            subsequence.append(words[current])
            current = prev[current]
        
        return subsequence[::-1]
```",Y,
sum-of-values-at-indices-with-k-set-bits,Sum of Values at Indices With K Set Bits,"```python
class Solution:
    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:
        total = 0
        for i in range(len(nums)):
            if bin(i).count('1') == k:
                total += nums[i]
        return total
```",Y,
maximum-odd-binary-number,Maximum Odd Binary Number,"```python
class Solution:
    def maximumOddBinaryNumber(self, s: str) -> str:
        count_ones = s.count('1')
        count_zeros = len(s) - count_ones
        if count_ones == 1:
            return '0' * count_zeros + '1'
        else:
            return '1' * (count_ones - 1) + '0' * count_zeros + '1'
```",Y,
minimum-right-shifts-to-sort-the-array,Minimum Right Shifts to Sort the Array,"```python
from typing import List

class Solution:
    def minimumRightShifts(self, nums: List[int]) -> int:
        n = len(nums)
        sorted_nums = sorted(nums)
        for shift in range(n):
            if all(nums[(i + shift) % n] == sorted_nums[i] for i in range(n)):
                return shift
        return -1
```",Y,
minimum-operations-to-collect-elements,Minimum Operations to Collect Elements,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        collected = set()
        operations = 0
        for num in reversed(nums):
            operations += 1
            if num <= k:
                collected.add(num)
                if len(collected) == k:
                    return operations
        return operations
```",Y,
points-that-intersect-with-cars,Points That Intersect With Cars,"```python
class Solution:
    def numberOfPoints(self, nums: List[List[int]]) -> int:
        covered = set()
        for start, end in nums:
            covered.update(range(start, end + 1))
        return len(covered)
```",Y,
furthest-point-from-origin,Furthest Point From Origin,"```python
class Solution:
    def furthestDistanceFromOrigin(self, moves: str) -> int:
        left = moves.count('L')
        right = moves.count('R')
        underscore = moves.count('_')
        return abs(left - right) + underscore
```",Y,
check-if-strings-can-be-made-equal-with-operations-i,Check if Strings Can be Made Equal With Operations I,"```python
class Solution:
    def canBeEqual(self, s1: str, s2: str) -> bool:
        if s1 == s2:
            return True
        return (sorted(s1[0] + s1[2]) == sorted(s2[0] + s2[2]) and 
                sorted(s1[1] + s1[3]) == sorted(s2[1] + s2[3]))
```",Y,
count-symmetric-integers,  Count Symmetric Integers,"```python
class Solution:
    def countSymmetricIntegers(self, low: int, high: int) -> int:
        count = 0
        for num in range(low, high + 1):
            s = str(num)
            n = len(s)
            if n % 2 != 0:
                continue
            half = n // 2
            first_sum = sum(int(d) for d in s[:half])
            second_sum = sum(int(d) for d in s[half:])
            if first_sum == second_sum:
                count += 1
        return count
```",Y,
check-if-a-string-is-an-acronym-of-words,Check if a String Is an Acronym of Words,"```python
from typing import List

class Solution:
    def isAcronym(self, words: List[str], s: str) -> bool:
        if len(words) != len(s):
            return False
        for i in range(len(words)):
            if not words[i] or words[i][0] != s[i]:
                return False
        return True
```",Y,
account-balance-after-rounded-purchase,Account Balance After Rounded Purchase,"```python
class Solution:
    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:
        roundedAmount = (purchaseAmount + 5) // 10 * 10
        return 100 - roundedAmount
```",Y,
count-pairs-whose-sum-is-less-than-target,Count Pairs Whose Sum is Less than Target,"```python
from typing import List

class Solution:
    def countPairs(self, nums: List[int], target: int) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] + nums[j] < target:
                    count += 1
        return count
```",Y,
max-pair-sum-in-an-array,Max Pair Sum in an Array,"```python
from typing import List

class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_digits = {}
        
        for num in nums:
            max_d = max(str(num))
            max_d = int(max_d)
            if max_d not in max_digits:
                max_digits[max_d] = []
            max_digits[max_d].append(num)
        
        max_sum = -1
        for key in max_digits:
            numbers = max_digits[key]
            if len(numbers) >= 2:
                numbers.sort(reverse=True)
                current_sum = numbers[0] + numbers[1]
                if current_sum > max_sum:
                    max_sum = current_sum
        
        return max_sum
```",Y,
check-if-array-is-good,Check if Array is Good,"```python
from typing import List

class Solution:
    def isGood(self, nums: List[int]) -> bool:
        if not nums:
            return False
        max_num = max(nums)
        expected_length = max_num + 1
        if len(nums) != expected_length:
            return False
        count = {}
        for num in nums:
            count[num] = count.get(num, 0) + 1
        for i in range(1, max_num):
            if count.get(i, 0) != 1:
                return False
        if count.get(max_num, 0) != 2:
            return False
        return True
```",Y,
faulty-keyboard,Faulty Keyboard,"```python
class Solution:
    def finalString(self, s: str) -> str:
        result = []
        for char in s:
            if char == 'i':
                result.reverse()
            else:
                result.append(char)
        return ''.join(result)
```",Y,
split-strings-by-separator,Split Strings by Separator,"```python
class Solution:
    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:
        result = []
        for word in words:
            parts = word.split(separator)
            for part in parts:
                if part:
                    result.append(part)
        return result
```",Y,
number-of-employees-who-met-the-target,Number of Employees Who Met the Target,"```python
class Solution:
    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:
        return sum(1 for h in hours if h >= target)
```",Y,
longest-alternating-subarray,Longest Alternating Subarray,"```python
from typing import List

class Solution:
    def alternatingSubarray(self, nums: List[int]) -> int:
        max_len = -1
        n = len(nums)
        for i in range(n - 1):
            if nums[i + 1] - nums[i] == 1:
                current_len = 2
                for j in range(i + 2, n):
                    expected_diff = 1 if (j - i) % 2 == 1 else -1
                    if nums[j] - nums[j - 1] == expected_diff:
                        current_len += 1
                    else:
                        break
                if current_len > max_len:
                    max_len = current_len
        return max_len if max_len != -1 else -1
```",Y,
longest-even-odd-subarray-with-threshold,Longest Even Odd Subarray With Threshold,"```python
from typing import List

class Solution:
    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:
        max_len = 0
        n = len(nums)
        for l in range(n):
            if nums[l] % 2 == 0 and nums[l] <= threshold:
                current_len = 1
                if current_len > max_len:
                    max_len = current_len
                for r in range(l + 1, n):
                    if nums[r] > threshold:
                        break
                    if nums[r-1] % 2 == nums[r] % 2:
                        break
                    current_len += 1
                    if current_len > max_len:
                        max_len = current_len
        return max_len
```",Y,
total-distance-traveled,Total Distance Traveled,"```python
class Solution:
    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:
        distance = 0
        while mainTank > 0:
            fuel_used = min(mainTank, 5)
            distance += fuel_used * 10
            mainTank -= fuel_used
            if fuel_used == 5 and additionalTank > 0:
                mainTank += 1
                additionalTank -= 1
        return distance
```",Y,
find-maximum-number-of-string-pairs,Find Maximum Number of String Pairs,"```python
class Solution:
    def maximumNumberOfStringPairs(self, words: List[str]) -> int:
        seen = set()
        count = 0
        for word in words:
            reversed_word = word[::-1]
            if reversed_word in seen:
                count += 1
                seen.remove(reversed_word)
            else:
                seen.add(word)
        return count
```",Y,
sum-of-squares-of-special-elements,Sum of Squares of Special Elements ,"```python
from typing import List

class Solution:
    def sumOfSquares(self, nums: List[int]) -> int:
        n = len(nums)
        total = 0
        for i in range(1, n + 1):
            if n % i == 0:
                total += nums[i - 1] ** 2
        return total
```",Y,
neither-minimum-nor-maximum,Neither Minimum nor Maximum,"```python
from typing import List

class Solution:
    def findNonMinOrMax(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return -1
        min_val = min(nums)
        max_val = max(nums)
        for num in nums:
            if num != min_val and num != max_val:
                return num
        return -1
```",Y,
number-of-beautiful-pairs,Number of Beautiful Pairs,"```python
import math
from typing import List

class Solution:
    def countBeautifulPairs(self, nums: List[int]) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            first_digit = int(str(nums[i])[0])
            for j in range(i + 1, n):
                last_digit = nums[j] % 10
                if math.gcd(first_digit, last_digit) == 1:
                    count += 1
        return count
```",Y,
minimize-string-length,Minimize String Length,"```python
class Solution:
    def minimizedStringLength(self, s: str) -> int:
        return len(set(s))
```",Y,
check-if-the-number-is-fascinating,Check if The Number is Fascinating,"```python
class Solution:
    def isFascinating(self, n: int) -> bool:
        concatenated = str(n) + str(2 * n) + str(3 * n)
        if '0' in concatenated:
            return False
        if len(concatenated) != 9:
            return False
        digits = set(concatenated)
        return len(digits) == 9 and all(str(i) in digits for i in range(1, 10))
```",Y,
remove-trailing-zeros-from-a-string,Remove Trailing Zeros From a String,"```python
class Solution:
    def removeTrailingZeros(self, num: str) -> str:
        return num.rstrip('0') or num
```",Y,
lexicographically-smallest-palindrome,Lexicographically Smallest Palindrome,"```python
class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        s = list(s)
        left, right = 0, len(s) - 1
        while left < right:
            if s[left] != s[right]:
                if s[left] < s[right]:
                    s[right] = s[left]
                else:
                    s[left] = s[right]
            left += 1
            right -= 1
        return ''.join(s)
```",Y,
find-the-maximum-achievable-number,Find the Maximum Achievable Number,"```python
class Solution:
    def theMaximumAchievableX(self, num: int, t: int) -> int:
        return num + 2 * t
```",Y,
minimum-string-length-after-removing-substrings,Minimum String Length After Removing Substrings,"```python
class Solution:
    def minLength(self, s: str) -> int:
        stack = []
        for char in s:
            if stack:
                last = stack[-1]
                if (last == 'A' and char == 'B') or (last == 'C' and char == 'D'):
                    stack.pop()
                    continue
            stack.append(char)
        return len(stack)
```",Y,
find-the-losers-of-the-circular-game,Find the Losers of the Circular Game,"```python
class Solution:
    def circularGameLosers(self, n: int, k: int) -> List[int]:
        received = set()
        current = 1
        step = 1
        while current not in received:
            received.add(current)
            current = (current + step * k - 1) % n + 1
            step += 1
        
        losers = []
        for i in range(1, n + 1):
            if i not in received:
                losers.append(i)
        return losers
```",Y,
semi-ordered-permutation,Semi-Ordered Permutation,"```python
from typing import List

class Solution:
    def semiOrderedPermutation(self, nums: List[int]) -> int:
        n = len(nums)
        pos1 = nums.index(1)
        posn = nums.index(n)
        if pos1 < posn:
            return pos1 + (n - 1 - posn)
        else:
            return pos1 + (n - 1 - posn) - 1
```",Y,
find-the-distinct-difference-array,Find the Distinct Difference Array,"```python
class Solution:
    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        prefix = [0] * n
        suffix = [0] * n
        
        seen = set()
        for i in range(n):
            seen.add(nums[i])
            prefix[i] = len(seen)
        
        seen = set()
        for i in range(n-1, -1, -1):
            suffix[i] = len(seen)
            seen.add(nums[i])
        
        diff = []
        for i in range(n):
            diff.append(prefix[i] - suffix[i])
        
        return diff
```",Y,
maximum-sum-with-exactly-k-elements,Maximum Sum With Exactly K Elements ,"```python
from typing import List

class Solution:
    def maximizeSum(self, nums: List[int], k: int) -> int:
        max_num = max(nums)
        return k * max_num + k * (k - 1) // 2
```",Y,
buy-two-chocolates,Buy Two Chocolates,"```python
class Solution:
    def buyChoco(self, prices: List[int], money: int) -> int:
        prices.sort()
        min_sum = prices[0] + prices[1]
        if min_sum <= money:
            return money - min_sum
        else:
            return money
```",Y,
sum-multiples,Sum Multiples,"```python
class Solution:
    def sumOfMultiples(self, n: int) -> int:
        total = 0
        for num in range(1, n + 1):
            if num % 3 == 0 or num % 5 == 0 or num % 7 == 0:
                total += num
        return total
```",Y,
calculate-delayed-arrival-time,Calculate Delayed Arrival Time,"```python
class Solution:
    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:
        return (arrivalTime + delayedTime) % 24
```",Y,
row-with-maximum-ones,Row With Maximum Ones,"```python
from typing import List

class Solution:
    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:
        max_row = 0
        max_count = 0
        for i, row in enumerate(mat):
            current_count = sum(row)
            if current_count > max_count:
                max_count = current_count
                max_row = i
        return [max_row, max_count]
```",Y,
number-of-senior-citizens,Number of Senior Citizens,"```python
class Solution:
    def countSeniors(self, details: List[str]) -> int:
        count = 0
        for detail in details:
            age = int(detail[11:13])
            if age > 60:
                count += 1
        return count
```",Y,
find-the-longest-balanced-substring-of-a-binary-string,Find the Longest Balanced Substring of a Binary String,"```python
class Solution:
    def findTheLongestBalancedSubstring(self, s: str) -> int:
        max_len = 0
        n = len(s)
        for i in range(n):
            zeros = 0
            ones = 0
            for j in range(i, n):
                if s[j] == '0':
                    if ones == 0:
                        zeros += 1
                    else:
                        break
                else:
                    ones += 1
                    if zeros == ones:
                        max_len = max(max_len, 2 * ones)
        return max_len
```",Y,
prime-in-diagonal,Prime In Diagonal,"```python
import math
from typing import List

class Solution:
    def diagonalPrime(self, nums: List[List[int]]) -> int:
        def is_prime(n):
            if n <= 1:
                return False
            if n == 2:
                return True
            if n % 2 == 0:
                return False
            sqrt_n = math.isqrt(n) + 1
            for i in range(3, sqrt_n, 2):
                if n % i == 0:
                    return False
            return True
        
        max_prime = 0
        n = len(nums)
        for i in range(n):
            val1 = nums[i][i]
            val2 = nums[i][n - i - 1]
            if val1 > max_prime and is_prime(val1):
                max_prime = val1
            if val2 > max_prime and is_prime(val2):
                max_prime = val2
        return max_prime
```",Y,
k-items-with-the-maximum-sum,K Items With the Maximum Sum,"```python
class Solution:
    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:
        if k <= numOnes:
            return k
        elif k <= numOnes + numZeros:
            return numOnes
        else:
            return numOnes - (k - numOnes - numZeros)
```",Y,
left-and-right-sum-differences,Left and Right Sum Differences,"```python
from typing import List

class Solution:
    def leftRightDifference(self, nums: List[int]) -> List[int]:
        n = len(nums)
        left_sum = [0] * n
        right_sum = [0] * n
        
        for i in range(1, n):
            left_sum[i] = left_sum[i-1] + nums[i-1]
        
        for i in range(n-2, -1, -1):
            right_sum[i] = right_sum[i+1] + nums[i+1]
        
        answer = [abs(left_sum[i] - right_sum[i]) for i in range(n)]
        return answer
```",Y,
merge-two-2d-arrays-by-summing-values,Merge Two 2D Arrays by Summing Values,"```python
from typing import List

class Solution:
    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
        merged = {}
        for id, val in nums1:
            merged[id] = merged.get(id, 0) + val
        for id, val in nums2:
            merged[id] = merged.get(id, 0) + val
        return sorted(merged.items())
```",Y,
maximum-difference-by-remapping-a-digit,Maximum Difference by Remapping a Digit,"```python
class Solution:
    def minMaxDifference(self, num: int) -> int:
        s = str(num)
        max_val = -1
        min_val = float('inf')
        
        for d in set(s):
            max_candidate = int(s.replace(d, '9'))
            if max_candidate > max_val:
                max_val = max_candidate
            min_candidate = int(s.replace(d, '0'))
            if min_candidate < min_val:
                min_val = min_candidate
        
        return max_val - min_val
```",Y,
find-the-array-concatenation-value,Find the Array Concatenation Value,"```python
from typing import List

class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        concat_value = 0
        left, right = 0, len(nums) - 1
        
        while left <= right:
            if left == right:
                concat_value += nums[left]
            else:
                first = nums[left]
                last = nums[right]
                concat_num = int(str(first) + str(last))
                concat_value += concat_num
            left += 1
            right -= 1
        
        return concat_value
```",Y,
find-the-maximum-divisibility-score,Find the Maximum Divisibility Score,"```python
from typing import List

class Solution:
    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:
        max_score = -1
        result = None
        for d in sorted(divisors):
            score = 0
            for num in nums:
                if num % d == 0:
                    score += 1
            if score > max_score or (score == max_score and d < result):
                max_score = score
                result = d
        return result
```",Y,
take-gifts-from-the-richest-pile,Take Gifts From the Richest Pile,"```python
import heapq
from math import isqrt
from typing import List

class Solution:
    def pickGifts(self, gifts: List[int], k: int) -> int:
        max_heap = []
        for num in gifts:
            heapq.heappush(max_heap, -num)
        
        for _ in range(k):
            if not max_heap:
                break
            current = -heapq.heappop(max_heap)
            new_val = isqrt(current)
            heapq.heappush(max_heap, -new_val)
        
        return sum(-num for num in max_heap)
```",Y,
determine-the-winner-of-a-bowling-game,Determine the Winner of a Bowling Game,"```python
from typing import List

class Solution:
    def isWinner(self, player1: List[int], player2: List[int]) -> int:
        def calculate_score(player):
            score = 0
            for i in range(len(player)):
                multiplier = 1
                if (i >= 1 and player[i-1] == 10) or (i >= 2 and player[i-2] == 10):
                    multiplier = 2
                score += player[i] * multiplier
            return score
        
        score1 = calculate_score(player1)
        score2 = calculate_score(player2)
        
        if score1 > score2:
            return 1
        elif score2 > score1:
            return 2
        else:
            return 0
```",Y,
count-distinct-numbers-on-board,Count Distinct Numbers on Board,"```python
class Solution:
    def distinctIntegers(self, n: int) -> int:
        if n == 1:
            return 1
        return n - 1
```",Y,
find-the-width-of-columns-of-a-grid,Find the Width of Columns of a Grid,"```python
from typing import List

class Solution:
    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:
        if not grid:
            return []
        n = len(grid[0])
        ans = [0] * n
        for row in grid:
            for i in range(n):
                num = row[i]
                if num < 0:
                    length = len(str(abs(num))) + 1
                else:
                    length = len(str(num))
                if length > ans[i]:
                    ans[i] = length
        return ans
```",Y,
form-smallest-number-from-two-digit-arrays,Form Smallest Number From Two Digit Arrays,"```python
class Solution:
    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:
        common_digits = set(nums1) & set(nums2)
        if common_digits:
            return min(common_digits)
        
        min1 = min(nums1)
        min2 = min(nums2)
        
        return min(min1 * 10 + min2, min2 * 10 + min1)
```",Y,
distribute-money-to-maximum-children,Distribute Money to Maximum Children,"```python
class Solution:
    def distMoney(self, money: int, children: int) -> int:
        if money < children:
            return -1
        
        money -= children  # Each child gets at least 1 dollar
        max_eight = min(money // 7, children)
        remaining_money = money - max_eight * 7
        remaining_children = children - max_eight
        
        if remaining_children == 0 and remaining_money > 0:
            return max_eight - 1
        if remaining_children == 1 and remaining_money == 3:
            return max_eight - 1
        
        return max_eight
```",Y,
number-of-even-and-odd-bits,Number of Even and Odd Bits,"```python
class Solution:
    def evenOddBit(self, n: int) -> List[int]:
        even = 0
        odd = 0
        index = 0
        while n > 0:
            if n & 1:
                if index % 2 == 0:
                    even += 1
                else:
                    odd += 1
            n >>= 1
            index += 1
        return [even, odd]
```",Y,
count-the-number-of-vowel-strings-in-range,Count the Number of Vowel Strings in Range,"```python
class Solution:
    def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        count = 0
        for i in range(left, right + 1):
            word = words[i]
            if word and word[0] in vowels and word[-1] in vowels:
                count += 1
        return count
```",Y,
split-with-minimum-sum,Split With Minimum Sum,"```python
class Solution:
    def splitNum(self, num: int) -> int:
        digits = sorted(list(str(num)))
        num1 = []
        num2 = []
        for i, digit in enumerate(digits):
            if i % 2 == 0:
                num1.append(digit)
            else:
                num2.append(digit)
        return int(''.join(num1)) + int(''.join(num2))
```",Y,
pass-the-pillow,Pass the Pillow,"```python
class Solution:
    def passThePillow(self, n: int, time: int) -> int:
        cycle = (n - 1) * 2
        time %= cycle
        if time < n:
            return time + 1
        else:
            return 2 * n - time - 1
```",Y,
separate-the-digits-in-an-array,Separate the Digits in an Array,"```python
class Solution:
    def separateDigits(self, nums: List[int]) -> List[int]:
        answer = []
        for num in nums:
            digits = []
            while num > 0:
                digits.append(num % 10)
                num = num // 10
            answer.extend(reversed(digits)) if digits else answer.append(0)
        return answer
```",Y,
minimum-common-value,Minimum Common Value,"```python
class Solution:
    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:
        i = j = 0
        len1, len2 = len(nums1), len(nums2)
        
        while i < len1 and j < len2:
            if nums1[i] == nums2[j]:
                return nums1[i]
            elif nums1[i] < nums2[j]:
                i += 1
            else:
                j += 1
        return -1
```",Y,
alternating-digit-sum,Alternating Digit Sum,"```python
class Solution:
    def alternateDigitSum(self, n: int) -> int:
        digits = list(map(int, str(n)))
        total = 0
        sign = 1
        for digit in digits:
            total += sign * digit
            sign *= -1
        return total
```",Y,
difference-between-element-sum-and-digit-sum-of-an-array,Difference Between Element Sum and Digit Sum of an Array,"```python
from typing import List

class Solution:
    def differenceOfSum(self, nums: List[int]) -> int:
        element_sum = sum(nums)
        digit_sum = 0
        for num in nums:
            for digit in str(num):
                digit_sum += int(digit)
        return abs(element_sum - digit_sum)
```",Y,
categorize-box-according-to-criteria,Categorize Box According to Criteria,"```python
class Solution:
    def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:
        bulky = False
        heavy = mass >= 100
        
        if (length >= 10**4 or width >= 10**4 or height >= 10**4) or (length * width * height >= 10**9):
            bulky = True
        
        if bulky and heavy:
            return ""Both""
        elif bulky:
            return ""Bulky""
        elif heavy:
            return ""Heavy""
        else:
            return ""Neither""
```",Y,
maximum-count-of-positive-integer-and-negative-integer,Maximum Count of Positive Integer and Negative Integer,"```python
from typing import List

class Solution:
    def maximumCount(self, nums: List[int]) -> int:
        neg = bisect.bisect_left(nums, 0)
        pos = len(nums) - bisect.bisect_right(nums, 0)
        return max(neg, pos)
```",Y,
count-the-digits-that-divide-a-number,Count the Digits That Divide a Number,"```python
class Solution:
    def countDigits(self, num: int) -> int:
        count = 0
        original_num = num
        while num > 0:
            digit = num % 10
            if original_num % digit == 0:
                count += 1
            num = num // 10
        return count
```",Y,
maximum-enemy-forts-that-can-be-captured,Maximum Enemy Forts That Can Be Captured,"```python
from typing import List

class Solution:
    def captureForts(self, forts: List[int]) -> int:
        max_captured = 0
        n = len(forts)
        
        for i in range(n):
            if forts[i] == 1:
                j = i + 1
                count = 0
                while j < n and forts[j] == 0:
                    count += 1
                    j += 1
                if j < n and forts[j] == -1:
                    max_captured = max(max_captured, count)
                
                j = i - 1
                count = 0
                while j >= 0 and forts[j] == 0:
                    count += 1
                    j -= 1
                if j >= 0 and forts[j] == -1:
                    max_captured = max(max_captured, count)
        
        return max_captured
```",Y,
shortest-distance-to-target-string-in-a-circular-array,Shortest Distance to Target String in a Circular Array,"```python
from typing import List

class Solution:
    def closestTarget(self, words: List[str], target: str, startIndex: int) -> int:
        n = len(words)
        min_distance = float('inf')
        found = False
        
        for i in range(n):
            if words[i] == target:
                found = True
                distance = min(abs(i - startIndex), n - abs(i - startIndex))
                if distance < min_distance:
                    min_distance = distance
        
        return min_distance if found else -1
```",Y,
count-pairs-of-similar-strings,Count Pairs Of Similar Strings,"```python
class Solution:
    def similarPairs(self, words: List[str]) -> int:
        count = 0
        n = len(words)
        for i in range(n):
            set_i = set(words[i])
            for j in range(i + 1, n):
                set_j = set(words[j])
                if set_i == set_j:
                    count += 1
        return count
```",Y,
maximum-value-of-a-string-in-an-array,Maximum Value of a String in an Array,"```python
from typing import List

class Solution:
    def maximumValue(self, strs: List[str]) -> int:
        max_val = 0
        for s in strs:
            if s.isdigit():
                current_val = int(s)
            else:
                current_val = len(s)
            if current_val > max_val:
                max_val = current_val
        return max_val
```",Y,
delete-greatest-value-in-each-row,Delete Greatest Value in Each Row,"```python
class Solution:
    def deleteGreatestValue(self, grid: List[List[int]]) -> int:
        answer = 0
        for row in grid:
            row.sort()
        for j in range(len(grid[0])):
            current_max = 0
            for i in range(len(grid)):
                if grid[i][j] > current_max:
                    current_max = grid[i][j]
            answer += current_max
        return answer
```",Y,
circular-sentence,Circular Sentence,"```python
class Solution:
    def isCircularSentence(self, sentence: str) -> bool:
        words = sentence.split()
        n = len(words)
        if n == 1:
            return words[0][-1] == words[0][0]
        for i in range(n - 1):
            if words[i][-1] != words[i + 1][0]:
                return False
        return words[-1][-1] == words[0][0]
```",Y,
minimum-cuts-to-divide-a-circle,Minimum Cuts to Divide a Circle,"```python
class Solution:
    def numberOfCuts(self, n: int) -> int:
        if n == 1:
            return 0
        return n if n % 2 else n // 2
```",Y,
find-the-pivot-integer,Find the Pivot Integer,"```python
class Solution:
    def pivotInteger(self, n: int) -> int:
        total_sum = n * (n + 1) // 2
        for x in range(1, n + 1):
            left_sum = x * (x + 1) // 2
            right_sum = total_sum - left_sum + x
            if left_sum == right_sum:
                return x
        return -1
```",Y,
number-of-unequal-triplets-in-array,Number of Unequal Triplets in Array,"```python
from typing import List

class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] != nums[j]:
                    for k in range(j + 1, n):
                        if nums[i] != nums[k] and nums[j] != nums[k]:
                            count += 1
        return count
```",Y,
number-of-distinct-averages,Number of Distinct Averages,"```python
class Solution:
    def distinctAverages(self, nums: List[int]) -> int:
        nums.sort()
        seen = set()
        left, right = 0, len(nums) - 1
        while left < right:
            avg = (nums[left] + nums[right]) / 2
            seen.add(avg)
            left += 1
            right -= 1
        return len(seen)
```",Y,
convert-the-temperature,Convert the Temperature,"```python
class Solution:
    def convertTemperature(self, celsius: float) -> List[float]:
        kelvin = celsius + 273.15
        fahrenheit = celsius * 1.80 + 32.00
        return [kelvin, fahrenheit]
```",Y,
apply-operations-to-an-array,Apply Operations to an Array,"```python
from typing import List

class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:
        n = len(nums)
        for i in range(n - 1):
            if nums[i] == nums[i + 1]:
                nums[i] *= 2
                nums[i + 1] = 0
        
        result = []
        zero_count = 0
        for num in nums:
            if num != 0:
                result.append(num)
            else:
                zero_count += 1
        result.extend([0] * zero_count)
        return result
```",Y,
odd-string-difference,Odd String Difference,"```python
class Solution:
    def oddString(self, words: List[str]) -> str:
        diff_dict = {}
        for word in words:
            diff = []
            for i in range(len(word) - 1):
                diff.append(ord(word[i+1]) - ord(word[i]))
            diff_tuple = tuple(diff)
            if diff_tuple in diff_dict:
                diff_dict[diff_tuple].append(word)
            else:
                diff_dict[diff_tuple] = [word]
        for key in diff_dict:
            if len(diff_dict[key]) == 1:
                return diff_dict[key][0]
        return """"
```",Y,
average-value-of-even-numbers-that-are-divisible-by-three,Average Value of Even Numbers That Are Divisible by Three,"```python
from typing import List

class Solution:
    def averageValue(self, nums: List[int]) -> int:
        total = 0
        count = 0
        for num in nums:
            if num % 2 == 0 and num % 3 == 0:
                total += num
                count += 1
        return total // count if count > 0 else 0
```",Y,
determine-if-two-events-have-conflict,Determine if Two Events Have Conflict,"```python
class Solution:
    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:
        def to_minutes(time_str):
            hh, mm = map(int, time_str.split(':'))
            return hh * 60 + mm
        
        start1, end1 = map(to_minutes, event1)
        start2, end2 = map(to_minutes, event2)
        
        return not (end1 < start2 or end2 < start1)
```",Y,
remove-letter-to-equalize-frequency,Remove Letter To Equalize Frequency,"```python
class Solution:
    def equalFrequency(self, word: str) -> bool:
        from collections import defaultdict
        
        for i in range(len(word)):
            temp_word = word[:i] + word[i+1:]
            freq = defaultdict(int)
            for c in temp_word:
                freq[c] += 1
            frequencies = list(freq.values())
            if all(f == frequencies[0] for f in frequencies):
                return True
        return False
```",Y,
number-of-valid-clock-times,Number of Valid Clock Times,"```python
class Solution:
    def countTime(self, time: str) -> int:
        h1, h2, _, m1, m2 = time
        count_h = 1
        if h1 == '?' and h2 == '?':
            count_h = 24
        elif h1 == '?':
            if int(h2) < 4:
                count_h = 3  # 0,1,2
            else:
                count_h = 2  # 0,1
        elif h2 == '?':
            if int(h1) == 2:
                count_h = 4  # 0,1,2,3
            else:
                count_h = 10  # 0-9
        
        count_m = 1
        if m1 == '?' and m2 == '?':
            count_m = 60
        elif m1 == '?':
            count_m = 6  # 0-5
        elif m2 == '?':
            count_m = 10  # 0-9
        
        return count_h * count_m
```",Y,
largest-positive-integer-that-exists-with-its-negative,Largest Positive Integer That Exists With Its Negative,"```python
class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        num_set = set(nums)
        max_k = -1
        for num in nums:
            if num > 0 and -num in num_set:
                if num > max_k:
                    max_k = num
        return max_k
```",Y,
the-employee-that-worked-on-the-longest-task,The Employee That Worked on the Longest Task,"```python
from typing import List

class Solution:
    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:
        max_duration = -1
        result = -1
        prev_time = 0
        
        for log in logs:
            employee_id, leave_time = log
            duration = leave_time - prev_time
            if duration > max_duration:
                max_duration = duration
                result = employee_id
            elif duration == max_duration and employee_id < result:
                result = employee_id
            prev_time = leave_time
        
        return result
```",Y,
number-of-common-factors,Number of Common Factors,"```python
class Solution:
    def commonFactors(self, a: int, b: int) -> int:
        def gcd(x, y):
            while y:
                x, y = y, x % y
            return x
        
        g = gcd(a, b)
        count = 0
        for i in range(1, int(g ** 0.5) + 1):
            if g % i == 0:
                if i * i == g:
                    count += 1
                else:
                    count += 2
        return count
```",Y,
sort-the-people,Sort the People,"```python
class Solution:
    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:
        people = list(zip(names, heights))
        people.sort(key=lambda x: -x[1])
        return [name for name, height in people]
```",Y,
count-days-spent-together,Count Days Spent Together,"```python
class Solution:
    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:
        days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        
        def date_to_day(date):
            month, day = map(int, date.split('-'))
            return sum(days_in_month[:month-1]) + day
        
        alice_start = date_to_day(arriveAlice)
        alice_end = date_to_day(leaveAlice)
        bob_start = date_to_day(arriveBob)
        bob_end = date_to_day(leaveBob)
        
        overlap_start = max(alice_start, bob_start)
        overlap_end = min(alice_end, bob_end)
        
        return max(0, overlap_end - overlap_start + 1) if overlap_start <= overlap_end else 0
```",Y,
smallest-even-multiple,Smallest Even Multiple,"```python
class Solution:
    def smallestEvenMultiple(self, n: int) -> int:
        return n if n % 2 == 0 else n * 2
```",Y,
most-frequent-even-element,Most Frequent Even Element,"```python
from typing import List
from collections import defaultdict

class Solution:
    def mostFrequentEven(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for num in nums:
            if num % 2 == 0:
                freq[num] += 1
        if not freq:
            return -1
        max_freq = max(freq.values())
        candidates = [num for num, count in freq.items() if count == max_freq]
        return min(candidates)
```",Y,
find-subarrays-with-equal-sum,Find Subarrays With Equal Sum,"```python
from typing import List

class Solution:
    def findSubarrays(self, nums: List[int]) -> bool:
        seen = set()
        for i in range(len(nums) - 1):
            current_sum = nums[i] + nums[i + 1]
            if current_sum in seen:
                return True
            seen.add(current_sum)
        return False
```",Y,
check-distances-between-same-letters,Check Distances Between Same Letters,"```python
from typing import List

class Solution:
    def checkDistances(self, s: str, distance: List[int]) -> bool:
        first_occurrence = {}
        for idx, char in enumerate(s):
            if char in first_occurrence:
                expected_distance = distance[ord(char) - ord('a')]
                actual_distance = idx - first_occurrence[char] - 1
                if actual_distance != expected_distance:
                    return False
            else:
                first_occurrence[char] = idx
        return True
```",Y,
longest-subsequence-with-limited-sum,Longest Subsequence With Limited Sum,"```python
class Solution:
    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:
        nums.sort()
        prefix = [0]
        for num in nums:
            prefix.append(prefix[-1] + num)
        
        answer = []
        for query in queries:
            left, right = 0, len(prefix) - 1
            best = 0
            while left <= right:
                mid = (left + right) // 2
                if prefix[mid] <= query:
                    best = mid
                    left = mid + 1
                else:
                    right = mid - 1
            answer.append(best)
        return answer
```",Y,
minimum-recolors-to-get-k-consecutive-black-blocks,Minimum Recolors to Get K Consecutive Black Blocks,"```python
class Solution:
    def minimumRecolors(self, blocks: str, k: int) -> int:
        min_operations = float('inf')
        n = len(blocks)
        for i in range(n - k + 1):
            window = blocks[i:i+k]
            operations = window.count('W')
            if operations < min_operations:
                min_operations = operations
        return min_operations
```",Y,
minimum-hours-of-training-to-win-a-competition,Minimum Hours of Training to Win a Competition,"```python
from typing import List

class Solution:
    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:
        total_energy = sum(energy)
        required_energy = max(0, total_energy - initialEnergy + 1)
        
        current_exp = initialExperience
        required_exp = 0
        
        for exp in experience:
            if current_exp <= exp:
                needed = exp - current_exp + 1
                required_exp += needed
                current_exp += needed
            current_exp += exp
        
        return required_energy + required_exp
```",Y,
largest-local-values-in-a-matrix,Largest Local Values in a Matrix,"```python
from typing import List

class Solution:
    def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:
        n = len(grid)
        max_local = []
        for i in range(n - 2):
            row = []
            for j in range(n - 2):
                max_val = max(
                    grid[i][j], grid[i][j+1], grid[i][j+2],
                    grid[i+1][j], grid[i+1][j+1], grid[i+1][j+2],
                    grid[i+2][j], grid[i+2][j+1], grid[i+2][j+2]
                )
                row.append(max_val)
            max_local.append(row)
        return max_local
```",Y,
merge-similar-items,Merge Similar Items,"```python
from typing import List

class Solution:
    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:
        weight_map = {}
        
        for value, weight in items1:
            weight_map[value] = weight_map.get(value, 0) + weight
        
        for value, weight in items2:
            weight_map[value] = weight_map.get(value, 0) + weight
        
        return sorted(weight_map.items())
```",Y,
number-of-arithmetic-triplets,Number of Arithmetic Triplets,"```python
class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        num_set = set(nums)
        count = 0
        for num in nums:
            if num + diff in num_set and num + 2 * diff in num_set:
                count += 1
        return count
```",Y,
make-array-zero-by-subtracting-equal-amounts,Make Array Zero by Subtracting Equal Amounts,"```python
from typing import List

class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        unique_nonzero = set()
        for num in nums:
            if num != 0:
                unique_nonzero.add(num)
        return len(unique_nonzero)
```",Y,
best-poker-hand,Best Poker Hand,"```python
from typing import List
from collections import defaultdict

class Solution:
    def bestHand(self, ranks: List[int], suits: List[str]) -> str:
        suit_counts = defaultdict(int)
        rank_counts = defaultdict(int)
        
        for suit in suits:
            suit_counts[suit] += 1
        
        for rank in ranks:
            rank_counts[rank] += 1
        
        if any(count >= 5 for count in suit_counts.values()):
            return ""Flush""
        
        max_rank_count = max(rank_counts.values())
        if max_rank_count >= 3:
            return ""Three of a Kind""
        elif max_rank_count >= 2:
            return ""Pair""
        else:
            return ""High Card""
```",Y,
first-letter-to-appear-twice,First Letter to Appear Twice,"```python
class Solution:
    def repeatedCharacter(self, s: str) -> str:
        seen = set()
        for char in s:
            if char in seen:
                return char
            seen.add(char)
        return """"
```",Y,
maximum-number-of-pairs-in-array,Maximum Number of Pairs in Array,"```python
from typing import List

class Solution:
    def numberOfPairs(self, nums: List[int]) -> List[int]:
        freq = {}
        for num in nums:
            freq[num] = freq.get(num, 0) + 1
        pairs = 0
        leftovers = 0
        for count in freq.values():
            pairs += count // 2
            leftovers += count % 2
        return [pairs, leftovers]
```",Y,
evaluate-boolean-binary-tree,Evaluate Boolean Binary Tree,"```python
class Solution:
    def evaluateTree(self, root: Optional[TreeNode]) -> bool:
        if not root.left and not root.right:
            return root.val == 1
        left_val = self.evaluateTree(root.left)
        right_val = self.evaluateTree(root.right)
        if root.val == 2:
            return left_val or right_val
        else:
            return left_val and right_val
```",Y,
minimum-amount-of-time-to-fill-cups,Minimum Amount of Time to Fill Cups,"```python
from typing import List

class Solution:
    def fillCups(self, amount: List[int]) -> int:
        amount.sort()
        if amount[2] >= amount[0] + amount[1]:
            return amount[2]
        else:
            return (sum(amount) + 1) // 2
```",Y,
decode-the-message,Decode the Message,"```python
class Solution:
    def decodeMessage(self, key: str, message: str) -> str:
        substitution = {}
        alphabet = 'abcdefghijklmnopqrstuvwxyz'
        index = 0
        
        for char in key:
            if char == ' ':
                continue
            if char not in substitution:
                substitution[char] = alphabet[index]
                index += 1
                if index == 26:
                    break
        
        decoded = []
        for char in message:
            if char == ' ':
                decoded.append(' ')
            else:
                decoded.append(substitution[char])
        
        return ''.join(decoded)
```",Y,
count-asterisks,Count Asterisks,"```python
class Solution:
    def countAsterisks(self, s: str) -> int:
        count = 0
        in_pair = False
        for char in s:
            if char == '|':
                in_pair = not in_pair
            elif char == '*' and not in_pair:
                count += 1
        return count
```",Y,
check-if-matrix-is-x-matrix,Check if Matrix Is X-Matrix,"```python
from typing import List

class Solution:
    def checkXMatrix(self, grid: List[List[int]]) -> bool:
        n = len(grid)
        for i in range(n):
            for j in range(n):
                if i == j or i + j == n - 1:
                    if grid[i][j] == 0:
                        return False
                else:
                    if grid[i][j] != 0:
                        return False
        return True
```",Y,
strong-password-checker-ii,Strong Password Checker II,"```python
class Solution:
    def strongPasswordCheckerII(self, password: str) -> bool:
        if len(password) < 8:
            return False
        
        has_lower = False
        has_upper = False
        has_digit = False
        has_special = False
        special_chars = ""!@#$%^&*()-+""
        
        for i in range(len(password)):
            if i > 0 and password[i] == password[i-1]:
                return False
            if password[i].islower():
                has_lower = True
            elif password[i].isupper():
                has_upper = True
            elif password[i].isdigit():
                has_digit = True
            elif password[i] in special_chars:
                has_special = True
        
        return has_lower and has_upper and has_digit and has_special
```",Y,
min-max-game,Min Max Game,"```python
from typing import List

class Solution:
    def minMaxGame(self, nums: List[int]) -> int:
        while len(nums) > 1:
            new_nums = []
            for i in range(len(nums) // 2):
                if i % 2 == 0:
                    new_nums.append(min(nums[2*i], nums[2*i+1]))
                else:
                    new_nums.append(max(nums[2*i], nums[2*i+1]))
            nums = new_nums
        return nums[0]
```",Y,
root-equals-sum-of-children,Root Equals Sum of Children,"```python
class Solution:
    def checkTree(self, root: Optional[TreeNode]) -> bool:
        return root.val == root.left.val + root.right.val
```",Y,
add-two-integers,Add Two Integers,"```python
class Solution:
    def sum(self, num1: int, num2: int) -> int:
        return num1 + num2
```",Y,
check-if-number-has-equal-digit-count-and-digit-value,Check if Number Has Equal Digit Count and Digit Value,"```python
class Solution:
    def digitCount(self, num: str) -> bool:
        for i in range(len(num)):
            expected = int(num[i])
            actual = num.count(str(i))
            if expected != actual:
                return False
        return True
```",Y,
rearrange-characters-to-make-target-string,Rearrange Characters to Make Target String,"```python
class Solution:
    def rearrangeCharacters(self, s: str, target: str) -> int:
        from collections import defaultdict
        
        s_counts = defaultdict(int)
        target_counts = defaultdict(int)
        
        for char in s:
            s_counts[char] += 1
        
        for char in target:
            target_counts[char] += 1
        
        max_copies = float('inf')
        
        for char in target_counts:
            if char not in s_counts:
                return 0
            max_copies = min(max_copies, s_counts[char] // target_counts[char])
        
        return max_copies
```",Y,
percentage-of-letter-in-string,Percentage of Letter in String,"```python
class Solution:
    def percentageLetter(self, s: str, letter: str) -> int:
        count = s.count(letter)
        total = len(s)
        return (count * 100) // total
```",Y,
calculate-digit-sum-of-a-string,Calculate Digit Sum of a String,"```python
class Solution:
    def digitSum(self, s: str, k: int) -> str:
        while len(s) > k:
            groups = []
            for i in range(0, len(s), k):
                group = s[i:i+k]
                total = sum(int(c) for c in group)
                groups.append(str(total))
            s = ''.join(groups)
        return s
```",Y,
find-closest-number-to-zero,Find Closest Number to Zero,"```python
from typing import List

class Solution:
    def findClosestNumber(self, nums: List[int]) -> int:
        closest = nums[0]
        for num in nums[1:]:
            if abs(num) < abs(closest):
                closest = num
            elif abs(num) == abs(closest):
                if num > closest:
                    closest = num
        return closest
```",Y,
largest-3-same-digit-number-in-string,Largest 3-Same-Digit Number in String,"```python
class Solution:
    def largestGoodInteger(self, num: str) -> str:
        max_good = """"
        for i in range(len(num) - 2):
            substring = num[i:i+3]
            if len(set(substring)) == 1:
                if substring > max_good:
                    max_good = substring
        return max_good
```",Y,
minimum-number-of-operations-to-convert-time,Minimum Number of Operations to Convert Time,"```python
class Solution:
    def convertTime(self, current: str, correct: str) -> int:
        current_h, current_m = map(int, current.split(':'))
        correct_h, correct_m = map(int, correct.split(':'))
        
        total_current = current_h * 60 + current_m
        total_correct = correct_h * 60 + correct_m
        diff = total_correct - total_current
        
        operations = 0
        for increment in [60, 15, 5, 1]:
            operations += diff // increment
            diff %= increment
        
        return operations
```",Y,
count-prefixes-of-a-given-string,Count Prefixes of a Given String,"```python
from typing import List

class Solution:
    def countPrefixes(self, words: List[str], s: str) -> int:
        count = 0
        for word in words:
            if s.startswith(word):
                count += 1
        return count
```",Y,
remove-digit-from-number-to-maximize-result,Remove Digit From Number to Maximize Result,"```python
class Solution:
    def removeDigit(self, number: str, digit: str) -> str:
        max_num = """"
        for i in range(len(number)):
            if number[i] == digit:
                current = number[:i] + number[i+1:]
                if current > max_num:
                    max_num = current
        return max_num
```",Y,
intersection-of-multiple-arrays,Intersection of Multiple Arrays,"```python
from typing import List

class Solution:
    def intersection(self, nums: List[List[int]]) -> List[int]:
        if not nums:
            return []
        common = set(nums[0])
        for arr in nums[1:]:
            common.intersection_update(arr)
        return sorted(common)
```",Y,
largest-number-after-digit-swaps-by-parity,Largest Number After Digit Swaps by Parity,"```python
class Solution:
    def largestInteger(self, num: int) -> int:
        digits = list(str(num))
        n = len(digits)
        for i in range(n):
            for j in range(i + 1, n):
                if int(digits[i]) % 2 == int(digits[j]) % 2 and int(digits[i]) < int(digits[j]):
                    digits[i], digits[j] = digits[j], digits[i]
        return int(''.join(digits))
```",Y,
minimum-bit-flips-to-convert-number,Minimum Bit Flips to Convert Number,"```python
class Solution:
    def minBitFlips(self, start: int, goal: int) -> int:
        xor = start ^ goal
        count = 0
        while xor:
            count += xor & 1
            xor >>= 1
        return count
```",Y,
find-all-k-distant-indices-in-an-array,Find All K-Distant Indices in an Array,"```python
from typing import List

class Solution:
    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        key_indices = [i for i, num in enumerate(nums) if num == key]
        result = set()
        n = len(nums)
        for j in key_indices:
            start = max(0, j - k)
            end = min(n - 1, j + k)
            for i in range(start, end + 1):
                result.add(i)
        return sorted(result)
```",Y,
count-hills-and-valleys-in-an-array,Count Hills and Valleys in an Array,"```python
from typing import List

class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        filtered_nums = []
        for num in nums:
            if not filtered_nums or num != filtered_nums[-1]:
                filtered_nums.append(num)
        
        count = 0
        for i in range(1, len(filtered_nums) - 1):
            left = filtered_nums[i-1]
            mid = filtered_nums[i]
            right = filtered_nums[i+1]
            if (left < mid and right < mid) or (left > mid and right > mid):
                count += 1
        return count
```",Y,
most-frequent-number-following-key-in-an-array,Most Frequent Number Following Key In an Array,"```python
from typing import List

class Solution:
    def mostFrequent(self, nums: List[int], key: int) -> int:
        freq = {}
        max_count = 0
        result = -1
        
        for i in range(len(nums) - 1):
            if nums[i] == key:
                target = nums[i + 1]
                freq[target] = freq.get(target, 0) + 1
                if freq[target] > max_count:
                    max_count = freq[target]
                    result = target
        
        return result
```",Y,
divide-array-into-equal-pairs,Divide Array Into Equal Pairs,"```python
from collections import defaultdict
from typing import List

class Solution:
    def divideArray(self, nums: List[int]) -> bool:
        freq = defaultdict(int)
        for num in nums:
            freq[num] += 1
        for count in freq.values():
            if count % 2 != 0:
                return False
        return True
```",Y,
cells-in-a-range-on-an-excel-sheet,Cells in a Range on an Excel Sheet,"```python
class Solution:
    def cellsInRange(self, s: str) -> List[str]:
        col1, row1, col2, row2 = s[0], s[1], s[3], s[4]
        result = []
        for col in range(ord(col1), ord(col2) + 1):
            for row in range(int(row1), int(row2) + 1):
                result.append(f""{chr(col)}{row}"")
        return result
```",Y,
count-integers-with-even-digit-sum,Count Integers With Even Digit Sum,"```python
class Solution:
    def countEven(self, num: int) -> int:
        count = 0
        for i in range(1, num + 1):
            digit_sum = sum(int(d) for d in str(i))
            if digit_sum % 2 == 0:
                count += 1
        return count
```",Y,
counting-words-with-a-given-prefix,Counting Words With a Given Prefix,"```python
from typing import List

class Solution:
    def prefixCount(self, words: List[str], pref: str) -> int:
        count = 0
        pref_len = len(pref)
        for word in words:
            if len(word) >= pref_len and word[:pref_len] == pref:
                count += 1
        return count
```",Y,
count-operations-to-obtain-zero,Count Operations to Obtain Zero,"```python
class Solution:
    def countOperations(self, num1: int, num2: int) -> int:
        count = 0
        while num1 != 0 and num2 != 0:
            if num1 >= num2:
                num1 -= num2
            else:
                num2 -= num1
            count += 1
        return count
```",Y,
sort-even-and-odd-indices-independently,Sort Even and Odd Indices Independently,"```python
from typing import List

class Solution:
    def sortEvenOdd(self, nums: List[int]) -> List[int]:
        even_indices = nums[::2]
        odd_indices = nums[1::2]
        
        even_indices_sorted = sorted(even_indices)
        odd_indices_sorted = sorted(odd_indices, reverse=True)
        
        result = []
        e_ptr = o_ptr = 0
        for i in range(len(nums)):
            if i % 2 == 0:
                result.append(even_indices_sorted[e_ptr])
                e_ptr += 1
            else:
                result.append(odd_indices_sorted[o_ptr])
                o_ptr += 1
        return result
```",Y,
count-equal-and-divisible-pairs-in-an-array,Count Equal and Divisible Pairs in an Array,"```python
from typing import List

class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if nums[i] == nums[j] and (i * j) % k == 0:
                    count += 1
        return count
```",Y,
keep-multiplying-found-values-by-two,Keep Multiplying Found Values by Two,"```python
class Solution:
    def findFinalValue(self, nums: List[int], original: int) -> int:
        nums_set = set(nums)
        while original in nums_set:
            original *= 2
        return original
```",Y,
count-elements-with-strictly-smaller-and-greater-elements,Count Elements With Strictly Smaller and Greater Elements ,"```python
class Solution:
    def countElements(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return 0
        min_num = min(nums)
        max_num = max(nums)
        count = 0
        for num in nums:
            if num > min_num and num < max_num:
                count += 1
        return count
```",Y,
minimum-sum-of-four-digit-number-after-splitting-digits,Minimum Sum of Four Digit Number After Splitting Digits,"```python
class Solution:
    def minimumSum(self, num: int) -> int:
        digits = sorted(str(num))
        return int(digits[0] + digits[2]) + int(digits[1] + digits[3])
```",Y,
divide-a-string-into-groups-of-size-k,Divide a String Into Groups of Size k,"```python
from typing import List

class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        result = []
        n = len(s)
        for i in range(0, n, k):
            group = s[i:i+k]
            if len(group) < k:
                group += fill * (k - len(group))
            result.append(group)
        return result
```",Y,
check-if-every-row-and-column-contains-all-numbers,Check if Every Row and Column Contains All Numbers,"```python
from typing import List

class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        n = len(matrix)
        for i in range(n):
            row_set = set()
            col_set = set()
            for j in range(n):
                row_val = matrix[i][j]
                col_val = matrix[j][i]
                if row_val < 1 or row_val > n or col_val < 1 or col_val > n:
                    return False
                row_set.add(row_val)
                col_set.add(col_val)
            if len(row_set) != n or len(col_set) != n:
                return False
        return True
```",Y,
minimum-cost-of-buying-candies-with-discount,Minimum Cost of Buying Candies With Discount,"```python
class Solution:
    def minimumCost(self, cost: List[int]) -> int:
        cost.sort(reverse=True)
        total = 0
        for i in range(len(cost)):
            if i % 3 != 2:
                total += cost[i]
        return total
```",Y,
check-if-all-as-appears-before-all-bs,Check if All A's Appears Before All B's,"```python
class Solution:
    def checkString(self, s: str) -> bool:
        return 'ba' not in s
```",Y,
a-number-after-a-double-reversal,A Number After a Double Reversal,"```python
class Solution:
    def isSameAfterReversals(self, num: int) -> bool:
        if num == 0:
            return True
        return num % 10 != 0
```",Y,
capitalize-the-title,Capitalize the Title,"```python
class Solution:
    def capitalizeTitle(self, title: str) -> str:
        words = title.split()
        result = []
        for word in words:
            if len(word) <= 2:
                result.append(word.lower())
            else:
                result.append(word[0].upper() + word[1:].lower())
        return ' '.join(result)
```",Y,
find-first-palindromic-string-in-the-array,Find First Palindromic String in the Array,"```python
from typing import List

class Solution:
    def firstPalindrome(self, words: List[str]) -> str:
        for word in words:
            if word == word[::-1]:
                return word
        return """"
```",Y,
rings-and-rods,Rings and Rods,"```python
class Solution:
    def countPoints(self, rings: str) -> int:
        rod_colors = {}
        for i in range(0, len(rings), 2):
            color = rings[i]
            rod = rings[i+1]
            if rod not in rod_colors:
                rod_colors[rod] = set()
            rod_colors[rod].add(color)
        
        count = 0
        for colors in rod_colors.values():
            if len(colors) == 3:
                count += 1
        return count
```",Y,
maximum-number-of-words-found-in-sentences,Maximum Number of Words Found in Sentences,"```python
class Solution:
    def mostWordsFound(self, sentences: List[str]) -> int:
        max_words = 0
        for sentence in sentences:
            word_count = len(sentence.split())
            if word_count > max_words:
                max_words = word_count
        return max_words
```",Y,
finding-3-digit-even-numbers,Finding 3-Digit Even Numbers,"```python
from typing import List

class Solution:
    def findEvenNumbers(self, digits: List[int]) -> List[int]:
        from collections import defaultdict
        
        freq = defaultdict(int)
        for d in digits:
            freq[d] += 1
        
        result = set()
        
        for i in range(100, 1000, 2):
            a, b, c = map(int, str(i))
            temp_freq = defaultdict(int)
            temp_freq[a] += 1
            temp_freq[b] += 1
            temp_freq[c] += 1
            
            valid = True
            for d in temp_freq:
                if temp_freq[d] > freq[d]:
                    valid = False
                    break
            if valid:
                result.add(i)
        
        return sorted(result)
```",Y,
find-target-indices-after-sorting-array,Find Target Indices After Sorting Array,"```python
from typing import List

class Solution:
    def targetIndices(self, nums: List[int], target: int) -> List[int]:
        nums.sort()
        return [i for i, num in enumerate(nums) if num == target]
```",Y,
find-subsequence-of-length-k-with-the-largest-sum,Find Subsequence of Length K With the Largest Sum,"```python
from typing import List

class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        indexed_nums = [(num, i) for i, num in enumerate(nums)]
        indexed_nums.sort(reverse=True, key=lambda x: x[0])
        top_k = indexed_nums[:k]
        top_k.sort(key=lambda x: x[1])
        result = [num for num, i in top_k]
        return result
```",Y,
two-furthest-houses-with-different-colors,Two Furthest Houses With Different Colors,"```python
from typing import List

class Solution:
    def maxDistance(self, colors: List[int]) -> int:
        max_dist = 0
        n = len(colors)
        for i in range(n):
            for j in range(i + 1, n):
                if colors[i] != colors[j]:
                    max_dist = max(max_dist, abs(i - j))
        return max_dist
```",Y,
time-needed-to-buy-tickets,Time Needed to Buy Tickets,"```python
from typing import List

class Solution:
    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        time = 0
        while True:
            for i in range(len(tickets)):
                if tickets[i] > 0:
                    tickets[i] -= 1
                    time += 1
                    if i == k and tickets[i] == 0:
                        return time
```",Y,
count-common-words-with-one-occurrence,Count Common Words With One Occurrence,"```python
from typing import List
from collections import defaultdict

class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        count1 = defaultdict(int)
        count2 = defaultdict(int)
        
        for word in words1:
            count1[word] += 1
        
        for word in words2:
            count2[word] += 1
        
        result = 0
        for word in count1:
            if count1[word] == 1 and count2.get(word, 0) == 1:
                result += 1
        return result
```",Y,
count-vowel-substrings-of-a-string,Count Vowel Substrings of a String,"```python
class Solution:
    def countVowelSubstrings(self, word: str) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        count = 0
        n = len(word)
        for i in range(n):
            if word[i] in vowels:
                seen = set()
                for j in range(i, n):
                    if word[j] not in vowels:
                        break
                    seen.add(word[j])
                    if len(seen) == 5:
                        count += 1
        return count
```",Y,
smallest-index-with-equal-value,Smallest Index With Equal Value,"```python
from typing import List

class Solution:
    def smallestEqual(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            if i % 10 == nums[i]:
                return i
        return -1
```",Y,
check-whether-two-strings-are-almost-equivalent,Check Whether Two Strings are Almost Equivalent,"```python
class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:
        freq1 = [0] * 26
        freq2 = [0] * 26
        
        for c in word1:
            freq1[ord(c) - ord('a')] += 1
        
        for c in word2:
            freq2[ord(c) - ord('a')] += 1
        
        for i in range(26):
            if abs(freq1[i] - freq2[i]) > 3:
                return False
        
        return True
```",Y,
number-of-valid-words-in-a-sentence,Number of Valid Words in a Sentence,"```python
class Solution:
    def countValidWords(self, sentence: str) -> int:
        tokens = sentence.split()
        count = 0
        for token in tokens:
            valid = True
            hyphen_count = 0
            punctuation_count = 0
            for i, c in enumerate(token):
                if c.isdigit():
                    valid = False
                    break
                if c == '-':
                    hyphen_count += 1
                    if hyphen_count > 1 or i == 0 or i == len(token) - 1 or not token[i-1].islower() or not token[i+1].islower():
                        valid = False
                        break
                if c in {'!', '.', ','}:
                    punctuation_count += 1
                    if punctuation_count > 1 or i != len(token) - 1:
                        valid = False
                        break
            if valid:
                count += 1
        return count
```",Y,
check-if-numbers-are-ascending-in-a-sentence,Check if Numbers Are Ascending in a Sentence,"```python
class Solution:
    def areNumbersAscending(self, s: str) -> bool:
        tokens = s.split()
        numbers = []
        for token in tokens:
            if token.isdigit():
                num = int(token)
                numbers.append(num)
        for i in range(1, len(numbers)):
            if numbers[i] <= numbers[i-1]:
                return False
        return True
```",Y,
kth-distinct-string-in-an-array,Kth Distinct String in an Array,"```python
from typing import List

class Solution:
    def kthDistinct(self, arr: List[str], k: int) -> str:
        count = {}
        for s in arr:
            count[s] = count.get(s, 0) + 1
        distinct = []
        for s in arr:
            if count[s] == 1:
                distinct.append(s)
        return distinct[k-1] if k <= len(distinct) else """"
```",Y,
two-out-of-three,Two Out of Three,"```python
class Solution:
    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        set1 = set(nums1)
        set2 = set(nums2)
        set3 = set(nums3)
        
        result = set()
        result.update(set1 & set2)
        result.update(set2 & set3)
        result.update(set1 & set3)
        
        return list(result)
```",Y,
minimum-moves-to-convert-string,Minimum Moves to Convert String,"```python
class Solution:
    def minimumMoves(self, s: str) -> int:
        moves = 0
        i = 0
        n = len(s)
        while i < n:
            if s[i] == 'X':
                moves += 1
                i += 3
            else:
                i += 1
        return moves
```",Y,
minimum-number-of-moves-to-seat-everyone,Minimum Number of Moves to Seat Everyone,"```python
class Solution:
    def minMovesToSeat(self, seats: List[int], students: List[int]) -> int:
        seats.sort()
        students.sort()
        return sum(abs(seat - student) for seat, student in zip(seats, students))
```",Y,
maximum-difference-between-increasing-elements,Maximum Difference Between Increasing Elements,"```python
from typing import List

class Solution:
    def maximumDifference(self, nums: List[int]) -> int:
        min_num = nums[0]
        max_diff = -1
        
        for num in nums[1:]:
            if num > min_num:
                max_diff = max(max_diff, num - min_num)
            else:
                min_num = min(min_num, num)
        
        return max_diff
```",Y,
final-value-of-variable-after-performing-operations,Final Value of Variable After Performing Operations,"```python
class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        x = 0
        for op in operations:
            if op in (""++X"", ""X++""):
                x += 1
            else:
                x -= 1
        return x
```",Y,
convert-1d-array-into-2d-array,Convert 1D Array Into 2D Array,"```python
from typing import List

class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        if len(original) != m * n:
            return []
        return [original[i*n : (i+1)*n] for i in range(m)]
```",Y,
reverse-prefix-of-word,Reverse Prefix of Word,"```python
class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        index = word.find(ch)
        if index != -1:
            return word[:index+1][::-1] + word[index+1:]
        return word
```",Y,
count-special-quadruplets,Count Special Quadruplets,"```python
from typing import List

class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        for a in range(n):
            for b in range(a + 1, n):
                for c in range(b + 1, n):
                    for d in range(c + 1, n):
                        if nums[a] + nums[b] + nums[c] == nums[d]:
                            count += 1
        return count
```",Y,
find-if-path-exists-in-graph,Find if Path Exists in Graph,"```python
from collections import deque
from typing import List

class Solution:
    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
        if source == destination:
            return True
        
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        visited = [False] * n
        queue = deque([source])
        visited[source] = True
        
        while queue:
            current = queue.popleft()
            for neighbor in graph[current]:
                if neighbor == destination:
                    return True
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
        
        return False
```",Y,
count-number-of-pairs-with-absolute-difference-k,Count Number of Pairs With Absolute Difference K,"```python
from typing import List

class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        count = 0
        freq = {}
        for num in nums:
            count += freq.get(num - k, 0) + freq.get(num + k, 0)
            freq[num] = freq.get(num, 0) + 1
        return count
```",Y,
minimum-difference-between-highest-and-lowest-of-k-scores,Minimum Difference Between Highest and Lowest of K Scores,"```python
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        min_diff = float('inf')
        for i in range(len(nums) - k + 1):
            current_diff = nums[i + k - 1] - nums[i]
            if current_diff < min_diff:
                min_diff = current_diff
        return min_diff
```",Y,
find-greatest-common-divisor-of-array,Find Greatest Common Divisor of Array,"```python
from typing import List
import math

class Solution:
    def findGCD(self, nums: List[int]) -> int:
        min_num = min(nums)
        max_num = max(nums)
        return math.gcd(min_num, max_num)
```",Y,
find-the-middle-index-in-array,Find the Middle Index in Array,"```python
from typing import List

class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        total_sum = sum(nums)
        left_sum = 0
        for i, num in enumerate(nums):
            if left_sum == total_sum - left_sum - num:
                return i
            left_sum += num
        return -1
```",Y,
number-of-strings-that-appear-as-substrings-in-word,Number of Strings That Appear as Substrings in Word,"```python
class Solution:
    def numOfStrings(self, patterns: List[str], word: str) -> int:
        count = 0
        for pattern in patterns:
            if pattern in word:
                count += 1
        return count
```",Y,
check-if-string-is-a-prefix-of-array,Check If String Is a Prefix of Array,"```python
from typing import List

class Solution:
    def isPrefixString(self, s: str, words: List[str]) -> bool:
        concatenated = """"
        for word in words:
            concatenated += word
            if concatenated == s:
                return True
            if len(concatenated) > len(s):
                return False
        return False
```",Y,
minimum-time-to-type-word-using-special-typewriter,Minimum Time to Type Word Using Special Typewriter,"```python
class Solution:
    def minTimeToType(self, word: str) -> int:
        total_time = 0
        current_pos = ord('a')
        for c in word:
            target_pos = ord(c)
            diff = abs(target_pos - current_pos)
            move_time = min(diff, 26 - diff)
            total_time += move_time + 1
            current_pos = target_pos
        return total_time
```",Y,
three-divisors,Three Divisors,"```python
class Solution:
    def isThree(self, n: int) -> bool:
        if n < 2:
            return False
        divisors = 0
        for i in range(1, int(n ** 0.5) + 1):
            if n % i == 0:
                if i * i == n:
                    divisors += 1
                else:
                    divisors += 2
            if divisors > 3:
                return False
        return divisors == 3
```",Y,
sum-of-digits-of-string-after-convert,Sum of Digits of String After Convert,"```python
class Solution:
    def getLucky(self, s: str, k: int) -> int:
        num_str = ''.join(str(ord(c) - ord('a') + 1) for c in s)
        
        for _ in range(k):
            num_str = str(sum(int(digit) for digit in num_str))
        
        return int(num_str)
```",Y,
concatenation-of-array,Concatenation of Array,"```python
from typing import List

class Solution:
    def getConcatenation(self, nums: List[int]) -> List[int]:
        return nums + nums
```",Y,
check-if-all-characters-have-equal-number-of-occurrences,Check if All Characters Have Equal Number of Occurrences,"```python
class Solution:
    def areOccurrencesEqual(self, s: str) -> bool:
        from collections import Counter
        counts = Counter(s).values()
        return len(set(counts)) == 1
```",Y,
build-array-from-permutation,Build Array from Permutation,"```python
from typing import List

class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
        return [nums[num] for num in nums]
```",Y,
maximum-product-difference-between-two-pairs,Maximum Product Difference Between Two Pairs,"```python
class Solution:
    def maxProductDifference(self, nums: List[int]) -> int:
        nums_sorted = sorted(nums)
        n = len(nums_sorted)
        return (nums_sorted[n-1] * nums_sorted[n-2]) - (nums_sorted[0] * nums_sorted[1])
```",Y,
count-square-sum-triples,Count Square Sum Triples,"```python
class Solution:
    def countTriples(self, n: int) -> int:
        count = 0
        for a in range(1, n + 1):
            for b in range(1, n + 1):
                c_square = a * a + b * b
                c = int(c_square ** 0.5)
                if c * c == c_square and c <= n:
                    count += 1
        return count
```",Y,
largest-odd-number-in-string,Largest Odd Number in String,"```python
class Solution:
    def largestOddNumber(self, num: str) -> str:
        for i in range(len(num) - 1, -1, -1):
            if int(num[i]) % 2 != 0:
                return num[:i+1]
        return """"
```",Y,
redistribute-characters-to-make-all-strings-equal,Redistribute Characters to Make All Strings Equal,"```python
from typing import List
from collections import defaultdict

class Solution:
    def makeEqual(self, words: List[str]) -> bool:
        char_count = defaultdict(int)
        total_words = len(words)
        
        for word in words:
            for char in word:
                char_count[char] += 1
        
        for count in char_count.values():
            if count % total_words != 0:
                return False
        
        return True
```",Y,
remove-one-element-to-make-the-array-strictly-increasing,Remove One Element to Make the Array Strictly Increasing,"```python
from typing import List

class Solution:
    def canBeIncreasing(self, nums: List[int]) -> bool:
        count = 0
        for i in range(1, len(nums)):
            if nums[i] <= nums[i-1]:
                if count == 1:
                    return False
                if i == 1 or nums[i] > nums[i-2]:
                    nums[i-1] = nums[i]
                else:
                    nums[i] = nums[i-1]
                count += 1
        return True
```",Y,
determine-whether-matrix-can-be-obtained-by-rotation,Determine Whether Matrix Can Be Obtained By Rotation,"```python
from typing import List

class Solution:
    def findRotation(self, mat: List[List[int]], target: List[List[int]]) -> bool:
        if mat == target:
            return True
        n = len(mat)
        for _ in range(3):
            rotated = [[0] * n for _ in range(n)]
            for i in range(n):
                for j in range(n):
                    rotated[j][n - 1 - i] = mat[i][j]
            if rotated == target:
                return True
            mat = rotated
        return False
```",Y,
check-if-word-equals-summation-of-two-words,Check if Word Equals Summation of Two Words,"```python
class Solution:
    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:
        def word_to_num(word):
            num_str = ''.join([str(ord(c) - ord('a')) for c in word])
            return int(num_str) if num_str else 0
        
        first_num = word_to_num(firstWord)
        second_num = word_to_num(secondWord)
        target_num = word_to_num(targetWord)
        
        return first_num + second_num == target_num
```",Y,
check-if-all-the-integers-in-a-range-are-covered,Check if All the Integers in a Range Are Covered,"```python
class Solution:
    def isCovered(self, ranges: List[List[int]], left: int, right: int) -> bool:
        covered = set()
        for start, end in ranges:
            covered.update(range(start, end + 1))
        return all(x in covered for x in range(left, right + 1))
```",Y,
longer-contiguous-segments-of-ones-than-zeros,Longer Contiguous Segments of Ones than Zeros,"```python
class Solution:
    def checkZeroOnes(self, s: str) -> bool:
        max_ones = 0
        max_zeros = 0
        current_ones = 0
        current_zeros = 0
        
        for char in s:
            if char == '1':
                current_ones += 1
                current_zeros = 0
                if current_ones > max_ones:
                    max_ones = current_ones
            else:
                current_zeros += 1
                current_ones = 0
                if current_zeros > max_zeros:
                    max_zeros = current_zeros
        
        return max_ones > max_zeros
```",Y,
sum-of-all-subset-xor-totals,Sum of All Subset XOR Totals,"```python
from typing import List

class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        total = 0
        n = len(nums)
        for mask in range(1 << n):
            current_xor = 0
            for i in range(n):
                if mask & (1 << i):
                    current_xor ^= nums[i]
            total += current_xor
        return total
```",Y,
substrings-of-size-three-with-distinct-characters,Substrings of Size Three with Distinct Characters,"```python
class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count = 0
        for i in range(len(s) - 2):
            substring = s[i:i+3]
            if len(set(substring)) == 3:
                count += 1
        return count
```",Y,
maximum-population-year,Maximum Population Year,"```python
class Solution:
    def maximumPopulation(self, logs: List[List[int]]) -> int:
        delta = [0] * 101  # 1950 to 2050 inclusive is 101 years
        for birth, death in logs:
            delta[birth - 1950] += 1
            delta[death - 1950] -= 1
        
        max_pop = 0
        current_pop = 0
        result_year = 1950
        for year in range(101):
            current_pop += delta[year]
            if current_pop > max_pop:
                max_pop = current_pop
                result_year = year + 1950
        return result_year
```",Y,
minimum-distance-to-the-target-element,Minimum Distance to the Target Element,"```python
from typing import List

class Solution:
    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        min_distance = float('inf')
        for i in range(len(nums)):
            if nums[i] == target:
                current_distance = abs(i - start)
                if current_distance < min_distance:
                    min_distance = current_distance
        return min_distance
```",Y,
sorting-the-sentence,Sorting the Sentence,"```python
class Solution:
    def sortSentence(self, s: str) -> str:
        words = s.split()
        words.sort(key=lambda x: int(x[-1]))
        original = [word[:-1] for word in words]
        return ' '.join(original)
```",Y,
sum-of-digits-in-base-k,Sum of Digits in Base K,"```python
class Solution:
    def sumBase(self, n: int, k: int) -> int:
        total = 0
        while n > 0:
            total += n % k
            n = n // k
        return total
```",Y,
check-if-the-sentence-is-pangram,Check if the Sentence Is Pangram,"```python
class Solution:
    def checkIfPangram(self, sentence: str) -> bool:
        return len(set(sentence)) == 26
```",Y,
replace-all-digits-with-characters,Replace All Digits with Characters,"```python
class Solution:
    def replaceDigits(self, s: str) -> str:
        result = []
        for i in range(len(s)):
            if i % 2 == 1:
                prev_char = s[i-1]
                shift = int(s[i])
                new_char = chr(ord(prev_char) + shift)
                result.append(new_char)
            else:
                result.append(s[i])
        return ''.join(result)
```",Y,
sign-of-the-product-of-an-array,Sign of the Product of an Array,"```python
from typing import List

class Solution:
    def arraySign(self, nums: List[int]) -> int:
        negative_count = 0
        for num in nums:
            if num == 0:
                return 0
            if num < 0:
                negative_count += 1
        return -1 if negative_count % 2 else 1
```",Y,
truncate-sentence,Truncate Sentence,"```python
class Solution:
    def truncateSentence(self, s: str, k: int) -> str:
        words = s.split(' ')
        truncated = ' '.join(words[:k])
        return truncated
```",Y,
minimum-operations-to-make-the-array-increasing,Minimum Operations to Make the Array Increasing,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        operations = 0
        for i in range(1, len(nums)):
            if nums[i] <= nums[i-1]:
                operations += nums[i-1] - nums[i] + 1
                nums[i] = nums[i-1] + 1
        return operations
```",Y,
number-of-different-integers-in-a-string,Number of Different Integers in a String,"```python
class Solution:
    def numDifferentIntegers(self, word: str) -> int:
        s = []
        for c in word:
            if c.isdigit():
                s.append(c)
            else:
                s.append(' ')
        parts = ''.join(s).split()
        unique = set()
        for num in parts:
            stripped = num.lstrip('0')
            if stripped == '':
                unique.add('0')
            else:
                unique.add(stripped)
        return len(unique)
```",Y,
maximum-ascending-subarray-sum,Maximum Ascending Subarray Sum,"```python
from typing import List

class Solution:
    def maxAscendingSum(self, nums: List[int]) -> int:
        max_sum = current_sum = nums[0] if nums else 0
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                current_sum += nums[i]
            else:
                current_sum = nums[i]
            if current_sum > max_sum:
                max_sum = current_sum
        return max_sum
```",Y,
determine-color-of-a-chessboard-square,Determine Color of a Chessboard Square,"```python
class Solution:
    def squareIsWhite(self, coordinates: str) -> bool:
        letter = coordinates[0]
        number = int(coordinates[1])
        return (ord(letter) - ord('a') + number) % 2 == 0
```",Y,
find-center-of-star-graph,Find Center of Star Graph,"```python
from typing import List

class Solution:
    def findCenter(self, edges: List[List[int]]) -> int:
        if edges[0][0] in edges[1]:
            return edges[0][0]
        else:
            return edges[0][1]
```",Y,
check-if-one-string-swap-can-make-strings-equal,Check if One String Swap Can Make Strings Equal,"```python
class Solution:
    def areAlmostEqual(self, s1: str, s2: str) -> bool:
        if s1 == s2:
            return True
        diff = []
        for a, b in zip(s1, s2):
            if a != b:
                diff.append((a, b))
            if len(diff) > 2:
                return False
        return len(diff) == 2 and diff[0] == (diff[1][1], diff[1][0])
```",Y,
check-if-binary-string-has-at-most-one-segment-of-ones,Check if Binary String Has at Most One Segment of Ones,"```python
class Solution:
    def checkOnesSegment(self, s: str) -> bool:
        return '01' not in s
```",Y,
second-largest-digit-in-a-string,Second Largest Digit in a String,"```python
class Solution:
    def secondHighest(self, s: str) -> int:
        digits = set()
        for c in s:
            if c.isdigit():
                digits.add(int(c))
        if len(digits) < 2:
            return -1
        return sorted(digits, reverse=True)[1]
```",Y,
count-items-matching-a-rule,Count Items Matching a Rule,"```python
class Solution:
    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:
        count = 0
        key_map = {""type"": 0, ""color"": 1, ""name"": 2}
        index = key_map[ruleKey]
        for item in items:
            if item[index] == ruleValue:
                count += 1
        return count
```",Y,
merge-strings-alternately,Merge Strings Alternately,"```python
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        merged = []
        i = 0
        while i < len(word1) or i < len(word2):
            if i < len(word1):
                merged.append(word1[i])
            if i < len(word2):
                merged.append(word2[i])
            i += 1
        return ''.join(merged)
```",Y,
find-nearest-point-that-has-the-same-x-or-y-coordinate,Find Nearest Point That Has the Same X or Y Coordinate,"```python
from typing import List

class Solution:
    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:
        min_distance = float('inf')
        result = -1
        for idx, (a, b) in enumerate(points):
            if a == x or b == y:
                distance = abs(x - a) + abs(y - b)
                if distance < min_distance:
                    min_distance = distance
                    result = idx
                elif distance == min_distance and idx < result:
                    result = idx
        return result
```",Y,
minimum-changes-to-make-alternating-binary-string,Minimum Changes To Make Alternating Binary String,"```python
class Solution:
    def minOperations(self, s: str) -> int:
        count1 = 0  # starts with '0'
        count2 = 0  # starts with '1'
        
        for i in range(len(s)):
            current_char = s[i]
            if i % 2 == 0:
                if current_char != '0':
                    count1 += 1
                if current_char != '1':
                    count2 += 1
            else:
                if current_char != '1':
                    count1 += 1
                if current_char != '0':
                    count2 += 1
        
        return min(count1, count2)
```",Y,
check-if-array-is-sorted-and-rotated,Check if Array Is Sorted and Rotated,"```python
from typing import List

class Solution:
    def check(self, nums: List[int]) -> bool:
        count = 0
        n = len(nums)
        for i in range(n):
            if nums[i] > nums[(i + 1) % n]:
                count += 1
                if count > 1:
                    return False
        return True
```",Y,
longest-nice-substring,Longest Nice Substring,"```python
class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        if not s:
            return """"
        chars = set(s)
        for i, c in enumerate(s):
            if c.swapcase() not in chars:
                left = self.longestNiceSubstring(s[:i])
                right = self.longestNiceSubstring(s[i+1:])
                return max(left, right, key=lambda x: (len(x), -s.find(x)))
        return s
```",Y,
latest-time-by-replacing-hidden-digits,Latest Time by Replacing Hidden Digits,"```python
class Solution:
    def maximumTime(self, time: str) -> str:
        time_list = list(time)
        if time_list[0] == '?':
            if time_list[1] == '?' or int(time_list[1]) <= 3:
                time_list[0] = '2'
            else:
                time_list[0] = '1'
        if time_list[1] == '?':
            if time_list[0] == '2':
                time_list[1] = '3'
            else:
                time_list[1] = '9'
        if time_list[3] == '?':
            time_list[3] = '5'
        if time_list[4] == '?':
            time_list[4] = '9'
        return ''.join(time_list)
```",Y,
sum-of-unique-elements,Sum of Unique Elements,"```python
from typing import List

class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        freq = {}
        for num in nums:
            freq[num] = freq.get(num, 0) + 1
        return sum(num for num, count in freq.items() if count == 1)
```",Y,
maximum-number-of-balls-in-a-box,Maximum Number of Balls in a Box,"```python
class Solution:
    def countBalls(self, lowLimit: int, highLimit: int) -> int:
        box_counts = {}
        max_count = 0
        for num in range(lowLimit, highLimit + 1):
            digit_sum = 0
            n = num
            while n > 0:
                digit_sum += n % 10
                n = n // 10
            if digit_sum in box_counts:
                box_counts[digit_sum] += 1
            else:
                box_counts[digit_sum] = 1
            if box_counts[digit_sum] > max_count:
                max_count = box_counts[digit_sum]
        return max_count
```",Y,
number-of-rectangles-that-can-form-the-largest-square,Number Of Rectangles That Can Form The Largest Square,"```python
from typing import List

class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        max_len = 0
        count = 0
        for rect in rectangles:
            current = min(rect)
            if current > max_len:
                max_len = current
                count = 1
            elif current == max_len:
                count += 1
        return count
```",Y,
decode-xored-array,Decode XORed Array,"```python
from typing import List

class Solution:
    def decode(self, encoded: List[int], first: int) -> List[int]:
        arr = [first]
        for num in encoded:
            arr.append(arr[-1] ^ num)
        return arr
```",Y,
find-the-highest-altitude,Find the Highest Altitude,"```python
from typing import List

class Solution:
    def largestAltitude(self, gain: List[int]) -> int:
        max_altitude = current_altitude = 0
        for g in gain:
            current_altitude += g
            if current_altitude > max_altitude:
                max_altitude = current_altitude
        return max_altitude
```",Y,
maximum-units-on-a-truck,Maximum Units on a Truck,"```python
class Solution:
    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        boxTypes.sort(key=lambda x: -x[1])
        total_units = 0
        remaining = truckSize
        for boxes, units in boxTypes:
            if remaining <= 0:
                break
            take = min(boxes, remaining)
            total_units += take * units
            remaining -= take
        return total_units
```",Y,
determine-if-string-halves-are-alike,Determine if String Halves Are Alike,"```python
class Solution:
    def halvesAreAlike(self, s: str) -> bool:
        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}
        half = len(s) // 2
        a = s[:half]
        b = s[half:]
        count_a = sum(1 for char in a if char in vowels)
        count_b = sum(1 for char in b if char in vowels)
        return count_a == count_b
```",Y,
calculate-money-in-leetcode-bank,Calculate Money in Leetcode Bank,"```python
class Solution:
    def totalMoney(self, n: int) -> int:
        total = 0
        weeks = n // 7
        remaining_days = n % 7
        
        total += 28 * weeks
        total += 7 * (weeks * (weeks - 1)) // 2
        
        monday_start = weeks + 1
        total += remaining_days * (2 * monday_start + remaining_days - 1) // 2
        
        return total
```",Y,
reformat-phone-number,Reformat Phone Number,"```python
class Solution:
    def reformatNumber(self, number: str) -> str:
        digits = [c for c in number if c.isdigit()]
        n = len(digits)
        result = []
        i = 0
        while i < n:
            remaining = n - i
            if remaining > 4:
                result.append(''.join(digits[i:i+3]))
                i += 3
            else:
                if remaining == 4:
                    result.append(''.join(digits[i:i+2]))
                    result.append(''.join(digits[i+2:i+4]))
                elif remaining == 3:
                    result.append(''.join(digits[i:i+3]))
                elif remaining == 2:
                    result.append(''.join(digits[i:i+2]))
                break
        return '-'.join(result)
```",Y,
count-of-matches-in-tournament,Count of Matches in Tournament,"```python
class Solution:
    def numberOfMatches(self, n: int) -> int:
        matches = 0
        while n > 1:
            if n % 2 == 0:
                matches += n // 2
                n = n // 2
            else:
                matches += (n - 1) // 2
                n = (n - 1) // 2 + 1
        return matches
```",Y,
number-of-students-unable-to-eat-lunch,Number of Students Unable to Eat Lunch,"```python
from typing import List

class Solution:
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        from collections import deque
        
        student_queue = deque(students)
        sandwich_stack = sandwiches.copy()
        
        while student_queue and sandwich_stack:
            if student_queue[0] == sandwich_stack[0]:
                student_queue.popleft()
                sandwich_stack.pop(0)
            else:
                if sandwich_stack[0] not in student_queue:
                    break
                student_queue.append(student_queue.popleft())
        
        return len(student_queue)
```",Y,
goal-parser-interpretation,Goal Parser Interpretation,"```python
class Solution:
    def interpret(self, command: str) -> str:
        result = []
        i = 0
        n = len(command)
        while i < n:
            if command[i] == 'G':
                result.append('G')
                i += 1
            elif command[i] == '(':
                if i + 1 < n and command[i+1] == ')':
                    result.append('o')
                    i += 2
                elif i + 3 < n and command[i+1] == 'a' and command[i+2] == 'l' and command[i+3] == ')':
                    result.append('al')
                    i += 4
                else:
                    i += 1
            else:
                i += 1
        return ''.join(result)
```",Y,
richest-customer-wealth,Richest Customer Wealth,"```python
class Solution:
    def maximumWealth(self, accounts: List[List[int]]) -> int:
        return max(sum(customer) for customer in accounts)
```",Y,
count-the-number-of-consistent-strings,Count the Number of Consistent Strings,"```python
class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        allowed_set = set(allowed)
        count = 0
        for word in words:
            consistent = True
            for c in word:
                if c not in allowed_set:
                    consistent = False
                    break
            if consistent:
                count += 1
        return count
```",Y,
check-if-two-string-arrays-are-equivalent,Check If Two String Arrays are Equivalent,"```python
class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        return ''.join(word1) == ''.join(word2)
```",Y,
design-an-ordered-stream,Design an Ordered Stream,"```python
class OrderedStream:

    def __init__(self, n: int):
        self.stream = [None] * (n + 2)  # 1-based indexing, extra space to avoid index issues
        self.ptr = 1

    def insert(self, idKey: int, value: str) -> List[str]:
        self.stream[idKey] = value
        result = []
        while self.ptr < len(self.stream) and self.stream[self.ptr] is not None:
            result.append(self.stream[self.ptr])
            self.ptr += 1
        return result


```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
get-maximum-in-generated-array,Get Maximum in Generated Array,"```python
class Solution:
    def getMaximumGenerated(self, n: int) -> int:
        if n == 0:
            return 0
        nums = [0] * (n + 1)
        nums[1] = 1
        max_num = 1
        for i in range(2, n + 1):
            if i % 2 == 0:
                nums[i] = nums[i // 2]
            else:
                nums[i] = nums[i // 2] + nums[i // 2 + 1]
            if nums[i] > max_num:
                max_num = nums[i]
        return max_num
```",Y,
maximum-repeating-substring,Maximum Repeating Substring,"```python
class Solution:
    def maxRepeating(self, sequence: str, word: str) -> int:
        max_k = 0
        current_word = word
        while len(current_word) <= len(sequence):
            if current_word in sequence:
                max_k += 1
                current_word += word
            else:
                break
        return max_k
```",Y,
check-array-formation-through-concatenation,Check Array Formation Through Concatenation,"```python
from typing import List

class Solution:
    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        piece_map = {p[0]: p for p in pieces}
        i = 0
        n = len(arr)
        while i < n:
            if arr[i] not in piece_map:
                return False
            piece = piece_map[arr[i]]
            for num in piece:
                if i >= n or arr[i] != num:
                    return False
                i += 1
        return True
```",Y,
defuse-the-bomb,Defuse the Bomb,"```python
from typing import List

class Solution:
    def decrypt(self, code: List[int], k: int) -> List[int]:
        n = len(code)
        result = []
        if k == 0:
            return [0] * n
        for i in range(n):
            total = 0
            if k > 0:
                for j in range(1, k + 1):
                    total += code[(i + j) % n]
            else:
                for j in range(1, -k + 1):
                    total += code[(i - j) % n]
            result.append(total)
        return result
```",Y,
slowest-key,Slowest Key,"```python
from typing import List

class Solution:
    def slowestKey(self, releaseTimes: List[int], keysPressed: str) -> str:
        max_duration = releaseTimes[0]
        result_key = keysPressed[0]
        
        for i in range(1, len(releaseTimes)):
            duration = releaseTimes[i] - releaseTimes[i-1]
            if duration > max_duration:
                max_duration = duration
                result_key = keysPressed[i]
            elif duration == max_duration:
                if keysPressed[i] > result_key:
                    result_key = keysPressed[i]
        
        return result_key
```",Y,
largest-substring-between-two-equal-characters,Largest Substring Between Two Equal Characters,"```python
class Solution:
    def maxLengthBetweenEqualCharacters(self, s: str) -> int:
        first_occurrence = {}
        max_length = -1
        
        for i, char in enumerate(s):
            if char in first_occurrence:
                max_length = max(max_length, i - first_occurrence[char] - 1)
            else:
                first_occurrence[char] = i
        
        return max_length
```",Y,
widest-vertical-area-between-two-points-containing-no-points,Widest Vertical Area Between Two Points Containing No Points,"```python
class Solution:
    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:
        x_coords = sorted([point[0] for point in points])
        max_width = 0
        for i in range(1, len(x_coords)):
            width = x_coords[i] - x_coords[i-1]
            if width > max_width:
                max_width = width
        return max_width
```",Y,
sort-array-by-increasing-frequency,Sort Array by Increasing Frequency,"```python
from collections import defaultdict
from typing import List

class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        frequency = defaultdict(int)
        for num in nums:
            frequency[num] += 1
        
        nums.sort(key=lambda x: (frequency[x], -x))
        return nums
```",Y,
maximum-nesting-depth-of-the-parentheses,Maximum Nesting Depth of the Parentheses,"```python
class Solution:
    def maxDepth(self, s: str) -> int:
        max_depth = 0
        current_depth = 0
        for char in s:
            if char == '(':
                current_depth += 1
                if current_depth > max_depth:
                    max_depth = current_depth
            elif char == ')':
                current_depth -= 1
        return max_depth
```",Y,
properties-graph,Properties Graph,"```python
from typing import List

class Solution:
    def numberOfComponents(self, properties: List[List[int]], k: int) -> int:
        n = len(properties)
        parent = [i for i in range(n)]
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            root_u = find(u)
            root_v = find(v)
            if root_u != root_v:
                parent[root_v] = root_u
        
        prop_sets = [set(prop) for prop in properties]
        
        for i in range(n):
            for j in range(i + 1, n):
                common = len(prop_sets[i] & prop_sets[j])
                if common >= k:
                    union(i, j)
        
        roots = set()
        for i in range(n):
            roots.add(find(i))
        
        return len(roots)
```",Y,
design-spreadsheet,Design Spreadsheet,"```python
class Spreadsheet:

    def __init__(self, rows: int):
        self.rows = rows
        self.cells = {}

    def setCell(self, cell: str, value: int) -> None:
        self.cells[cell] = value

    def resetCell(self, cell: str) -> None:
        self.cells[cell] = 0

    def getValue(self, formula: str) -> int:
        if not formula.startswith('='):
            return 0  # though per problem statement, formula always starts with '='
        expr = formula[1:]
        parts = expr.split('+')
        total = 0
        for part in parts:
            if part[0].isalpha():
                total += self.cells.get(part, 0)
            else:
                total += int(part)
        return total
```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
zero-array-transformation-iv,Zero Array Transformation IV,"```python
from typing import List

class Solution:
    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        original = nums.copy()
        
        for k in range(1, m + 1):
            nums = original.copy()
            for i in range(k):
                l, r, val = queries[i]
                for j in range(l, r + 1):
                    if nums[j] >= val:
                        nums[j] -= val
                    else:
                        break
                else:
                    continue
                break
            else:
                if all(x == 0 for x in nums):
                    return k
        
        return -1
```",Y,
find-the-minimum-amount-of-time-to-brew-potions,Find the Minimum Amount of Time to Brew Potions,"```python
from typing import List

class Solution:
    def minTime(self, skill: List[int], mana: List[int]) -> int:
        n = len(skill)
        m = len(mana)
        if n == 0 or m == 0:
            return 0
        
        time = [[0] * m for _ in range(n)]
        for i in range(n):
            for j in range(m):
                time[i][j] = skill[i] * mana[j]
        
        end_times = [[0] * m for _ in range(n)]
        end_times[0][0] = time[0][0]
        for i in range(1, n):
            end_times[i][0] = end_times[i-1][0] + time[i][0]
        
        for j in range(1, m):
            end_times[0][j] = end_times[0][j-1] + time[0][j]
        
        for i in range(1, n):
            for j in range(1, m):
                end_times[i][j] = max(end_times[i-1][j], end_times[i][j-1]) + time[i][j]
        
        return end_times[-1][-1]
```",Y,
fruits-into-baskets-iii,Fruits Into Baskets III,"```python
from typing import List

class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        baskets_sorted = sorted(baskets)
        used = [False] * len(baskets_sorted)
        unplaced = 0
        
        for fruit in fruits:
            placed = False
            for i in range(len(baskets_sorted)):
                if not used[i] and baskets_sorted[i] >= fruit:
                    used[i] = True
                    placed = True
                    break
            if not placed:
                unplaced += 1
                
        return unplaced
```",Y,
longest-palindromic-subsequence-after-at-most-k-operations,Longest Palindromic Subsequence After at Most K Operations,"```python
class Solution:
    def longestPalindromicSubsequence(self, s: str, k: int) -> int:
        n = len(s)
        memo = {}

        def dp(i, j, k_left):
            if (i, j, k_left) in memo:
                return memo[(i, j, k_left)]
            if i > j:
                return 0
            if i == j:
                return 1
            if s[i] == s[j]:
                res = 2 + dp(i + 1, j - 1, k_left)
            else:
                if k_left > 0:
                    cost_i = (ord(s[j]) - ord(s[i])) % 26
                    cost_i = min(cost_i, 26 - cost_i)
                    if cost_i <= k_left:
                        option1 = 2 + dp(i + 1, j - 1, k_left - cost_i)
                    else:
                        option1 = 0
                    cost_j = (ord(s[i]) - ord(s[j])) % 26
                    cost_j = min(cost_j, 26 - cost_j)
                    if cost_j <= k_left:
                        option2 = 2 + dp(i + 1, j - 1, k_left - cost_j)
                    else:
                        option2 = 0
                    option3 = max(dp(i + 1, j, k_left), dp(i, j - 1, k_left))
                    res = max(option1, option2, option3)
                else:
                    res = max(dp(i + 1, j, k_left), dp(i, j - 1, k_left))
            memo[(i, j, k_left)] = res
            return res

        return dp(0, n - 1, k)
```",Y,
find-the-number-of-copy-arrays,Find the Number of Copy Arrays,"```python
from typing import List

class Solution:
    def countArrays(self, original: List[int], bounds: List[List[int]]) -> int:
        n = len(original)
        if n == 0:
            return 0
        
        min_k = -float('inf')
        max_k = float('inf')
        
        for i in range(1, n):
            delta_original = original[i] - original[i-1]
            lower_i = bounds[i][0]
            upper_i = bounds[i][1]
            lower_prev = bounds[i-1][0]
            upper_prev = bounds[i-1][1]
            
            new_lower = lower_i - delta_original
            new_upper = upper_i - delta_original
            
            current_lower = max(lower_prev, new_lower)
            current_upper = min(upper_prev, new_upper)
            
            if current_lower > current_upper:
                return 0
            
            k_lower = bounds[0][0] - original[0]
            k_upper = bounds[0][1] - original[0]
            
            k_lower = max(k_lower, current_lower - original[i-1])
            k_upper = min(k_upper, current_upper - original[i-1])
            
            if k_lower > k_upper:
                return 0
        
        last_lower = bounds[-1][0] - original[-1]
        last_upper = bounds[-1][1] - original[-1]
        k_lower = max(k_lower, last_lower)
        k_upper = min(k_upper, last_upper)
        
        if k_lower > k_upper:
            return 0
        
        return k_upper - k_lower + 1
```",Y,
eat-pizzas,Eat Pizzas!,"```python
from typing import List

class Solution:
    def maxWeight(self, pizzas: List[int]) -> int:
        pizzas.sort()
        total = 0
        n = len(pizzas)
        day = 1
        left = 0
        right = n - 1
        while left <= right:
            if day % 2 == 1:
                total += pizzas[right]
                right -= 4
            else:
                total += pizzas[right - 1]
                right -= 4
            day += 1
        return total
```",Y,
find-minimum-cost-to-remove-array-elements,Find Minimum Cost to Remove Array Elements,"```python
from typing import List

class Solution:
    def minCost(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        
        for length in range(1, n + 1):
            for i in range(n - length + 1):
                j = i + length
                if length <= 2:
                    dp[i][j] = max(nums[i:j])
                else:
                    min_cost = float('inf')
                    for k in range(i + 1, j):
                        cost = dp[i][k] + dp[k][j]
                        if cost < min_cost:
                            min_cost = cost
                    dp[i][j] = min_cost
                    if length == 3:
                        dp[i][j] = min(dp[i][j], max(nums[i], nums[i+1]) + max(nums[i+2], 0))
                        dp[i][j] = min(dp[i][j], max(nums[i], nums[i+2]) + max(nums[i+1], 0))
                        dp[i][j] = min(dp[i][j], max(nums[i+1], nums[i+2]) + max(nums[i], 0))
        return dp[0][n]
```",Y,
select-k-disjoint-special-substrings,Select K Disjoint Special Substrings,"```python
class Solution:
    def maxSubstringLength(self, s: str, k: int) -> bool:
        if k == 0:
            return True
        n = len(s)
        if k > 26:
            return False
        
        last_occurrence = {}
        for i, ch in enumerate(s):
            last_occurrence[ch] = i
        
        result = 0
        start = 0
        min_end = float('inf')
        
        for i, ch in enumerate(s):
            min_end = min(min_end, last_occurrence[ch])
            if i == min_end:
                if i - start + 1 < n:
                    result += 1
                    if result >= k:
                        return True
                start = i + 1
                min_end = float('inf')
        
        return result >= k
```",Y,
maximum-sum-with-at-most-k-elements,Maximum Sum With at Most K Elements,"```python
from typing import List
import heapq

class Solution:
    def maxSum(self, grid: List[List[int]], limits: List[int], k: int) -> int:
        max_heap = []
        for i in range(len(grid)):
            row = grid[i]
            limit = limits[i]
            sorted_row = sorted(row, reverse=True)
            for num in sorted_row[:limit]:
                heapq.heappush(max_heap, -num)  # Using a min-heap as a max-heap
        
        total = 0
        count = 0
        while max_heap and count < k:
            total += -heapq.heappop(max_heap)
            count += 1
        return total
```",Y,
separate-squares-i,Separate Squares I,"```python
class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        def compute_area(y_line):
            area_above = 0.0
            area_below = 0.0
            for x, y, l in squares:
                top = y + l
                if y >= y_line:
                    area_above += l * l
                elif top <= y_line:
                    area_below += l * l
                else:
                    overlap = top - y_line
                    area_above += overlap * l
                    area_below += (l * l - overlap * l)
            return area_above, area_below
        
        left = 0.0
        right = 0.0
        for x, y, l in squares:
            right = max(right, y + l)
        
        precision = 1e-7
        while right - left > precision:
            mid = (left + right) / 2
            area_above, area_below = compute_area(mid)
            if area_above > area_below:
                left = mid
            else:
                right = mid
        return left
```",Y,
assign-elements-to-groups-with-constraints,Assign Elements to Groups with Constraints,"```python
from typing import List

class Solution:
    def assignElements(self, groups: List[int], elements: List[int]) -> List[int]:
        assigned = []
        element_indices = {}  # Maps element value to the smallest index
        
        for j in range(len(elements)):
            val = elements[j]
            if val not in element_indices:
                element_indices[val] = j
        
        for group_size in groups:
            found = -1
            for val in sorted(element_indices.keys()):
                if group_size % val == 0:
                    found = element_indices[val]
                    break
            assigned.append(found)
        return assigned
```",Y,
choose-k-elements-with-maximum-sum,Choose K Elements With Maximum Sum,"```python
import bisect
import heapq

class Solution:
    def findMaxSum(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        n = len(nums1)
        indices = sorted(range(n), key=lambda i: nums1[i])
        sorted_nums1 = [nums1[i] for i in indices]
        sorted_nums2 = [nums2[i] for i in indices]
        
        prefix_heap = []
        prefix_sums = []
        current_sum = 0
        res = [0] * n
        
        for i in range(n):
            num = sorted_nums2[i]
            if len(prefix_heap) < k:
                heapq.heappush(prefix_heap, num)
                current_sum += num
            else:
                if prefix_heap[0] < num:
                    popped = heapq.heappop(prefix_heap)
                    current_sum -= popped
                    heapq.heappush(prefix_heap, num)
                    current_sum += num
            prefix_sums.append(current_sum)
        
        original_indices = [0] * n
        for pos, idx in enumerate(indices):
            original_indices[idx] = pos
        
        for i in range(n):
            target = nums1[i]
            pos = bisect.bisect_left(sorted_nums1, target)
            if pos == 0:
                res[i] = 0
            else:
                res[i] = prefix_sums[pos - 1] if k <= pos else prefix_sums[pos - 1]
        
        return res
```",Y,
maximum-manhattan-distance-after-k-changes,Maximum Manhattan Distance After K Changes,"```python
class Solution:
    def maxDistance(self, s: str, k: int) -> int:
        max_dist = 0
        x, y = 0, 0
        n = len(s)
        
        
        
        
        
        
        max_total = 0
        
        for m in range(0, k + 1):
            vert_changes = m
            horz_changes = k - m
            x, y = 0, 0
            current_max = 0
            for c in s:
                dx, dy = 0, 0
                if c == 'N':
                    dy = 1
                elif c == 'S':
                    dy = -1
                elif c == 'E':
                    dx = 1
                elif c == 'W':
                    dx = -1
                
                new_dx, new_dy = dx, dy
                if vert_changes > 0 and (c == 'N' or c == 'S'):
                    new_dy = 1 if (y >= 0) else -1
                    vert_changes -= 1
                elif horz_changes > 0 and (c == 'E' or c == 'W'):
                    new_dx = 1 if (x >= 0) else -1
                    horz_changes -= 1
                
                x += new_dx
                y += new_dy
                current_max = max(current_max, abs(x) + abs(y))
            
            max_total = max(max_total, current_max)
        
        return max_total
```",Y,
maximum-frequency-after-subarray-operation,Maximum Frequency After Subarray Operation,"```python
from typing import List

class Solution:
    def maxFrequency(self, nums: List[int], k: int) -> int:
        max_freq = 0
        n = len(nums)
        
        
        
        
        total_k = nums.count(k)
        max_freq = total_k  # at least this, by choosing empty subarray
        
        
        from collections import defaultdict
        
        
        max_diff = 0
        current_diff = 0
        val_to_max_diff = defaultdict(int)
        
        for num in nums:
            if num == k:
                current_diff -= 1
            else:
                current_diff += 1
            if current_diff > max_diff:
                max_diff = current_diff
            if current_diff < 0:
                current_diff = 0
        max_freq = total_k + max_diff
        
        return max_freq
```",Y,
closest-equal-element-queries,Closest Equal Element Queries,"```python
from collections import defaultdict
from bisect import bisect_left, bisect_right
from typing import List

class Solution:
    def solveQueries(self, nums: List[int], queries: List[int]) -> List[int]:
        value_indices = defaultdict(list)
        for idx, num in enumerate(nums):
            value_indices[num].append(idx)
        
        answer = []
        n = len(nums)
        for query in queries:
            target = nums[query]
            indices = value_indices.get(target, [])
            if len(indices) <= 1:
                answer.append(-1)
                continue
            
            pos = bisect_left(indices, query)
            min_dist = float('inf')
            if pos > 0:
                min_dist = min(min_dist, (query - indices[pos - 1]) % n)
            if pos < len(indices) - 1:
                min_dist = min(min_dist, (indices[pos + 1] - query) % n)
            if pos < len(indices):
                if indices[pos] != query:
                    min_dist = min(min_dist, (indices[pos] - query) % n)
                elif pos + 1 < len(indices):
                    min_dist = min(min_dist, (indices[pos + 1] - query) % n)
            if pos > 0:
                if indices[pos - 1] != query:
                    min_dist = min(min_dist, (query - indices[pos - 1]) % n)
                elif pos - 2 >= 0:
                    min_dist = min(min_dist, (query - indices[pos - 2]) % n)
            
            answer.append(min_dist if min_dist != float('inf') else -1)
        
        return answer
```",Y,
sort-matrix-by-diagonals,Sort Matrix by Diagonals,"```python
from typing import List

class Solution:
    def sortMatrix(self, grid: List[List[int]]) -> List[List[int]]:
        n = len(grid)
        for d in range(n):
            diagonal = []
            i, j = d, 0
            while i < n and j < n:
                diagonal.append(grid[i][j])
                i += 1
                j += 1
            diagonal.sort(reverse=True)
            i, j = d, 0
            idx = 0
            while i < n and j < n:
                grid[i][j] = diagonal[idx]
                i += 1
                j += 1
                idx += 1
        
        for d in range(1, n):
            diagonal = []
            i, j = 0, d
            while i < n and j < n:
                diagonal.append(grid[i][j])
                i += 1
                j += 1
            diagonal.sort()
            i, j = 0, d
            idx = 0
            while i < n and j < n:
                grid[i][j] = diagonal[idx]
                i += 1
                j += 1
                idx += 1
        
        return grid
```",Y,
reschedule-meetings-for-maximum-free-time-i,Reschedule Meetings for Maximum Free Time I,"```python
from typing import List

class Solution:
    def maxFreeTime(self, eventTime: int, k: int, startTime: List[int], endTime: List[int]) -> int:
        n = len(startTime)
        if n == 0:
            return eventTime
        
        gaps = []
        gaps.append(startTime[0] - 0)
        for i in range(1, n):
            gaps.append(startTime[i] - endTime[i-1])
        gaps.append(eventTime - endTime[-1])
        
        if k == 0:
            return max(gaps)
        
        max_gap = 0
        current_sum = sum(gaps[:k+1])
        max_gap = current_sum
        
        for i in range(k+1, len(gaps)):
            current_sum += gaps[i] - gaps[i - (k+1)]
            if current_sum > max_gap:
                max_gap = current_sum
        
        return max_gap
```",Y,
reschedule-meetings-for-maximum-free-time-ii,Reschedule Meetings for Maximum Free Time II,"```python
from typing import List

class Solution:
    def maxFreeTime(self, eventTime: int, startTime: List[int], endTime: List[int]) -> int:
        intervals = sorted(zip(startTime, endTime), key=lambda x: x[0])
        n = len(intervals)
        if n == 0:
            return eventTime
        
        max_gap = 0
        gaps = []
        prev_end = 0
        for s, e in intervals:
            gap = s - prev_end
            gaps.append(gap)
            if gap > max_gap:
                max_gap = gap
            prev_end = e
        gap_after_last = eventTime - intervals[-1][1]
        gaps.append(gap_after_last)
        if gap_after_last > max_gap:
            max_gap = gap_after_last
        
        if n == 1:
            s, e = intervals[0]
            duration = e - s
            return max(eventTime - duration, intervals[0][0])
        
        prefix_max = [0] * (n + 1)
        suffix_max = [0] * (n + 1)
        
        for i in range(1, n + 1):
            prefix_max[i] = max(prefix_max[i-1], gaps[i-1])
        
        for i in range(n - 1, -1, -1):
            suffix_max[i] = max(suffix_max[i+1], gaps[i+1])
        
        res = max_gap  # initial max without moving any meeting
        
        for i in range(n):
            s, e = intervals[i]
            duration = e - s
            if i == 0:
                new_start = eventTime - duration
                if new_start >= intervals[1][0] - duration:
                    continue  # can't move without overlapping
                new_gap_before = intervals[1][0] - 0
                new_gap_after = eventTime - (new_start + duration)
                current_max = max(new_gap_before, new_gap_after)
                if i + 1 < n:
                    current_max = max(current_max, suffix_max[i+1])
                res = max(res, current_max)
            elif i == n - 1:
                new_start = 0
                new_end = duration
                if new_end > intervals[-2][1]:
                    continue  # can't move without overlapping
                new_gap_before = new_start - intervals[-2][1]
                new_gap_after = eventTime - new_end
                current_max = max(new_gap_before, new_gap_after)
                if i - 1 >= 0:
                    current_max = max(current_max, prefix_max[i])
                res = max(res, current_max)
            else:
                new_start = intervals[i-1][1]
                new_end = new_start + duration
                if new_end > intervals[i+1][0]:
                    continue  # overlaps with next meeting
                new_gap_before = new_start - intervals[i-1][1]
                new_gap_after = intervals[i+1][0] - new_end
                current_max = max(prefix_max[i], suffix_max[i+1])
                current_max = max(current_max, new_gap_before, new_gap_after)
                res = max(res, current_max)
                
                new_end = intervals[i+1][0]
                new_start = new_end - duration
                if new_start < intervals[i-1][1]:
                    continue  # overlaps with previous meeting
                new_gap_before = new_start - intervals[i-1][1]
                new_gap_after = intervals[i+1][0] - new_end
                current_max = max(prefix_max[i], suffix_max[i+1])
                current_max = max(current_max, new_gap_before, new_gap_after)
                res = max(res, current_max)
        
        return res
```",Y,
paint-house-iv,Paint House IV,"```python
from typing import List

class Solution:
    def minCost(self, n: int, cost: List[List[int]]) -> int:
        if n == 2:
            min_cost = float('inf')
            for c1 in range(3):
                for c2 in range(3):
                    if c1 != c2:
                        min_cost = min(min_cost, cost[0][c1] + cost[1][c2])
            return min_cost
        
        half = n // 2
        dp_first = [[float('inf')] * 3 for _ in range(half)]
        for c in range(3):
            dp_first[0][c] = cost[0][c]
        
        for i in range(1, half):
            for c in range(3):
                min_prev = float('inf')
                for prev_c in range(3):
                    if prev_c != c:
                        min_prev = min(min_prev, dp_first[i-1][prev_c])
                dp_first[i][c] = min_prev + cost[i][c]
        
        dp_second = [[float('inf')] * 3 for _ in range(half)]
        for c in range(3):
            dp_second[-1][c] = cost[n - 1 - half][c]
        
        for i in range(half - 2, -1, -1):
            for c in range(3):
                min_next = float('inf')
                for next_c in range(3):
                    if next_c != c:
                        min_next = min(min_next, dp_second[i+1][next_c])
                dp_second[i][c] = min_next + cost[n - 1 - i][c]
        
        min_total = float('inf')
        for c1 in range(3):
            for c2 in range(3):
                if c1 != c2:
                    min_total = min(min_total, dp_first[-1][c1] + dp_second[0][c2])
        
        return min_total
```",Y,
sum-of-k-subarrays-with-length-at-least-m,Sum of K Subarrays With Length at Least M,"```python
from typing import List

class Solution:
    def maxSum(self, nums: List[int], k: int, m: int) -> int:
        n = len(nums)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + nums[i]
        
        dp = [[-float('inf')] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        
        for i in range(1, n + 1):
            dp[i][0] = 0
            for j in range(1, k + 1):
                dp[i][j] = dp[i-1][j]  # not taking nums[i-1] in any subarray
                if i >= m:
                    for l in range(m, i + 1):
                        if i - l >= 0 and dp[i - l][j - 1] != -float('inf'):
                            current_sum = prefix[i] - prefix[i - l]
                            dp[i][j] = max(dp[i][j], dp[i - l][j - 1] + current_sum)
        
        return dp[n][k]
```",Y,
count-mentions-per-user,Count Mentions Per User,"```python
from typing import List

class Solution:
    def countMentions(self, numberOfUsers: int, events: List[List[str]]) -> List[int]:
        mentions = [0] * numberOfUsers
        online_status = [True] * numberOfUsers
        offline_events = []  # list of (end_time, user_id)
        
        events.sort(key=lambda x: int(x[1]))
        
        for event in events:
            event_type, timestamp_str, data = event
            timestamp = int(timestamp_str)
            
            new_offline_events = []
            for end_time, user_id in offline_events:
                if end_time <= timestamp:
                    online_status[user_id] = True
                else:
                    new_offline_events.append((end_time, user_id))
            offline_events = new_offline_events
            
            if event_type == ""OFFLINE"":
                user_id = int(data)
                offline_events.append((timestamp + 60, user_id))
                online_status[user_id] = False
            elif event_type == ""MESSAGE"":
                if data == ""ALL"":
                    for i in range(numberOfUsers):
                        mentions[i] += 1
                elif data == ""HERE"":
                    for i in range(numberOfUsers):
                        if online_status[i]:
                            mentions[i] += 1
                else:
                    parts = data.split()
                    for part in parts:
                        if part.startswith(""id""):
                            user_id = int(part[2:])
                            mentions[user_id] += 1
        
        return mentions
```",Y,
minimize-the-maximum-edge-weight-of-graph,Minimize the Maximum Edge Weight of Graph,"```python
import heapq
from collections import defaultdict
from typing import List

class Solution:
    def minMaxWeight(self, n: int, edges: List[List[int]], threshold: int) -> int:
        reversed_edges = defaultdict(list)
        for a, b, w in edges:
            reversed_edges[b].append((a, w))
        
        left = 1
        right = max(w for _, _, w in edges) if edges else 0
        answer = -1
        
        def is_possible(max_weight):
            
            adj = defaultdict(list)
            for a, b, w in edges:
                if w <= max_weight:
                    adj[b].append((a, w))  # reversed edge
            
            min_edges = [threshold + 1] * n
            min_edges[0] = 0
            heap = []
            heapq.heappush(heap, (0, 0))  # (edges, node)
            
            while heap:
                current_edges, u = heapq.heappop(heap)
                if current_edges > min_edges[u]:
                    continue
                for v, w in adj[u]:
                    if min_edges[v] > current_edges + 1:
                        min_edges[v] = current_edges + 1
                        heapq.heappush(heap, (min_edges[v], v))
            
            for i in range(n):
                if min_edges[i] > threshold:
                    return False
            return True
        
        if not edges:
            return 0 if n == 1 else -1
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        return answer
```",Y,
longest-subsequence-with-decreasing-adjacent-difference,Longest Subsequence With Decreasing Adjacent Difference,"```python
from typing import List

class Solution:
    def longestSubsequence(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        
        dp = [1] * n
        diff = [0] * n
        
        for i in range(1, n):
            for j in range(i):
                current_diff = abs(nums[i] - nums[j])
                if dp[j] >= dp[i]:
                    if dp[j] == 1:
                        dp[i] = dp[j] + 1
                        diff[i] = current_diff
                    else:
                        if current_diff <= diff[j]:
                            dp[i] = dp[j] + 1
                            diff[i] = current_diff
        return max(dp)
```",Y,
maximum-coins-from-k-consecutive-bags,Maximum Coins From K Consecutive Bags,"```python
from typing import List

class Solution:
    def maximumCoins(self, coins: List[List[int]], k: int) -> int:
        events = []
        for l, r, c in coins:
            events.append((l, c))
            events.append((r + 1, -c))
        
        events.sort()
        max_coins = 0
        current_coins = 0
        prev_pos = None
        
        for pos, delta in events:
            if prev_pos is not None and pos > prev_pos:
                segment_length = pos - prev_pos
                max_segment = min(segment_length, k)
                max_coins = max(max_coins, current_coins * max_segment)
                k -= max_segment
                if k <= 0:
                    break
            current_coins += delta
            prev_pos = pos
        
        return max_coins
```",Y,
maximum-and-minimum-sums-of-at-most-size-k-subsequences,Maximum and Minimum Sums of at Most Size K Subsequences,"```python
import bisect

class Solution:
    def minMaxSums(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        nums.sort()
        n = len(nums)
        res = 0
        
        pow2 = [1] * (n + 1)
        for i in range(1, n + 1):
            pow2[i] = (pow2[i-1] * 2) % MOD
        
        for i in range(n):
            right = n - i - 1
            max_j = min(k - 1, right)
            cnt_min = 0
            if max_j >= 0:
                cnt_min = pow2[right] - 1
                if right > max_j:
                    subtract = pow2[right - (max_j + 1)]
                    cnt_min = (pow2[right] - subtract) % MOD
            
            left = i
            max_j = min(k - 1, left)
            cnt_max = 0
            if max_j >= 0:
                cnt_max = pow2[left] - 1
                if left > max_j:
                    subtract = pow2[left - (max_j + 1)]
                    cnt_max = (pow2[left] - subtract) % MOD
            
            res = (res + nums[i] * (cnt_min + cnt_max)) % MOD
        
        return res
```",Y,
minimum-cost-to-make-arrays-identical,Minimum Cost to Make Arrays Identical,"```python
from typing import List

class Solution:
    def minCost(self, arr: List[int], brr: List[int], k: int) -> int:
        if arr == brr:
            return 0
        
        arr_sorted = sorted(arr)
        brr_sorted = sorted(brr)
        
        cost = 0
        for a, b in zip(arr_sorted, brr_sorted):
            cost += abs(a - b)
        
        option1 = cost
        option2 = k
        
        return min(option1, option2)
```",Y,
count-special-subsequences,Count Special Subsequences,"```python
from typing import List

class Solution:
    def numberOfSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        for p in range(n):
            for q in range(p + 2, n):
                for r in range(q + 2, n):
                    for s in range(r + 2, n):
                        if nums[p] * nums[r] == nums[q] * nums[s]:
                            count += 1
        return count
```",Y,
count-beautiful-splits-in-an-array,Count Beautiful Splits in an Array,"```python
from typing import List

class Solution:
    def beautifulSplits(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        
        for i in range(1, n):
            for j in range(i + 1, n):
                nums1 = nums[:i]
                nums2 = nums[i:j]
                nums3 = nums[j:]
                
                len1 = len(nums1)
                len2 = len(nums2)
                len3 = len(nums3)
                
                if len1 <= len2 and nums1 == nums2[:len1]:
                    count += 1
                elif len2 <= len3 and nums2 == nums3[:len2]:
                    count += 1
        
        return count
```",Y,
find-the-lexicographically-largest-string-from-the-box-i,Find the Lexicographically Largest String From the Box I,"```python
class Solution:
    def answerString(self, word: str, numFriends: int) -> str:
        if numFriends == 1:
            return word
        max_str = """"
        n = len(word)
        for i in range(1, n - numFriends + 2):
            current = word[:i]
            if current > max_str:
                max_str = current
        return max_str
```",Y,
maximum-area-rectangle-with-point-constraints-i,Maximum Area Rectangle With Point Constraints I,"```python
from typing import List

class Solution:
    def maxRectangleArea(self, points: List[List[int]]) -> int:
        point_set = set((x, y) for x, y in points)
        max_area = -1
        
        for i in range(len(points)):
            x1, y1 = points[i]
            for j in range(len(points)):
                x2, y2 = points[j]
                if x1 < x2 and y1 < y2:
                    if (x1, y2) in point_set and (x2, y1) in point_set:
                        valid = True
                        for x, y in points:
                            if x1 < x < x2 and y1 < y < y2:
                                valid = False
                                break
                        if valid:
                            area = (x2 - x1) * (y2 - y1)
                            if area > max_area:
                                max_area = area
        return max_area
```",Y,
design-task-manager,Design Task Manager,"```python
import heapq
from typing import List

class TaskManager:

    def __init__(self, tasks: List[List[int]]):
        self.task_map = {}  # Maps taskId to (priority, userId)
        self.priority_queue = []  # Max-heap based on (-priority, -taskId)
        for task in tasks:
            userId, taskId, priority = task
            self.add(userId, taskId, priority)

    def add(self, userId: int, taskId: int, priority: int) -> None:
        self.task_map[taskId] = (priority, userId)
        heapq.heappush(self.priority_queue, (-priority, -taskId))

    def edit(self, taskId: int, newPriority: int) -> None:
        old_priority, userId = self.task_map[taskId]
        self.task_map[taskId] = (newPriority, userId)
        heapq.heappush(self.priority_queue, (-newPriority, -taskId))

    def rmv(self, taskId: int) -> None:
        if taskId in self.task_map:
            del self.task_map[taskId]

    def execTop(self) -> int:
        while self.priority_queue:
            neg_priority, neg_taskId = self.priority_queue[0]
            taskId = -neg_taskId
            if taskId in self.task_map:
                current_priority, userId = self.task_map[taskId]
                if current_priority == -neg_priority:
                    heapq.heappop(self.priority_queue)
                    del self.task_map[taskId]
                    return userId
            heapq.heappop(self.priority_queue)
        return -1
```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
maximum-amount-of-money-robot-can-earn,Maximum Amount of Money Robot Can Earn,"```python
from typing import List

class Solution:
    def maximumAmount(self, coins: List[List[int]]) -> int:
        m, n = len(coins), len(coins[0])
        dp = [[[-float('inf')] * 3 for _ in range(n)] for _ in range(m)]
        
        if coins[0][0] < 0:
            dp[0][0][1] = coins[0][0]
        else:
            dp[0][0][0] = coins[0][0]
        
        for i in range(m):
            for j in range(n):
                for k in range(3):
                    if i == 0 and j == 0:
                        continue
                    current = -float('inf')
                    if i > 0:
                        current = max(current, dp[i-1][j][k])
                    if j > 0:
                        current = max(current, dp[i][j-1][k])
                    if current == -float('inf'):
                        continue
                    val = coins[i][j]
                    if val < 0:
                        if k > 0:
                            new_val = current + val
                            if dp[i][j][k] < new_val:
                                dp[i][j][k] = new_val
                        new_k = k - 1
                        if new_k >= 0:
                            new_val = current
                            if dp[i][j][new_k] < new_val:
                                dp[i][j][new_k] = new_val
                    else:
                        new_val = current + val
                        if dp[i][j][k] < new_val:
                            dp[i][j][k] = new_val
        
        return max(dp[m-1][n-1][0], dp[m-1][n-1][1], dp[m-1][n-1][2])
```",Y,
count-paths-with-the-given-xor-value,Count Paths With the Given XOR Value,"```python
class Solution:
    def countPathsWithXorValue(self, grid: List[List[int]], k: int) -> int:
        m, n = len(grid), len(grid[0])
        MOD = 10**9 + 7
        
        from collections import defaultdict
        
        dp = [[defaultdict(int) for _ in range(n)] for __ in range(m)]
        dp[0][0][grid[0][0]] = 1
        
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    continue
                current_xor = grid[i][j]
                if i > 0:
                    for xor_val, count in dp[i-1][j].items():
                        new_xor = xor_val ^ current_xor
                        dp[i][j][new_xor] = (dp[i][j][new_xor] + count) % MOD
                if j > 0:
                    for xor_val, count in dp[i][j-1].items():
                        new_xor = xor_val ^ current_xor
                        dp[i][j][new_xor] = (dp[i][j][new_xor] + count) % MOD
        
        return dp[m-1][n-1].get(k, 0) % MOD
```",Y,
check-if-grid-can-be-cut-into-sections,Check if Grid can be Cut into Sections,"```python
from typing import List

class Solution:
    def checkValidCuts(self, n: int, rectangles: List[List[int]]) -> bool:
        def check_horizontal():
            y_coords = []
            for rect in rectangles:
                y_coords.append(rect[1])
                y_coords.append(rect[3])
            y_coords = sorted(list(set(y_coords)))
            
            for i in range(len(y_coords)):
                for j in range(i + 1, len(y_coords)):
                    y1 = y_coords[i]
                    y2 = y_coords[j]
                    lower = []
                    middle = []
                    upper = []
                    for rect in rectangles:
                        starty, endy = rect[1], rect[3]
                        if endy <= y1:
                            lower.append(rect)
                        elif starty >= y2:
                            upper.append(rect)
                        else:
                            middle.append(rect)
                    if lower and middle and upper:
                        return True
            return False
        
        def check_vertical():
            x_coords = []
            for rect in rectangles:
                x_coords.append(rect[0])
                x_coords.append(rect[2])
            x_coords = sorted(list(set(x_coords)))
            
            for i in range(len(x_coords)):
                for j in range(i + 1, len(x_coords)):
                    x1 = x_coords[i]
                    x2 = x_coords[j]
                    left = []
                    middle = []
                    right = []
                    for rect in rectangles:
                        startx, endx = rect[0], rect[2]
                        if endx <= x1:
                            left.append(rect)
                        elif startx >= x2:
                            right.append(rect)
                        else:
                            middle.append(rect)
                    if left and middle and right:
                        return True
            return False
        
        return check_horizontal() or check_vertical()
```",Y,
digit-operations-to-make-two-integers-equal,Digit Operations to Make Two Integers Equal,"```python
import math

class Solution:
    def minOperations(self, n: int, m: int) -> int:
        def is_prime(num):
            if num < 2:
                return False
            for i in range(2, int(math.sqrt(num)) + 1):
                if num % i == 0:
                    return False
            return True
        
        if is_prime(m):
            return -1
        
        from collections import deque
        
        visited = set()
        queue = deque()
        queue.append((n, 0))
        visited.add(n)
        
        while queue:
            current, cost = queue.popleft()
            if current == m:
                return cost + m
            
            digits = list(map(int, str(current)))
            for i in range(len(digits)):
                original_digit = digits[i]
                if original_digit != 9:
                    new_digits = digits.copy()
                    new_digits[i] += 1
                    new_num = int(''.join(map(str, new_digits)))
                    if not is_prime(new_num) and new_num not in visited:
                        visited.add(new_num)
                        queue.append((new_num, cost + current))
                if original_digit != 0:
                    new_digits = digits.copy()
                    new_digits[i] -= 1
                    new_num = int(''.join(map(str, new_digits)))
                    if not is_prime(new_num) and new_num not in visited:
                        visited.add(new_num)
                        queue.append((new_num, cost + current))
        
        return -1
```",Y,
minimum-array-sum,Minimum Array Sum,"```python
import heapq

class Solution:
    def minArraySum(self, nums: List[int], k: int, op1: int, op2: int) -> int:
        heap = []
        for num in nums:
            heapq.heappush(heap, -num)
        
        for _ in range(op1):
            if not heap:
                break
            current = -heapq.heappop(heap)
            new_val = (current + 1) // 2
            heapq.heappush(heap, -new_val)
        
        heap2 = []
        while heap:
            val = -heapq.heappop(heap)
            if val >= k and op2 > 0:
                val -= k
                op2 -= 1
            heapq.heappush(heap2, val)
        
        return sum(heap2)
```",Y,
maximum-subarray-sum-with-length-divisible-by-k,Maximum Subarray Sum With Length Divisible by K,"```python
from typing import List

class Solution:
    def maxSubarraySum(self, nums: List[int], k: int) -> int:
        n = len(nums)
        prefix_sum = [0] * (n + 1)
        for i in range(n):
            prefix_sum[i + 1] = prefix_sum[i] + nums[i]
        
        max_sum = -float('inf')
        remainder_min = {}
        remainder_min[0] = 0  # prefix_sum[0] is 0, remainder 0
        
        for i in range(1, n + 1):
            remainder = prefix_sum[i] % k
            if remainder in remainder_min:
                current_sum = prefix_sum[i] - remainder_min[remainder]
                if current_sum > max_sum:
                    max_sum = current_sum
            if remainder not in remainder_min or prefix_sum[i] < remainder_min[remainder]:
                remainder_min[remainder] = prefix_sum[i]
        
        return max_sum
```",Y,
minimum-time-to-break-locks-i,Minimum Time to Break Locks I,"```python
import itertools

class Solution:
    def findMinimumTime(self, strength: List[int], k: int) -> int:
        n = len(strength)
        min_time = float('inf')
        
        for perm in itertools.permutations(strength):
            current_time = 0
            x = 1
            energy = 0
            for s in perm:
                t = 0
                discriminant = (2 * x - 1) ** 2 + 8 * s
                sqrt_discriminant = int(discriminant ** 0.5)
                if sqrt_discriminant * sqrt_discriminant < discriminant:
                    sqrt_discriminant += 1
                t = (- (2 * x - 1) + sqrt_discriminant) // 2
                if t * (2 * x + t - 1) // 2 < s:
                    t += 1
                
                current_time += t
                energy = t * (2 * x + t - 1) // 2
                x += k
                
            if current_time < min_time:
                min_time = current_time
        
        return min_time
```",Y,
zero-array-transformation-iii,Zero Array Transformation III,"```python
from typing import List

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        diff = [0] * (n + 2)
        
        for l, r in queries:
            diff[l] += 1
            diff[r + 1] -= 1
        
        coverage = [0] * n
        current = 0
        for i in range(n):
            current += diff[i]
            coverage[i] = current
        
        for i in range(n):
            if nums[i] > coverage[i]:
                return -1
        
        
        
        
        
        
        
        surplus = [coverage[i] - nums[i] for i in range(n)]
        
        
        size = 1
        while size < n:
            size <<= 1
        seg = [float('inf')] * (2 * size)
        
        for i in range(n):
            seg[size + i] = surplus[i]
        for i in range(size - 1, 0, -1):
            seg[i] = min(seg[2 * i], seg[2 * i + 1])
        
        def query_min(l, r):
            res = float('inf')
            l += size
            r += size
            while l < r:
                if l % 2 == 1:
                    res = min(res, seg[l])
                    l += 1
                if r % 2 == 1:
                    r -= 1
                    res = min(res, seg[r])
                l //= 2
                r //= 2
            return res
        
        removable = 0
        for l, r in queries:
            min_surplus = query_min(l, r + 1)
            if min_surplus >= 1:
                removable += 1
                pass
        
        return removable
```",Y,
zero-array-transformation-ii,Zero Array Transformation II,"```python
import bisect

class Solution:
    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        
        diff = [0] * (n + 1)
        
        left = 0
        right = m
        answer = -1
        
        while left <= right:
            mid = (left + right) // 2
            diff = [0] * (n + 1)
            
            for i in range(mid):
                l, r, val = queries[i]
                diff[l] += val
                if r + 1 < n:
                    diff[r + 1] -= val
            
            possible = True
            current = 0
            for i in range(n):
                current += diff[i]
                if current > nums[i]:
                    possible = False
                    break
            
            if possible:
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        
        return answer if answer != -1 else -1
```",Y,
zero-array-transformation-i,Zero Array Transformation I,"```python
from typing import List

class Solution:
    def isZeroArray(self, nums: List[int], queries: List[List[int]]) -> bool:
        n = len(nums)
        diff = [0] * (n + 1)
        
        for l, r in queries:
            diff[l] += 1
            if r + 1 < n:
                diff[r + 1] -= 1
        
        current = 0
        for i in range(n):
            current += diff[i]
            if current > nums[i]:
                return False
        
        return sum(nums) == sum(r - l + 1 for l, r in queries)
```",Y,
find-mirror-score-of-a-string,Find Mirror Score of a String,"```python
class Solution:
    def calculateScore(self, s: str) -> int:
        mirror_map = {
            'a': 'z', 'b': 'y', 'c': 'x', 'd': 'w', 'e': 'v', 'f': 'u',
            'g': 't', 'h': 's', 'i': 'r', 'j': 'q', 'k': 'p', 'l': 'o',
            'm': 'n', 'n': 'm', 'o': 'l', 'p': 'k', 'q': 'j', 'r': 'i',
            's': 'h', 't': 'g', 'u': 'f', 'v': 'e', 'w': 'd', 'x': 'c',
            'y': 'b', 'z': 'a'
        }
        marked = [False] * len(s)
        score = 0
        
        for i in range(len(s)):
            if marked[i]:
                continue
            target_char = mirror_map[s[i]]
            for j in range(i - 1, -1, -1):
                if not marked[j] and s[j] == target_char:
                    marked[i] = marked[j] = True
                    score += i - j
                    break
        return score
```",Y,
maximize-the-number-of-target-nodes-after-connecting-trees-i,Maximize the Number of Target Nodes After Connecting Trees I,"```python
from collections import defaultdict, deque
from typing import List

class Solution:
    def maxTargetNodes(self, edges1: List[List[int]], edges2: List[List[int]], k: int) -> List[int]:
        n = len(edges1) + 1
        m = len(edges2) + 1
        
        tree1 = defaultdict(list)
        for a, b in edges1:
            tree1[a].append(b)
            tree1[b].append(a)
        
        tree2 = defaultdict(list)
        for u, v in edges2:
            tree2[u].append(v)
            tree2[v].append(u)
        
        dist_tree2 = [[0] * m for _ in range(m)]
        for u in range(m):
            visited = [False] * m
            q = deque([(u, 0)])
            visited[u] = True
            while q:
                node, d = q.popleft()
                dist_tree2[u][node] = d
                for neighbor in tree2[node]:
                    if not visited[neighbor]:
                        visited[neighbor] = True
                        q.append((neighbor, d + 1))
        
        dist_tree1 = [[0] * n for _ in range(n)]
        for u in range(n):
            visited = [False] * n
            q = deque([(u, 0)])
            visited[u] = True
            while q:
                node, d = q.popleft()
                dist_tree1[u][node] = d
                for neighbor in tree1[node]:
                    if not visited[neighbor]:
                        visited[neighbor] = True
                        q.append((neighbor, d + 1))
        
        answer = []
        for i in range(n):
            max_target = 0
            for j in range(m):
                count1 = sum(1 for x in range(n) if dist_tree1[i][x] <= k)
                count2 = sum(1 for y in range(m) if dist_tree2[j][y] + 1 <= k)
                total = count1 + count2
                if total > max_target:
                    max_target = total
            answer.append(max_target)
        
        return answer
```",Y,
total-characters-in-string-after-transformations-i,Total Characters in String After Transformations I,"```python
class Solution:
    def lengthAfterTransformations(self, s: str, t: int) -> int:
        MOD = 10**9 + 7
        count = [0] * 26
        for c in s:
            count[ord(c) - ord('a')] += 1
        
        for _ in range(t):
            new_count = [0] * 26
            for i in range(25):
                new_count[i + 1] += count[i]
                new_count[i + 1] %= MOD
            new_count[0] += count[25]
            new_count[1] += count[25]
            new_count[0] %= MOD
            new_count[1] %= MOD
            count = new_count
        
        return sum(count) % MOD
```",Y,
find-minimum-time-to-reach-last-room-ii,Find Minimum Time to Reach Last Room II,"```python
import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0]) if n > 0 else 0
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        heap = []
        heapq.heappush(heap, (moveTime[0][0], 0, 0, 0))
        
        visited = {}
        visited[(0, 0, 0)] = moveTime[0][0]
        
        while heap:
            current_time, x, y, parity = heapq.heappop(heap)
            if x == n - 1 and y == m - 1:
                return current_time
            if current_time > visited.get((x, y, parity), float('inf')):
                continue
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    move_cost = 1 if parity == 0 else 2
                    new_time = max(current_time, moveTime[nx][ny]) + move_cost
                    new_parity = 1 - parity
                    key = (nx, ny, new_parity)
                    if new_time < visited.get(key, float('inf')):
                        visited[key] = new_time
                        heapq.heappush(heap, (new_time, nx, ny, new_parity))
        return -1
```",Y,
find-minimum-time-to-reach-last-room-i,Find Minimum Time to Reach Last Room I,"```python
import heapq
from typing import List

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0]) if n > 0 else 0
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        heap = []
        heapq.heappush(heap, (0, 0, 0))
        visited = [[False for _ in range(m)] for _ in range(n)]
        
        while heap:
            current_time, i, j = heapq.heappop(heap)
            if i == n - 1 and j == m - 1:
                return current_time
            if visited[i][j]:
                continue
            visited[i][j] = True
            
            for di, dj in directions:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m and not visited[ni][nj]:
                    new_time = max(current_time + 1, moveTime[ni][nj])
                    heapq.heappush(heap, (new_time, ni, nj))
        
        return -1
```",Y,
maximum-frequency-of-an-element-after-performing-operations-i,Maximum Frequency of an Element After Performing Operations I,"```python
from typing import List

class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        nums.sort()
        left = 0
        max_freq = 0
        total = 0
        
        for right in range(len(nums)):
            total += nums[right]
            
            while nums[right] * (right - left + 1) > total + k * min(numOperations, right - left + 1):
                total -= nums[left]
                left += 1
            
            current_window = right - left + 1
            if current_window <= numOperations or numOperations == 0:
                max_freq = max(max_freq, current_window)
            else:
                max_freq = max(max_freq, numOperations + 1)
        
        return max_freq
```",Y,
maximum-number-of-distinct-elements-after-operations,Maximum Number of Distinct Elements After Operations,"```python
from typing import List

class Solution:
    def maxDistinctElements(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        res = 1
        prev = nums[0] - k - 1  # Initialize to ensure first element is considered
        
        for i in range(n):
            current = nums[i]
            optimal = max(prev + 1, current - k)
            if optimal <= current + k:
                res += 1
                prev = optimal
            else:
                pass
        return res - 1  # Subtract 1 because we started counting from 1
```",Y,
adjacent-increasing-subarrays-detection-ii,Adjacent Increasing Subarrays Detection II,"```python
from typing import List

class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return 0
        
        lengths = [1] * n
        for i in range(n-2, -1, -1):
            if nums[i] < nums[i+1]:
                lengths[i] = lengths[i+1] + 1
        
        max_k = 0
        i = 0
        while i < n:
            current_len = lengths[i]
            next_start = i + current_len
            if next_start < n and lengths[next_start] >= current_len:
                max_k = max(max_k, current_len)
                i = next_start
            else:
                if current_len > 1:
                    potential_k = current_len - 1
                    if next_start - 1 < n and lengths[next_start - 1] >= potential_k:
                        max_k = max(max_k, potential_k)
                i += 1
        return max_k
```",Y,
maximize-amount-after-two-days-of-conversions,Maximize Amount After Two Days of Conversions,"```python
from typing import List
from collections import defaultdict

class Solution:
    def maxAmount(self, initialCurrency: str, pairs1: List[List[str]], rates1: List[float], pairs2: List[List[str]], rates2: List[float]) -> float:
        def build_graph(pairs, rates):
            graph = defaultdict(dict)
            for (u, v), rate in zip(pairs, rates):
                graph[u][v] = rate
                graph[v][u] = 1.0 / rate
            return graph
        
        def find_max_conversion(graph, start_currency):
            max_amounts = defaultdict(float)
            max_amounts[start_currency] = 1.0
            queue = [start_currency]
            
            while queue:
                current_currency = queue.pop(0)
                current_amount = max_amounts[current_currency]
                for neighbor, rate in graph[current_currency].items():
                    new_amount = current_amount * rate
                    if new_amount > max_amounts[neighbor]:
                        max_amounts[neighbor] = new_amount
                        queue.append(neighbor)
            return max_amounts
        
        graph1 = build_graph(pairs1, rates1)
        day1_amounts = find_max_conversion(graph1, initialCurrency)
        
        max_final_amount = 1.0
        
        for currency, amount in day1_amounts.items():
            graph2 = build_graph(pairs2, rates2)
            day2_amounts = find_max_conversion(graph2, currency)
            if initialCurrency in day2_amounts:
                final_amount = amount * day2_amounts[initialCurrency]
                if final_amount > max_final_amount:
                    max_final_amount = final_amount
        
        return max_final_amount
```",Y,
construct-the-minimum-bitwise-array-ii,Construct the Minimum Bitwise Array II,"```python
from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            found = -1
            for candidate in range(num):
                if (candidate | (candidate + 1)) == num:
                    found = candidate
                    break
            ans.append(found)
        return ans
```",Y,
minimum-division-operations-to-make-array-non-decreasing,Minimum Division Operations to Make Array Non Decreasing,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return 0
        
        operations = 0
        prev = nums[-1]
        
        for i in range(len(nums) - 2, -1, -1):
            current = nums[i]
            if current > prev:
                if prev == 0:
                    return -1
                target = (current + prev - 1) // prev  # Equivalent to ceiling(current / prev)
                if target > current:
                    return -1
                
                k = target
                while k <= current:
                    if current % k == 0:
                        break
                    k += 1
                if k > current:
                    return -1
                new_val = current // k
                operations += 1
                prev = new_val
            else:
                prev = current
        
        return operations
```",Y,
rearrange-k-substrings-to-form-target-string,Rearrange K Substrings to Form Target String,"```python
class Solution:
    def isPossibleToRearrange(self, s: str, t: str, k: int) -> bool:
        n = len(s)
        if n % k != 0:
            return False
        
        substring_length = n // k
        s_substrings = [s[i*substring_length : (i+1)*substring_length] for i in range(k)]
        t_substrings = [t[i*substring_length : (i+1)*substring_length] for i in range(k)]
        
        from collections import defaultdict
        s_counts = defaultdict(int)
        t_counts = defaultdict(int)
        
        for sub in s_substrings:
            s_counts[sub] += 1
        for sub in t_substrings:
            t_counts[sub] += 1
            
        return s_counts == t_counts
```",Y,
identify-the-largest-outlier-in-an-array,Identify the Largest Outlier in an Array,"```python
from typing import List

class Solution:
    def getLargestOutlier(self, nums: List[int]) -> int:
        nums_sorted = sorted(nums)
        n = len(nums_sorted)
        
        sum_rest = sum(nums_sorted[:-1])
        if sum_rest - nums_sorted[-2] == nums_sorted[-2]:
            return nums_sorted[-1]
        
        sum_rest = sum(nums_sorted[1:])
        if sum_rest - nums_sorted[1] == nums_sorted[1]:
            return nums_sorted[0]
        
        return max(nums_sorted[0], nums_sorted[-1])
```",Y,
find-the-maximum-factor-score-of-array,Find the Maximum Factor Score of Array,"```python
import math
from typing import List

class Solution:
    def maxScore(self, nums: List[int]) -> int:
        if not nums:
            return 0
        max_score = 0
        n = len(nums)
        for i in range(-1, n):
            current_nums = nums[:i] + nums[i+1:] if i != -1 else nums
            if not current_nums:
                continue
            current_gcd = current_nums[0]
            current_lcm = current_nums[0]
            for num in current_nums[1:]:
                current_gcd = math.gcd(current_gcd, num)
                current_lcm = (current_lcm * num) // math.gcd(current_lcm, num)
            score = current_gcd * current_lcm
            if score > max_score:
                max_score = score
        return max_score
```",Y,
shift-distance-between-two-strings,Shift Distance Between Two Strings,"```python
from typing import List

class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        total_cost = 0
        for sc, tc in zip(s, t):
            if sc == tc:
                continue
            sc_ord = ord(sc) - ord('a')
            tc_ord = ord(tc) - ord('a')
            
            forward_shifts = (tc_ord - sc_ord) % 26
            backward_shifts = (sc_ord - tc_ord) % 26
            
            forward_cost = 0
            current = sc_ord
            for _ in range(forward_shifts):
                forward_cost += nextCost[current]
                current = (current + 1) % 26
            
            backward_cost = 0
            current = sc_ord
            for _ in range(backward_shifts):
                backward_cost += previousCost[current]
                current = (current - 1) % 26
            
            total_cost += min(forward_cost, backward_cost)
        
        return total_cost
```",Y,
maximum-points-tourist-can-earn,Maximum Points Tourist Can Earn,"```python
from typing import List

class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp_prev = [0] * n
        
        for day in range(k):
            dp_current = [0] * n
            for curr in range(n):
                max_stay = dp_prev[curr] + stayScore[day][curr]
                max_travel = 0
                for dest in range(n):
                    if dest != curr:
                        current_travel = dp_prev[dest] + travelScore[dest][curr]
                        if current_travel > max_travel:
                            max_travel = current_travel
                dp_current[curr] = max(max_stay, max_travel)
            dp_prev = dp_current
        
        return max(dp_prev)
```",Y,
find-the-lexicographically-smallest-valid-sequence,Find the Lexicographically Smallest Valid Sequence,"```python
from typing import List

class Solution:
    def validSequence(self, word1: str, word2: str) -> List[int]:
        n1, n2 = len(word1), len(word2)
        if n1 < n2:
            return []
        
        result = []
        mismatch_used = False
        i = 0  # pointer for word1
        j = 0  # pointer for word2
        
        while j < n2 and i < n1:
            if word1[i] == word2[j]:
                result.append(i)
                i += 1
                j += 1
            else:
                if not mismatch_used:
                    result.append(i)
                    i += 1
                    j += 1
                    mismatch_used = True
                else:
                    i += 1
        
        if j < n2:
            return []
        
        if mismatch_used:
            result = []
            mismatch_pos = -1
            i = 0
            j = 0
            while j < n2:
                if i >= n1:
                    return []
                if word1[i] == word2[j]:
                    result.append(i)
                    i += 1
                    j += 1
                else:
                    if mismatch_pos == -1:
                        mismatch_pos = j
                        result.append(i)
                        i += 1
                        j += 1
                    else:
                        i += 1
            if j < n2:
                return []
            
            
            
            
            
            min_result = None
            for possible_mismatch in range(n2):
                temp_result = []
                i = 0
                j = 0
                used = False
                valid = True
                while j < n2:
                    if i >= n1:
                        valid = False
                        break
                    if j == possible_mismatch:
                        temp_result.append(i)
                        i += 1
                        j += 1
                        used = True
                    else:
                        if word1[i] == word2[j]:
                            temp_result.append(i)
                            i += 1
                            j += 1
                        else:
                            if not used:
                                temp_result.append(i)
                                i += 1
                                j += 1
                                used = True
                            else:
                                i += 1
                if valid and j == n2:
                    if min_result is None or temp_result < min_result:
                        min_result = temp_result.copy()
            if min_result is not None:
                return min_result
            else:
                return []
        else:
            return list(range(n2))
```",Y,
maximum-possible-number-by-binary-concatenation,Maximum Possible Number by Binary Concatenation,"```python
from typing import List

class Solution:
    def maxGoodNumber(self, nums: List[int]) -> int:
        max_num = 0
        from itertools import permutations
        
        for perm in permutations(nums):
            binary_str = ''
            for num in perm:
                binary_str += bin(num)[2:]
            current_num = int(binary_str, 2)
            if current_num > max_num:
                max_num = current_num
        return max_num
```",Y,
find-subtree-sizes-after-changes,Find Subtree Sizes After Changes,"```python
from typing import List

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)
        
        new_parent = parent.copy()
        for x in range(1, n):
            current = parent[x]
            found = None
            while current != -1:
                if s[current] == s[x]:
                    found = current
                    break
                current = parent[current]
            if found is not None:
                new_parent[x] = found
        
        new_children = [[] for _ in range(n)]
        for i in range(1, n):
            new_children[new_parent[i]].append(i)
        
        sizes = [1] * n
        stack = [(0, False)]
        while stack:
            node, processed = stack.pop()
            if not processed:
                stack.append((node, True))
                for child in reversed(new_children[node]):
                    stack.append((child, False))
            else:
                for child in new_children[node]:
                    sizes[node] += sizes[child]
        
        return sizes
```",Y,
count-substrings-that-can-be-rearranged-to-contain-a-string-i,Count Substrings That Can Be Rearranged to Contain a String I,"```python
from collections import defaultdict

class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        len_word2 = len(word2)
        if len(word1) < len_word2:
            return 0
        
        word2_freq = defaultdict(int)
        for c in word2:
            word2_freq[c] += 1
        
        window_freq = defaultdict(int)
        left = 0
        valid_count = 0
        
        for right in range(len(word1)):
            window_freq[word1[right]] += 1
            
            if right - left + 1 >= len_word2:
                valid = True
                for c in word2_freq:
                    if window_freq[c] < word2_freq[c]:
                        valid = False
                        break
                if valid:
                    valid_count += 1
                
                window_freq[word1[left]] -= 1
                if window_freq[word1[left]] == 0:
                    del window_freq[word1[left]]
                left += 1
        
        
        
        
        
        
        
        len1 = len(word1)
        len2 = len(word2)
        if len1 < len2:
            return 0
        
        word2_counts = [0] * 26
        for c in word2:
            word2_counts[ord(c) - ord('a')] += 1
        
        total = 0
        left = 0
        current_counts = [0] * 26
        
        for right in range(len1):
            current_counts[ord(word1[right]) - ord('a')] += 1
            
            while right - left + 1 > len2:
                current_counts[ord(word1[left]) - ord('a')] -= 1
                left += 1
            
            if right - left + 1 == len2:
                valid = True
                for i in range(26):
                    if current_counts[i] < word2_counts[i]:
                        valid = False
                        break
                if valid:
                    total += (left + 1) * (len1 - right)
                    left = right + 1
                    current_counts = [0] * 26
        
        return total
```",Y,
count-of-substrings-containing-every-vowel-and-k-consonants-i,Count of Substrings Containing Every Vowel and K Consonants I,"```python
class Solution:
    def countOfSubstrings(self, word: str, k: int) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        n = len(word)
        count = 0
        
        for i in range(n):
            vowel_set = set()
            consonant_count = 0
            for j in range(i, n):
                char = word[j]
                if char in vowels:
                    vowel_set.add(char)
                else:
                    consonant_count += 1
                
                if consonant_count == k and len(vowel_set) == 5:
                    count += 1
                elif consonant_count > k:
                    break
        return count
```",Y,
count-of-substrings-containing-every-vowel-and-k-consonants-ii,Count of Substrings Containing Every Vowel and K Consonants II,"```python
class Solution:
    def countOfSubstrings(self, word: str, k: int) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        n = len(word)
        res = 0
        
        for i in range(n):
            vowel_count = 0
            consonant_count = 0
            seen_vowels = set()
            for j in range(i, n):
                c = word[j]
                if c in vowels:
                    if c not in seen_vowels:
                        seen_vowels.add(c)
                        vowel_count += 1
                else:
                    consonant_count += 1
                
                if consonant_count > k:
                    break
                
                if vowel_count == 5 and consonant_count == k:
                    res += 1
        
        return res
```",Y,
find-the-sequence-of-strings-appeared-on-the-screen,Find the Sequence of Strings Appeared on the Screen,"```python
from typing import List

class Solution:
    def stringSequence(self, target: str) -> List[str]:
        if not target:
            return []
        
        result = []
        current = []
        
        for i in range(len(target)):
            c = target[i]
            if i == 0:
                steps = ord(c) - ord('a')
                for _ in range(steps + 1):
                    if not current:
                        current.append('a')
                    else:
                        current[-1] = chr(ord(current[-1]) + 1)
                        if current[-1] > 'z':
                            current[-1] = 'a'
                    result.append(''.join(current))
            else:
                if not current:
                    current.append('a')
                    result.append(''.join(current))
                
                current.append('a')
                result.append(''.join(current))
                
                steps = (ord(c) - ord('a')) % 26
                for _ in range(steps):
                    current[-1] = chr(ord(current[-1]) + 1)
                    if current[-1] > 'z':
                        current[-1] = 'a'
                    result.append(''.join(current))
        
        return result
```",Y,
remove-methods-from-project,Remove Methods From Project,"```python
from typing import List
from collections import defaultdict, deque

class Solution:
    def remainingMethods(self, n: int, k: int, invocations: List[List[int]]) -> List[int]:
        graph = defaultdict(set)
        reverse_graph = defaultdict(set)
        for a, b in invocations:
            graph[a].add(b)
            reverse_graph[b].add(a)
        
        suspicious = set()
        queue = deque([k])
        while queue:
            current = queue.popleft()
            if current in suspicious:
                continue
            suspicious.add(current)
            for neighbor in graph.get(current, set()):
                if neighbor not in suspicious:
                    queue.append(neighbor)
        
        can_remove = True
        for method in suspicious:
            for caller in reverse_graph.get(method, set()):
                if caller not in suspicious:
                    can_remove = False
                    break
            if not can_remove:
                break
        
        if not can_remove:
            return list(range(n))
        else:
            remaining = [m for m in range(n) if m not in suspicious]
            return remaining
```",Y,
minimum-number-of-valid-strings-to-form-target-i,Minimum Number of Valid Strings to Form Target I,"```python
class Solution:
    def minValidStrings(self, words: List[str], target: str) -> int:
        prefixes = set()
        for word in words:
            for i in range(1, len(word)+1):
                prefixes.add(word[:i])
        
        n = len(target)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        
        for i in range(1, n+1):
            for l in range(1, i+1):
                if target[i-l:i] in prefixes and dp[i-l] != float('inf'):
                    dp[i] = min(dp[i], dp[i-l] + 1)
        
        return dp[n] if dp[n] != float('inf') else -1
```",Y,
find-a-safe-walk-through-a-grid,Find a Safe Walk Through a Grid,"```python
from typing import List
import heapq

class Solution:
    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:
        m, n = len(grid), len(grid[0])
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        heap = []
        max_health = [[-1 for _ in range(n)] for _ in range(m)]
        
        initial_health = health - grid[0][0]
        if initial_health <= 0:
            return False
        
        heapq.heappush(heap, (-initial_health, 0, 0))
        max_health[0][0] = initial_health
        
        while heap:
            neg_health, x, y = heapq.heappop(heap)
            current_health = -neg_health
            
            if x == m - 1 and y == n - 1:
                return True
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n:
                    new_health = current_health - grid[nx][ny]
                    if new_health > max_health[nx][ny] and new_health > 0:
                        max_health[nx][ny] = new_health
                        heapq.heappush(heap, (-new_health, nx, ny))
        
        return False
```",Y,
report-spam-message,Report Spam Message,"```python
class Solution:
    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:
        banned_set = set(bannedWords)
        count = 0
        for word in message:
            if word in banned_set:
                count += 1
                if count >= 2:
                    return True
        return False
```",Y,
hash-divided-string,Hash Divided String,"```python
class Solution:
    def stringHash(self, s: str, k: int) -> str:
        result = []
        n = len(s)
        for i in range(0, n, k):
            substring = s[i:i+k]
            total = sum(ord(c) - ord('a') for c in substring)
            hashed_char = chr(ord('a') + (total % 26))
            result.append(hashed_char)
        return ''.join(result)
```",Y,
count-almost-equal-pairs-i,Count Almost Equal Pairs I,"```python
from typing import List

class Solution:
    def countPairs(self, nums: List[int]) -> int:
        def is_almost_equal(x, y):
            s1 = str(x)
            s2 = str(y)
            if len(s1) != len(s2):
                return False
            diff = []
            for a, b in zip(s1, s2):
                if a != b:
                    diff.append((a, b))
                if len(diff) > 2:
                    return False
            if not diff:
                return True
            if len(diff) == 2:
                (a1, b1), (a2, b2) = diff
                return a1 == b2 and a2 == b1
            return False
        
        count = 0
        n = len(nums)
        for i in range(n):
            for j in range(i + 1, n):
                if is_almost_equal(nums[i], nums[j]):
                    count += 1
        return count
```",Y,
reach-end-of-array-with-max-score,Reach End of Array With Max Score,"```python
from typing import List

class Solution:
    def findMaximumScore(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [0] * n
        max_score = [0] * n
        max_score[-1] = nums[-1]
        
        for i in range(n - 2, -1, -1):
            max_score[i] = max(max_score[i + 1], nums[i])
        
        dp[0] = nums[0] * (n - 1)
        
        for i in range(1, n):
            dp[i] = max(dp[i - 1], nums[i] * (n - 1 - i))
        
        res = 0
        for i in range(n - 1):
            res = max(res, nums[i] * (n - 1 - i) + dp[i])
        
        return res
```",Y,
minimum-number-of-flips-to-make-binary-grid-palindromic-i,Minimum Number of Flips to Make Binary Grid Palindromic I,"```python
from typing import List

class Solution:
    def minFlips(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        
        def calculate_row_flips():
            flips = 0
            for row in grid:
                left, right = 0, n - 1
                while left < right:
                    if row[left] != row[right]:
                        flips += 1
                    left += 1
                    right -= 1
            return flips
        
        def calculate_col_flips():
            flips = 0
            for j in range(n):
                top, bottom = 0, m - 1
                while top < bottom:
                    if grid[top][j] != grid[bottom][j]:
                        flips += 1
                    top += 1
                    bottom -= 1
            return flips
        
        if m == 0 or n == 0:
            return 0
        
        row_flips = calculate_row_flips()
        col_flips = calculate_col_flips()
        
        return min(row_flips, col_flips)
```",Y,
maximum-energy-boost-from-two-drinks,Maximum Energy Boost From Two Drinks,"```python
from typing import List

class Solution:
    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:
        n = len(energyDrinkA)
        if n == 0:
            return 0
        
        dpA = [0] * n
        dpB = [0] * n
        
        dpA[0] = energyDrinkA[0]
        dpB[0] = energyDrinkB[0]
        
        for i in range(1, n):
            dpA[i] = max(dpA[i-1] + energyDrinkA[i], (dpB[i-2] + energyDrinkA[i] if i >= 2 else energyDrinkA[i]))
            dpB[i] = max(dpB[i-1] + energyDrinkB[i], (dpA[i-2] + energyDrinkB[i] if i >= 2 else energyDrinkB[i]))
        
        return max(dpA[-1], dpB[-1])
```",Y,
minimum-number-of-flips-to-make-binary-grid-palindromic-ii,Minimum Number of Flips to Make Binary Grid Palindromic II,"```python
from typing import List

class Solution:
    def minFlips(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        
        total_ones = sum(sum(row) for row in grid)
        if total_ones % 4 != 0:
            rem = total_ones % 4
            adjustment_needed = min(rem, 4 - rem)
        else:
            adjustment_needed = 0
        
        flips = 0
        
        for i in range(m):
            left = 0
            right = n - 1
            while left < right:
                if grid[i][left] != grid[i][right]:
                    flips += 1
                left += 1
                right -= 1
        
        for j in range(n):
            top = 0
            bottom = m - 1
            while top < bottom:
                if grid[top][j] != grid[bottom][j]:
                    flips += 1
                top += 1
                bottom -= 1
        
        return flips + adjustment_needed
```",Y,
find-the-power-of-k-size-subarrays-ii,Find the Power of K-Size Subarrays II,"```python
from typing import List

class Solution:
    def resultsArray(self, nums: List[int], k: int) -> List[int]:
        results = []
        n = len(nums)
        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            max_val = max(subarray)
            min_val = min(subarray)
            if max_val - min_val == k - 1 and sorted(subarray) == subarray:
                results.append(max_val)
            else:
                results.append(-1)
        return results
```",Y,
find-the-power-of-k-size-subarrays-i,Find the Power of K-Size Subarrays I,"```python
from typing import List

class Solution:
    def resultsArray(self, nums: List[int], k: int) -> List[int]:
        results = []
        n = len(nums)
        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            sorted_sub = sorted(subarray)
            if sorted_sub == list(range(sorted_sub[0], sorted_sub[0] + k)):
                results.append(max(subarray))
            else:
                results.append(-1)
        return results
```",Y,
maximum-multiplication-score,Maximum Multiplication Score,"```python
from typing import List

class Solution:
    def maxScore(self, a: List[int], b: List[int]) -> int:
        n = len(b)
        
        dp0 = [0] * n
        dp1 = [0] * n
        dp2 = [0] * n
        dp3 = [0] * n
        
        for i in range(n):
            dp0[i] = a[0] * b[i]
        
        max_dp0 = -float('inf')
        for i in range(1, n):
            if dp0[i-1] > max_dp0:
                max_dp0 = dp0[i-1]
            dp1[i] = max_dp0 + a[1] * b[i]
        
        max_dp1 = -float('inf')
        for i in range(2, n):
            if dp1[i-1] > max_dp1:
                max_dp1 = dp1[i-1]
            dp2[i] = max_dp1 + a[2] * b[i]
        
        max_dp2 = -float('inf')
        for i in range(3, n):
            if dp2[i-1] > max_dp2:
                max_dp2 = dp2[i-1]
            dp3[i] = max_dp2 + a[3] * b[i]
        
        if n < 4:
            return 0
        return max(dp3[3:])
```",Y,
shortest-distance-after-road-addition-queries-i,Shortest Distance After Road Addition Queries I,"```python
from typing import List
import heapq

class Solution:
    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        graph = [[] for _ in range(n)]
        for i in range(n - 1):
            graph[i].append((i + 1, 1))
        
        answer = []
        current_min = n - 1  # initial path 0 -> 1 -> ... -> n-1
        
        for u, v in queries:
            graph[u].append((v, 1))
            if u == 0 and v == n - 1:
                current_min = 1
            elif u == 0:
                potential = 1 + (n - 1 - v)
                if potential < current_min:
                    current_min = potential
            elif v == n - 1:
                potential = u + 1
                if potential < current_min:
                    current_min = potential
            else:
                potential = u + 1 + (n - 1 - v)
                if potential < current_min:
                    current_min = potential
            answer.append(current_min)
        
        return answer
```",Y,
maximize-the-total-height-of-unique-towers,Maximize the Total Height of Unique Towers,"```python
class Solution:
    def maximumTotalSum(self, maximumHeight: List[int]) -> int:
        maximumHeight.sort()
        total = 0
        prev = 0
        for h in maximumHeight:
            current = max(prev + 1, h)
            if current > h:
                return -1
            total += current
            prev = current
        return total
```",Y,
k-th-largest-perfect-subtree-size-in-binary-tree,K-th Largest Perfect Subtree Size in Binary Tree,"```python
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfect_sizes = []
        
        def dfs(node):
            if not node:
                return (0, 0)  # (depth, size)
            
            left_depth, left_size = dfs(node.left)
            right_depth, right_size = dfs(node.right)
            
            current_depth = min(left_depth, right_depth) + 1 if (node.left and node.right) else 1
            current_size = (1 << current_depth) - 1  # 2^depth - 1
            
            if node.left and node.right and left_depth == right_depth:
                perfect_sizes.append(current_size)
            else:
                if node.left:
                    perfect_sizes.append(left_size)
                if node.right:
                    perfect_sizes.append(right_size)
                if not node.left and not node.right:
                    perfect_sizes.append(1)
            
            return (current_depth, current_size)
        
        dfs(root)
        perfect_sizes = sorted([size for size in perfect_sizes if size >= 1], reverse=True)
        
        if k > len(perfect_sizes):
            return -1
        return perfect_sizes[k-1]
```",Y,
find-the-count-of-numbers-which-are-not-special,Find the Count of Numbers Which Are Not Special,"```python
import math

class Solution:
    def nonSpecialCount(self, l: int, r: int) -> int:
        def is_prime(n):
            if n < 2:
                return False
            for p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]:
                if n % p == 0:
                    return n == p
            d = n - 1
            s = 0
            while d % 2 == 0:
                d //= 2
                s += 1
            for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
                if a >= n:
                    continue
                x = pow(a, d, n)
                if x == 1 or x == n - 1:
                    continue
                for _ in range(s - 1):
                    x = pow(x, 2, n)
                    if x == n - 1:
                        break
                else:
                    return False
            return True

        def count_special_numbers(l, r):
            count = 0
            max_p = int(math.isqrt(r)) + 2
            primes = []
            for p in range(2, max_p + 1):
                if is_prime(p):
                    primes.append(p)
            for p in primes:
                square = p * p
                if l <= square <= r:
                    count += 1
            return count

        special = count_special_numbers(l, r)
        return (r - l + 1) - special
```",Y,
count-substrings-with-k-frequency-characters-i,Count Substrings With K-Frequency Characters I,"```python
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        count = 0
        n = len(s)
        for i in range(n):
            freq = [0] * 26
            for j in range(i, n):
                freq[ord(s[j]) - ord('a')] += 1
                if any(f >= k for f in freq):
                    count += 1
        return count
```",Y,
delete-nodes-from-linked-list-present-in-array,Delete Nodes From Linked List Present in Array,"```python
class Solution:
    def modifiedList(self, nums: List[int], head: Optional[ListNode]) -> Optional[ListNode]:
        nums_set = set(nums)
        dummy = ListNode(0)
        dummy.next = head
        prev = dummy
        current = head
        
        while current:
            if current.val in nums_set:
                prev.next = current.next
            else:
                prev = current
            current = current.next
        
        return dummy.next
```",Y,
minimum-array-changes-to-make-differences-equal,Minimum Array Changes to Make Differences Equal,"```python
from typing import List
from collections import defaultdict

class Solution:
    def minChanges(self, nums: List[int], k: int) -> int:
        n = len(nums)
        freq = [defaultdict(int) for _ in range(k)]
        for i in range(n):
            pos = i % k
            freq[pos][nums[i]] += 1
        
        dp_prev = defaultdict(lambda: float('inf'))
        for x in range(0, k + 1):
            total = 0
            for pos in range(k):
                total += (n // k) - freq[pos].get(x, 0)
            dp_prev[x] = total
        
        for i in range(1, k):
            dp_curr = defaultdict(lambda: float('inf'))
            max_prev = min(dp_prev.values())
            for x in range(0, 2 * k + 1):
                min_changes = max_prev
                for y in dp_prev:
                    if (x - y) % k == i % k:
                        min_changes = min(min_changes, dp_prev[y] - ((n // k + (1 if i < n % k else 0)) - freq[i].get(x, 0)))
                dp_curr[x] = min_changes + ((n // k + (1 if i < n % k else 0)) - freq[i].get(x, 0))
            dp_prev = dp_curr
        
        return min(dp_prev.values())
```",Y,
minimum-number-of-seconds-to-make-mountain-height-zero,Minimum Number of Seconds to Make Mountain Height Zero,"```python
from typing import List

class Solution:
    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:
        left = 1
        right = mountainHeight * (mountainHeight + 1) // 2 * max(workerTimes) if workerTimes else 0
        
        def can_reduce(t):
            total = 0
            for time in workerTimes:
                low = 0
                high = mountainHeight
                best = 0
                while low <= high:
                    mid = (low + high) // 2
                    s = time * mid * (mid + 1) // 2
                    if s <= t:
                        best = mid
                        low = mid + 1
                    else:
                        high = mid - 1
                total += best
                if total >= mountainHeight:
                    return True
            return total >= mountainHeight
        
        answer = right
        while left <= right:
            mid = (left + right) // 2
            if can_reduce(mid):
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        return answer
```",Y,
k-th-nearest-obstacle-queries,K-th Nearest Obstacle Queries,"```python
import bisect

class Solution:
    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:
        distances = []
        results = []
        for x, y in queries:
            distance = abs(x) + abs(y)
            bisect.insort(distances, distance)
            if len(distances) >= k:
                results.append(distances[k-1])
            else:
                results.append(-1)
        return results
```",Y,
minimum-cost-for-cutting-cake-i,Minimum Cost for Cutting Cake I,"```python
from typing import List

class Solution:
    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:
        horizontalCut.sort(reverse=True)
        verticalCut.sort(reverse=True)
        h_pieces = 1
        v_pieces = 1
        total_cost = 0
        i = j = 0
        while i < len(horizontalCut) and j < len(verticalCut):
            if horizontalCut[i] > verticalCut[j]:
                total_cost += horizontalCut[i] * v_pieces
                h_pieces += 1
                i += 1
            else:
                total_cost += verticalCut[j] * h_pieces
                v_pieces += 1
                j += 1
        while i < len(horizontalCut):
            total_cost += horizontalCut[i] * v_pieces
            h_pieces += 1
            i += 1
        while j < len(verticalCut):
            total_cost += verticalCut[j] * h_pieces
            v_pieces += 1
            j += 1
        return total_cost
```",Y,
maximum-number-of-operations-to-move-ones-to-the-end,Maximum Number of Operations to Move Ones to the End,"```python
class Solution:
    def maxOperations(self, s: str) -> int:
        res = 0
        ones = 0
        for c in s:
            if c == '1':
                ones += 1
            else:
                res += ones
        return res
```",Y,
count-submatrices-with-equal-frequency-of-x-and-y,Count Submatrices With Equal Frequency of X and Y,"```python
class Solution:
    def numberOfSubmatrices(self, grid: List[List[str]]) -> int:
        rows = len(grid)
        cols = len(grid[0]) if rows > 0 else 0
        count = 0
        
        prefix_x = [[0] * (cols + 1) for _ in range(rows + 1)]
        prefix_y = [[0] * (cols + 1) for _ in range(rows + 1)]
        
        for i in range(1, rows + 1):
            for j in range(1, cols + 1):
                prefix_x[i][j] = prefix_x[i-1][j] + prefix_x[i][j-1] - prefix_x[i-1][j-1] + (1 if grid[i-1][j-1] == 'X' else 0)
                prefix_y[i][j] = prefix_y[i-1][j] + prefix_y[i][j-1] - prefix_y[i-1][j-1] + (1 if grid[i-1][j-1] == 'Y' else 0)
        
        for i1 in range(rows):
            for j1 in range(cols):
                for i2 in range(i1, rows):
                    for j2 in range(j1, cols):
                        x = prefix_x[i2+1][j2+1] - prefix_x[i1][j2+1] - prefix_x[i2+1][j1] + prefix_x[i1][j1]
                        y = prefix_y[i2+1][j2+1] - prefix_y[i1][j2+1] - prefix_y[i2+1][j1] + prefix_y[i1][j1]
                        if x == y and x > 0:
                            count += 1
        return count
```",Y,
find-the-maximum-length-of-valid-subsequence-ii,Find the Maximum Length of Valid Subsequence II,"```python
from typing import List

class Solution:
    def maximumLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if n == 0:
            return 0
        
        dp = [1] * n
        max_len = 1
        
        for i in range(1, n):
            for j in range(i):
                if (nums[j] + nums[i]) % k == (nums[i-1] + nums[i]) % k if i > 1 else True:
                    if dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
            if dp[i] > max_len:
                max_len = dp[i]
        
        return max_len
```",Y,
find-the-maximum-length-of-valid-subsequence-i,Find the Maximum Length of Valid Subsequence I,"```python
from typing import List

class Solution:
    def maximumLength(self, nums: List[int]) -> int:
        if len(nums) < 2:
            return len(nums)
        
        
        even_count = 0
        odd_count = 0
        
        for num in nums:
            if num % 2 == 0:
                even_count += 1
            else:
                odd_count += 1
        
        if even_count == 0 or odd_count == 0:
            return len(nums)
        
        return min(max(even_count, odd_count) * 2 - (1 if abs(even_count - odd_count) > 1 else 0), len(nums))
```",Y,
find-maximum-removals-from-source-string,Find Maximum Removals From Source String,"```python
from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        target_set = set(targetIndices)
        left = 0
        right = len(targetIndices)
        answer = 0
        
        while left <= right:
            mid = (left + right) // 2
            removed_indices = set(targetIndices[:mid])
            source_ptr = 0
            pattern_ptr = 0
            possible = True
            
            while pattern_ptr < len(pattern) and source_ptr < len(source):
                if source_ptr in removed_indices:
                    source_ptr += 1
                    continue
                if source[source_ptr] == pattern[pattern_ptr]:
                    pattern_ptr += 1
                source_ptr += 1
            
            if pattern_ptr == len(pattern):
                answer = mid
                left = mid + 1
            else:
                right = mid - 1
        
        return answer
```",Y,
count-the-number-of-good-nodes,Count the Number of Good Nodes,"```python
from collections import defaultdict
from typing import List

class Solution:
    def countGoodNodes(self, edges: List[List[int]]) -> int:
        if not edges:
            return 0
        
        tree = defaultdict(list)
        for a, b in edges:
            tree[a].append(b)
            tree[b].append(a)
        
        visited = set()
        size = {}
        is_good = {}
        
        stack = [(0, None, False)]
        
        while stack:
            node, parent, processed = stack.pop()
            if not processed:
                stack.append((node, parent, True))
                for neighbor in reversed(tree[node]):
                    if neighbor != parent:
                        stack.append((neighbor, node, False))
            else:
                sizes = []
                for neighbor in tree[node]:
                    if neighbor != parent:
                        sizes.append(size[neighbor])
                if not sizes:
                    size[node] = 1
                    is_good[node] = True
                else:
                    size[node] = 1 + sum(sizes)
                    is_good[node] = all(s == sizes[0] for s in sizes)
        
        return sum(is_good.values())
```",Y,
maximize-score-of-numbers-in-ranges,Maximize Score of Numbers in Ranges,"```python
from typing import List

class Solution:
    def maxPossibleScore(self, start: List[int], d: int) -> int:
        intervals = [(s, s + d) for s in start]
        intervals.sort()
        n = len(intervals)
        low = 0
        high = intervals[-1][1] - intervals[0][0]
        answer = 0
        
        def is_possible(mid):
            prev = intervals[0][0]
            count = 1
            for i in range(1, n):
                current_start, current_end = intervals[i]
                target = prev + mid
                if target <= current_end:
                    prev = max(target, current_start)
                    count += 1
                else:
                    return False
            return count == n
        
        while low <= high:
            mid = (low + high) // 2
            if is_possible(mid):
                answer = mid
                low = mid + 1
            else:
                high = mid - 1
        return answer
```",Y,
alternating-groups-ii,Alternating Groups II,"```python
from typing import List

class Solution:
    def numberOfAlternatingGroups(self, colors: List[int], k: int) -> int:
        n = len(colors)
        if k > n:
            return 0
        
        count = 0
        extended = colors + colors[:k-1]
        
        for i in range(n):
            group = extended[i:i+k]
            valid = True
            for j in range(1, k):
                if group[j] == group[j-1]:
                    valid = False
                    break
            if valid:
                count += 1
        
        return count
```",Y,
count-the-number-of-substrings-with-dominant-ones,Count the Number of Substrings With Dominant Ones,"```python
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        n = len(s)
        total = 0
        for i in range(n):
            zeros = 0
            ones = 0
            for j in range(i, n):
                if s[j] == '0':
                    zeros += 1
                else:
                    ones += 1
                if ones >= zeros * zeros:
                    total += 1
        return total
```",Y,
minimum-operations-to-make-binary-array-elements-equal-to-one-ii,Minimum Operations to Make Binary Array Elements Equal to One II,"```python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        operations = 0
        flip = 0
        for i in range(len(nums)):
            current = nums[i] ^ flip
            if current == 0:
                operations += 1
                flip ^= 1
        return operations
```",Y,
minimum-operations-to-make-binary-array-elements-equal-to-one-i,Minimum Operations to Make Binary Array Elements Equal to One I,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        res = 0
        nums = nums.copy()
        for i in range(n - 2):
            if nums[i] == 0:
                res += 1
                nums[i] ^= 1
                nums[i+1] ^= 1
                nums[i+2] ^= 1
        if nums[-1] == 1 and nums[-2] == 1:
            return res
        else:
            return -1
```",Y,
maximize-total-cost-of-alternating-subarrays,Maximize Total Cost of Alternating Subarrays,"```python
from typing import List

class Solution:
    def maximumTotalCost(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]
        
        
        dp = [0] * n
        dp[0] = nums[0]
        
        for i in range(1, n):
            option1 = dp[i-1] + nums[i]
            option2 = (dp[i-2] if i >= 2 else 0) + nums[i-1] + nums[i]
            dp[i] = max(option1, option2)
        
        return dp[-1]
```",Y,
vowels-game-in-a-string,Vowels Game in a String,"```python
class Solution:
    def doesAliceWin(self, s: str) -> bool:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        count = 0
        for c in s:
            if c in vowels:
                count += 1
        return count % 2 == 1
```",Y,
find-the-minimum-area-to-cover-all-ones-i,Find the Minimum Area to Cover All Ones I,"```python
from typing import List

class Solution:
    def minimumArea(self, grid: List[List[int]]) -> int:
        rows = len(grid)
        if rows == 0:
            return 0
        cols = len(grid[0])
        
        min_row = rows
        max_row = -1
        min_col = cols
        max_col = -1
        
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 1:
                    if i < min_row:
                        min_row = i
                    if i > max_row:
                        max_row = i
                    if j < min_col:
                        min_col = j
                    if j > max_col:
                        max_col = j
        
        if max_row == -1:  # no 1s found (though constraints say there's at least one)
            return 0
        
        height = max_row - min_row + 1
        width = max_col - min_col + 1
        
        return height * width
```",Y,
find-the-maximum-length-of-a-good-subsequence-i,Find the Maximum Length of a Good Subsequence I,"```python
from typing import List

class Solution:
    def maximumLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [[0] * (k + 1) for _ in range(n)]
        same = [[0] * (k + 1) for _ in range(n)]
        diff = [[0] * (k + 1) for _ in range(n)]
        
        for i in range(n):
            dp[i][0] = 1
            same[i][0] = 1
            for j in range(k + 1):
                max_len = 1
                max_same = 1
                max_diff = 0
                for prev in range(i):
                    if nums[prev] == nums[i]:
                        current = same[prev][j] + 1
                        if current > max_same:
                            max_same = current
                    else:
                        if j > 0:
                            current = max(same[prev][j-1], diff[prev][j-1]) + 1
                            if current > max_diff:
                                max_diff = current
                same[i][j] = max_same
                if j > 0:
                    diff[i][j] = max_diff
                dp[i][j] = max(same[i][j], diff[i][j] if j > 0 else 0)
        
        max_result = 0
        for i in range(n):
            for j in range(k + 1):
                if dp[i][j] > max_result:
                    max_result = dp[i][j]
        return max_result
```",Y,
minimum-length-of-string-after-operations,Minimum Length of String After Operations,"```python
class Solution:
    def minimumLength(self, s: str) -> int:
        left, right = 0, len(s) - 1
        while left < right and s[left] == s[right]:
            char = s[left]
            while left <= right and s[left] == char:
                left += 1
            while right >= left and s[right] == char:
                right -= 1
        return right - left + 1
```",Y,
generate-binary-strings-without-adjacent-zeros,Generate Binary Strings Without Adjacent Zeros,"```python
from typing import List

class Solution:
    def validStrings(self, n: int) -> List[str]:
        def backtrack(current, last_char):
            if len(current) == n:
                result.append(current)
                return
            backtrack(current + '1', '1')
            if last_char != '0':
                backtrack(current + '0', '0')
        
        result = []
        backtrack("""", """")
        return result
```",Y,
string-compression-iii,String Compression III,"```python
class Solution:
    def compressedString(self, word: str) -> str:
        comp = []
        i = 0
        n = len(word)
        while i < n:
            c = word[i]
            j = i
            while j < n and word[j] == c and (j - i) < 9:
                j += 1
            length = j - i
            comp.append(f""{length}{c}"")
            i = j
        return ''.join(comp)
```",Y,
lexicographically-minimum-string-after-removing-stars,Lexicographically Minimum String After Removing Stars,"```python
import heapq

class Solution:
    def clearStars(self, s: str) -> str:
        heap = []
        to_remove = set()
        for i, char in enumerate(s):
            if char == '*':
                if heap:
                    val, idx = heapq.heappop(heap)
                    to_remove.add(idx)
                    to_remove.add(i)
            else:
                heapq.heappush(heap, (char, i))
        result = []
        for i, char in enumerate(s):
            if i not in to_remove and char != '*':
                result.append(char)
        return ''.join(result)
```",Y,
find-the-number-of-good-pairs-ii,Find the Number of Good Pairs II,"```python
from collections import defaultdict
from typing import List

class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:
        freq = defaultdict(int)
        for num in nums2:
            freq[num * k] += 1
        
        divisors = defaultdict(int)
        for d in freq:
            for multiple in range(d, max(nums1) + 1, d):
                divisors[multiple] += freq[d]
        
        res = 0
        for num in nums1:
            res += divisors.get(num, 0)
        return res
```",Y,
maximum-total-reward-using-operations-i,Maximum Total Reward Using Operations I,"```python
class Solution:
    def maxTotalReward(self, rewardValues: List[int]) -> int:
        rewardValues = sorted(set(rewardValues))
        max_reward = 0
        dp = {0}
        
        for num in rewardValues:
            new_dp = set()
            for x in dp:
                if num > x:
                    new_x = x + num
                    new_dp.add(new_x)
                    if new_x > max_reward:
                        max_reward = new_x
            dp.update(new_dp)
        
        return max_reward
```",Y,
maximum-total-damage-with-spell-casting,Maximum Total Damage With Spell Casting,"```python
from collections import defaultdict
from typing import List

class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        freq = defaultdict(int)
        for p in power:
            freq[p] += 1
        
        unique_powers = sorted(freq.keys())
        n = len(unique_powers)
        dp = [0] * (n + 2)
        
        for i in range(n - 1, -1, -1):
            current_power = unique_powers[i]
            total = current_power * freq[current_power]
            
            next_allowed = i + 1
            while next_allowed < n:
                if unique_powers[next_allowed] > current_power + 2:
                    break
                next_allowed += 1
            
            if next_allowed < n:
                total += dp[next_allowed]
            
            dp[i] = max(total, dp[i + 1])
        
        return dp[0]
```",Y,
find-the-number-of-distinct-colors-among-the-balls,Find the Number of Distinct Colors Among the Balls,"```python
from typing import List

class Solution:
    def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:
        color_count = {}
        ball_colors = {}
        result = []
        distinct_colors = 0
        
        for x, y in queries:
            if x in ball_colors:
                old_color = ball_colors[x]
                color_count[old_color] -= 1
                if color_count[old_color] == 0:
                    distinct_colors -= 1
                    del color_count[old_color]
            
            ball_colors[x] = y
            if y in color_count:
                color_count[y] += 1
            else:
                color_count[y] = 1
                distinct_colors += 1
            
            result.append(distinct_colors)
        
        return result
```",Y,
count-days-without-meetings,Count Days Without Meetings,"```python
class Solution:
    def countDays(self, days: int, meetings: List[List[int]]) -> int:
        if not meetings:
            return days
        
        meetings.sort()
        
        merged = []
        for meeting in meetings:
            if not merged:
                merged.append(meeting)
            else:
                last_start, last_end = merged[-1]
                current_start, current_end = meeting
                if current_start <= last_end + 1:
                    new_start = last_start
                    new_end = max(last_end, current_end)
                    merged[-1] = [new_start, new_end]
                else:
                    merged.append(meeting)
        
        total_meeting_days = 0
        for interval in merged:
            start, end = interval
            total_meeting_days += end - start + 1
        
        return days - total_meeting_days
```",Y,
special-array-ii,Special Array II,"```python
from typing import List

class Solution:
    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:
        n = len(nums)
        prefix = [0] * n
        for i in range(1, n):
            prefix[i] = prefix[i-1] + (1 if (nums[i] % 2) == (nums[i-1] % 2) else 0)
        
        answer = []
        for query in queries:
            fromi, toi = query
            if fromi == toi:
                answer.append(True)
            else:
                answer.append(prefix[toi] - prefix[fromi] == 0)
        return answer
```",Y,
find-the-n-th-value-after-k-seconds,Find the N-th Value After K Seconds,"```python
class Solution:
    def valueAfterKSeconds(self, n: int, k: int) -> int:
        MOD = 10**9 + 7
        dp = [1] * n
        for _ in range(k):
            for i in range(1, n):
                dp[i] = (dp[i] + dp[i-1]) % MOD
        return dp[-1]
```",Y,
find-occurrences-of-an-element-in-an-array,Find Occurrences of an Element in an Array,"```python
from typing import List

class Solution:
    def occurrencesOfElement(self, nums: List[int], queries: List[int], x: int) -> List[int]:
        indices = [i for i, num in enumerate(nums) if num == x]
        answer = []
        for q in queries:
            if q <= len(indices):
                answer.append(indices[q-1])
            else:
                answer.append(-1)
        return answer
```",Y,
maximum-points-inside-the-square,Maximum Points Inside the Square,"```python
class Solution:
    def maxPointsInsideSquare(self, points: List[List[int]], s: str) -> int:
        max_side = []
        for x, y in points:
            current_max = max(abs(x), abs(y))
            max_side.append(current_max)
        
        tagged_sides = list(zip(max_side, s))
        
        tagged_sides.sort()
        
        seen_tags = set()
        result = 0
        prev_side = -1
        temp_count = 0
        
        for side, tag in tagged_sides:
            if side != prev_side:
                if len(seen_tags) == temp_count:
                    result = temp_count
                else:
                    break
                prev_side = side
            
            if tag in seen_tags:
                break
            seen_tags.add(tag)
            temp_count += 1
        
        else:
            if len(seen_tags) == temp_count:
                result = temp_count
        
        return result
```",Y,
count-pairs-that-form-a-complete-day-ii,Count Pairs That Form a Complete Day II,"```python
from typing import List
from collections import defaultdict

class Solution:
    def countCompleteDayPairs(self, hours: List[int]) -> int:
        mod_counts = defaultdict(int)
        count = 0
        for hour in hours:
            mod = hour % 24
            complement = (24 - mod) % 24
            count += mod_counts.get(complement, 0)
            mod_counts[mod] += 1
        return count
```",Y,
sum-of-digit-differences-of-all-pairs,Sum of Digit Differences of All Pairs,"```python
from typing import List

class Solution:
    def sumDigitDifferences(self, nums: List[int]) -> int:
        digit_counts = []
        num_strs = [str(num) for num in nums]
        length = len(num_strs[0])
        
        for i in range(length):
            freq = {}
            for num in num_strs:
                d = num[i]
                freq[d] = freq.get(d, 0) + 1
            digit_counts.append(freq)
        
        total = 0
        n = len(nums)
        for i in range(length):
            freq = digit_counts[i]
            s = 0
            for count in freq.values():
                s += count * (n - count)
            total += s // 2
        
        return total
```",Y,
find-the-first-player-to-win-k-games-in-a-row,Find The First Player to win K Games in a Row,"```python
from collections import deque

class Solution:
    def findWinningPlayer(self, skills: List[int], k: int) -> int:
        n = len(skills)
        if k >= n - 1:
            return skills.index(max(skills))
        
        queue = deque(range(n))
        current_winner = queue.popleft()
        consecutive_wins = 0
        
        while True:
            next_player = queue.popleft()
            if skills[current_winner] > skills[next_player]:
                consecutive_wins += 1
            else:
                queue.append(current_winner)
                current_winner = next_player
                consecutive_wins = 1
            
            if consecutive_wins == k:
                return current_winner
            
            queue.append(next_player)
```",Y,
find-all-possible-stable-binary-arrays-i,Find All Possible Stable Binary Arrays I,"```python
class Solution:
    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:
        MOD = 10**9 + 7
        dp = [[[0] * 2 for _ in range(one + 1)] for __ in range(zero + 1)]
        
        if zero > 0:
            dp[1][0][0] = 1
        if one > 0:
            dp[0][1][1] = 1
        
        for i in range(zero + 1):
            for j in range(one + 1):
                if i == 0 and j == 0:
                    continue
                for k in range(2):
                    if dp[i][j][k] == 0:
                        continue
                    if k == 0:
                        if i + 1 <= zero:
                            max_consec = limit
                            pass
                        pass
                    pass
        
        
        
        from functools import lru_cache
        
        memo = {}
        
        def helper(zeros_left, ones_left, last, consecutive):
            if zeros_left == 0 and ones_left == 0:
                return 1
            key = (zeros_left, ones_left, last, consecutive)
            if key in memo:
                return memo[key]
            total = 0
            if last == 0:
                if zeros_left > 0 and consecutive < limit:
                    total += helper(zeros_left - 1, ones_left, 0, consecutive + 1)
                if ones_left > 0:
                    total += helper(zeros_left, ones_left - 1, 1, 1)
            else:
                if ones_left > 0 and consecutive < limit:
                    total += helper(zeros_left, ones_left - 1, 1, consecutive + 1)
                if zeros_left > 0:
                    total += helper(zeros_left - 1, ones_left, 0, 1)
            total %= MOD
            memo[key] = total
            return total
        
        res = 0
        if zero > 0:
            res += helper(zero - 1, one, 0, 1)
        if one > 0:
            res += helper(zero, one - 1, 1, 1)
        return res % MOD
```",Y,
count-the-number-of-special-characters-ii,Count the Number of Special Characters II,"```python
class Solution:
    def numberOfSpecialChars(self, word: str) -> int:
        lowercase_first = {}
        uppercase_first = {}
        
        for i, c in enumerate(word):
            if c.islower():
                if c not in lowercase_first:
                    lowercase_first[c] = i
            else:
                lower_c = c.lower()
                if lower_c not in uppercase_first:
                    uppercase_first[lower_c] = i
        
        count = 0
        for c in lowercase_first:
            if c in uppercase_first:
                if lowercase_first[c] < uppercase_first[c]:
                    count += 1
        return count
```",Y,
minimum-number-of-operations-to-satisfy-conditions,Minimum Number of Operations to Satisfy Conditions,"```python
from typing import List

class Solution:
    def minimumOperations(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        
        if m == 1 and n == 1:
            return 0
        
        col_freq = []
        for j in range(n):
            freq = [0] * 10
            for i in range(m):
                freq[grid[i][j]] += 1
            col_freq.append(freq)
        
        dp_prev = {}
        for v in range(10):
            dp_prev[v] = m - col_freq[0][v]
        
        for j in range(1, n):
            dp_current = {}
            for v in range(10):
                min_ops = float('inf')
                for u in range(10):
                    if u != v:
                        if dp_prev[u] < min_ops:
                            min_ops = dp_prev[u]
                dp_current[v] = min_ops + (m - col_freq[j][v])
            dp_prev = dp_current
        
        return min(dp_prev.values()) if dp_prev else 0
```",Y,
minimum-substring-partition-of-equal-character-frequency,Minimum Substring Partition of Equal Character Frequency,"```python
class Solution:
    def minimumSubstringsInPartition(self, s: str) -> int:
        n = len(s)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        
        for i in range(1, n + 1):
            freq = [0] * 26
            for j in range(i, 0, -1):
                freq[ord(s[j-1]) - ord('a')] += 1
                balanced = True
                count = freq[ord(s[j-1]) - ord('a')]
                for k in range(26):
                    if freq[k] != 0 and freq[k] != count:
                        balanced = False
                        break
                if balanced:
                    dp[i] = min(dp[i], dp[j-1] + 1)
        
        return dp[n]
```",Y,
find-the-integer-added-to-array-ii,Find the Integer Added to Array II,"```python
from typing import List

class Solution:
    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:
        nums1.sort()
        nums2.sort()
        min_x = float('inf')
        
        n = len(nums1)
        for i in range(n):
            for j in range(i + 1, n):
                candidate = []
                for k in range(n):
                    if k != i and k != j:
                        candidate.append(nums1[k])
                x = nums2[0] - candidate[0]
                match = True
                for a, b in zip(candidate, nums2):
                    if b - a != x:
                        match = False
                        break
                if match:
                    if x < min_x:
                        min_x = x
        return min_x
```",Y,
minimum-length-of-anagram-concatenation,Minimum Length of Anagram Concatenation,"```python
import math
from collections import Counter

class Solution:
    def minAnagramLength(self, s: str) -> int:
        n = len(s)
        freq = Counter(s)
        k = len(freq)
        
        max_char_freq = max(freq.values())
        min_possible = max_char_freq
        
        for candidate in range(min_possible, n // 2 + 1):
            if n % candidate != 0:
                continue
            t_len = candidate
            valid = True
            for c in freq:
                if freq[c] % (n // t_len) != 0:
                    valid = False
                    break
            if valid:
                return t_len
        
        return n
```",Y,
minimum-array-end,Minimum Array End,"```python
class Solution:
    def minEnd(self, n: int, x: int) -> int:
        m = n - 1
        res = x
        mask = 1
        for _ in range(60):
            if (res & mask) == 0:
                if m >= 1:
                    res |= mask
                    m -= 1
                else:
                    break
            mask <<= 1
        mask = 1
        while m > 0:
            if (res & mask) == 0:
                res |= mask
                m -= 1
            mask <<= 1
        return res
```",Y,
maximum-difference-score-in-a-grid,Maximum Difference Score in a Grid,"```python
from typing import List

class Solution:
    def maxScore(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        max_diff = [[-float('inf')] * n for _ in range(m)]
        res = -float('inf')
        
        for i in range(m-1, -1, -1):
            for j in range(n-1, -1, -1):
                if i < m - 1:
                    max_diff[i][j] = max(max_diff[i][j], max_diff[i+1][j])
                if j < n - 1:
                    max_diff[i][j] = max(max_diff[i][j], max_diff[i][j+1])
                if max_diff[i][j] != -float('inf'):
                    res = max(res, max_diff[i][j] - grid[i][j])
                max_diff[i][j] = max(max_diff[i][j], grid[i][j])
        
        return res
```",Y,
minimum-rectangles-to-cover-points,Minimum Rectangles to Cover Points,"```python
class Solution:
    def minRectanglesToCoverPoints(self, points: List[List[int]], w: int) -> int:
        if not points:
            return 0
        points.sort()
        res = 0
        i = 0
        n = len(points)
        while i < n:
            res += 1
            start = points[i][0]
            end = start + w
            while i < n and points[i][0] <= end:
                i += 1
        return res
```",Y,
minimum-time-to-visit-disappearing-nodes,Minimum Time to Visit Disappearing Nodes,"```python
import heapq
from typing import List

class Solution:
    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:
        graph = [[] for _ in range(n)]
        for u, v, length in edges:
            graph[u].append((v, length))
            graph[v].append((u, length))
        
        answer = [-1] * n
        heap = []
        heapq.heappush(heap, (0, 0))
        
        while heap:
            current_time, node = heapq.heappop(heap)
            if answer[node] != -1:
                continue
            if current_time >= disappear[node]:
                continue
            answer[node] = current_time
            
            for neighbor, length in graph[node]:
                if answer[neighbor] == -1:
                    new_time = current_time + length
                    if new_time < disappear[neighbor]:
                        heapq.heappush(heap, (new_time, neighbor))
        
        return answer
```",Y,
right-triangles,Right Triangles,"```python
from typing import List

class Solution:
    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:
        rows = len(grid)
        cols = len(grid[0]) if rows > 0 else 0
        
        row_counts = [0] * rows
        col_counts = [0] * cols
        
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 1:
                    row_counts[i] += 1
                    col_counts[j] += 1
        
        count = 0
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 1:
                    count += (row_counts[i] - 1) * (col_counts[j] - 1)
        
        return count
```",Y,
minimum-operations-to-make-median-of-array-equal-to-k,Minimum Operations to Make Median of Array Equal to K,"```python
class Solution:
    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        median_pos = n // 2
        operations = 0
        
        if nums[median_pos] == k:
            return 0
        elif nums[median_pos] < k:
            operations += k - nums[median_pos]
            for i in range(median_pos + 1, n):
                if nums[i] < k:
                    operations += k - nums[i]
                else:
                    break
        else:
            operations += nums[median_pos] - k
            for i in range(median_pos - 1, -1, -1):
                if nums[i] > k:
                    operations += nums[i] - k
                else:
                    break
        return operations
```",Y,
minimum-number-of-operations-to-make-word-k-periodic,Minimum Number of Operations to Make Word K-Periodic,"```python
class Solution:
    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:
        n = len(word)
        segments = [word[i:i+k] for i in range(0, n, k)]
        freq = {}
        max_freq = 0
        for seg in segments:
            freq[seg] = freq.get(seg, 0) + 1
            if freq[seg] > max_freq:
                max_freq = freq[seg]
        return len(segments) - max_freq
```",Y,
taking-maximum-energy-from-the-mystic-dungeon,Taking Maximum Energy From the Mystic Dungeon,"```python
from typing import List

class Solution:
    def maximumEnergy(self, energy: List[int], k: int) -> int:
        n = len(energy)
        max_energy = -float('inf')
        
        for i in range(n - 1, n - k - 1, -1):
            current_sum = 0
            for j in range(i, -1, -k):
                current_sum += energy[j]
                if current_sum > max_energy:
                    max_energy = current_sum
        
        return max_energy
```",Y,
shortest-subarray-with-or-at-least-k-ii,Shortest Subarray With OR at Least K II,"```python
class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        min_len = float('inf')
        
        for i in range(n):
            current_or = 0
            for j in range(i, n):
                current_or |= nums[j]
                if current_or >= k:
                    min_len = min(min_len, j - i + 1)
                    break
        
        return min_len if min_len != float('inf') else -1
```",Y,
count-alternating-subarrays,Count Alternating Subarrays,"```python
from typing import List

class Solution:
    def countAlternatingSubarrays(self, nums: List[int]) -> int:
        total = 0
        current = 1
        
        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]:
                current += 1
            else:
                total += current * (current + 1) // 2
                current = 1
        total += current * (current + 1) // 2
        
        return total
```",Y,
maximum-prime-difference,Maximum Prime Difference,"```python
class Solution:
    def maximumPrimeDifference(self, nums: List[int]) -> int:
        primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
        prime_indices = []
        for i, num in enumerate(nums):
            if num in primes:
                prime_indices.append(i)
        if len(prime_indices) == 1:
            return 0
        return prime_indices[-1] - prime_indices[0]
```",Y,
most-frequent-ids,Most Frequent IDs,"```python
from collections import defaultdict
import heapq

class Solution:
    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:
        freq_map = defaultdict(int)
        max_heap = []
        ans = []
        
        for num, f in zip(nums, freq):
            if f > 0:
                freq_map[num] += f
                heapq.heappush(max_heap, (-freq_map[num], num))
            else:
                freq_map[num] += f
                if freq_map[num] <= 0:
                    del freq_map[num]
                heapq.heappush(max_heap, (-freq_map[num], num) if num in freq_map else (0, num))
            
            while max_heap:
                current_neg_f, current_num = max_heap[0]
                current_f = -current_neg_f
                if current_num in freq_map and freq_map[current_num] == current_f:
                    ans.append(current_f)
                    break
                else:
                    heapq.heappop(max_heap)
            else:
                ans.append(0)
        
        return ans
```",Y,
minimum-deletions-to-make-string-k-special,Minimum Deletions to Make String K-Special,"```python
class Solution:
    def minimumDeletions(self, word: str, k: int) -> int:
        from collections import defaultdict

        freq = defaultdict(int)
        for c in word:
            freq[c] += 1
        
        frequencies = sorted(freq.values())
        min_deletions = float('inf')
        
        for i in range(len(frequencies)):
            target_min = frequencies[i]
            deletions = 0
            for j in range(len(frequencies)):
                if frequencies[j] < target_min:
                    deletions += frequencies[j]
                elif frequencies[j] > target_min + k:
                    deletions += frequencies[j] - (target_min + k)
            min_deletions = min(min_deletions, deletions)
        
        return min_deletions
```",Y,
shortest-uncommon-substring-in-an-array,Shortest Uncommon Substring in an Array,"```python
from typing import List

class Solution:
    def shortestSubstrings(self, arr: List[str]) -> List[str]:
        answer = []
        n = len(arr)
        
        for i in range(n):
            s = arr[i]
            min_sub = """"
            found = False
            
            for length in range(1, len(s) + 1):
                candidates = []
                for start in range(len(s) - length + 1):
                    substring = s[start:start+length]
                    unique = True
                    for j in range(n):
                        if j != i and substring in arr[j]:
                            unique = False
                            break
                    if unique:
                        candidates.append(substring)
                if candidates:
                    candidates.sort()
                    min_sub = candidates[0]
                    found = True
                    break
            answer.append(min_sub if found else """")
        
        return answer
```",Y,
minimum-levels-to-gain-more-points,Minimum Levels to Gain More Points,"```python
from typing import List

class Solution:
    def minimumLevels(self, possible: List[int]) -> int:
        n = len(possible)
        total = sum(1 if x == 1 else -1 for x in possible)
        alice_sum = 0
        for i in range(n - 1):
            alice_sum += 1 if possible[i] == 1 else -1
            bob_sum = total - alice_sum
            if alice_sum > bob_sum:
                return i + 1
        return -1
```",Y,
replace-question-marks-in-string-to-minimize-its-value,Replace Question Marks in String to Minimize Its Value,"```python
class Solution:
    def minimizeStringValue(self, s: str) -> str:
        s_list = list(s)
        freq = [0] * 26
        for c in s_list:
            if c != '?':
                freq[ord(c) - ord('a')] += 1
        
        question_indices = [i for i, c in enumerate(s_list) if c == '?']
        
        for idx in question_indices:
            min_freq = min(freq)
            candidates = [i for i in range(26) if freq[i] == min_freq]
            chosen_char = min(candidates)  # lex smallest
            s_list[idx] = chr(ord('a') + chosen_char)
            freq[chosen_char] += 1
        
        return ''.join(s_list)
```",Y,
maximize-happiness-of-selected-children,Maximize Happiness of Selected Children,"```python
class Solution:
    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:
        happiness.sort(reverse=True)
        total = 0
        for i in range(k):
            current = max(happiness[i] - i, 0)
            total += current
        return total
```",Y,
lexicographically-smallest-string-after-operations-with-constraint,Lexicographically Smallest String After Operations With Constraint,"```python
class Solution:
    def getSmallestString(self, s: str, k: int) -> str:
        res = []
        remaining_k = k
        for c in s:
            if remaining_k <= 0:
                res.append(c)
                continue
            current_char = ord(c) - ord('a')
            for target in range(0, 26):
                distance = min((current_char - target) % 26, (target - current_char) % 26)
                if distance <= remaining_k:
                    remaining_k -= distance
                    res.append(chr(ord('a') + target))
                    break
        return ''.join(res)
```",Y,
count-submatrices-with-top-left-element-and-sum-less-than-k,Count Submatrices with Top-Left Element and Sum Less Than k,"```python
from typing import List

class Solution:
    def countSubmatrices(self, grid: List[List[int]], k: int) -> int:
        m = len(grid)
        n = len(grid[0])
        prefix = [[0] * (n + 1) for _ in range(m + 1)]
        count = 0
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = grid[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]
                if prefix[i][j] <= k:
                    count += 1
                else:
                    break
        
        return count
```",Y,
count-substrings-starting-and-ending-with-given-character,Count Substrings Starting and Ending with Given Character,"```python
class Solution:
    def countSubstrings(self, s: str, c: str) -> int:
        count = s.count(c)
        return count * (count + 1) // 2
```",Y,
water-bottles-ii,Water Bottles II,"```python
class Solution:
    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:
        total = 0
        empty = 0
        current_numBottles = numBottles
        current_numExchange = numExchange
        
        while True:
            if current_numBottles > 0:
                total += current_numBottles
                empty += current_numBottles
                current_numBottles = 0
            elif empty >= current_numExchange:
                exchanged = empty // current_numExchange
                current_numBottles += exchanged
                empty -= exchanged * current_numExchange
                current_numExchange += 1
            else:
                break
        return total
```",Y,
minimum-operations-to-write-the-letter-y-on-a-grid,Minimum Operations to Write the Letter Y on a Grid,"```python
from typing import List

class Solution:
    def minimumOperationsToWriteY(self, grid: List[List[int]]) -> int:
        n = len(grid)
        center = n // 2
        y_cells = set()
        non_y_cells = set()
        
        for i in range(center + 1):
            y_cells.add((i, i))  # top-left to center diagonal
            y_cells.add((i, n - 1 - i))  # top-right to center diagonal
        for i in range(center, n):
            y_cells.add((i, center))  # vertical line from center to bottom
        
        for i in range(n):
            for j in range(n):
                if (i, j) not in y_cells:
                    non_y_cells.add((i, j))
        
        y_counts = [0, 0, 0]
        non_y_counts = [0, 0, 0]
        
        for (i, j) in y_cells:
            val = grid[i][j]
            y_counts[val] += 1
        
        for (i, j) in non_y_cells:
            val = grid[i][j]
            non_y_counts[val] += 1
        
        total_y = sum(y_counts)
        total_non_y = sum(non_y_counts)
        
        min_operations = float('inf')
        
        for y_val in range(3):
            for non_y_val in range(3):
                if y_val == non_y_val:
                    continue
                operations = (total_y - y_counts[y_val]) + (total_non_y - non_y_counts[non_y_val])
                if operations < min_operations:
                    min_operations = operations
        
        return min_operations
```",Y,
minimum-operations-to-exceed-threshold-value-ii,Minimum Operations to Exceed Threshold Value II,"```python
import heapq

class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        heap = []
        for num in nums:
            heapq.heappush(heap, num)
        
        operations = 0
        while heap[0] < k and len(heap) >= 2:
            x = heapq.heappop(heap)
            y = heapq.heappop(heap)
            new_num = min(x, y) * 2 + max(x, y)
            heapq.heappush(heap, new_num)
            operations += 1
        
        return operations
```",Y,
find-the-length-of-the-longest-common-prefix,Find the Length of the Longest Common Prefix,"```python
class Solution:
    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:
        max_len = 0
        prefixes = set()
        
        for num in arr1:
            s = str(num)
            for i in range(1, len(s)+1):
                prefixes.add(s[:i])
        
        for num in arr2:
            s = str(num)
            for i in range(1, len(s)+1):
                prefix = s[:i]
                if prefix in prefixes and i > max_len:
                    max_len = i
        
        return max_len
```",Y,
apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k,Apply Operations to Make Sum of Array Greater Than or Equal to k,"```python
class Solution:
    def minOperations(self, k: int) -> int:
        if k == 1:
            return 0
        min_ops = float('inf')
        for a in range(1, k + 1):
            b = (k + a - 1) // a  # Equivalent to math.ceil(k / a)
            ops = (a - 1) + (b - 1)
            if ops < min_ops:
                min_ops = ops
            if a > b:
                break
        return min_ops
```",Y,
count-pairs-of-connectable-servers-in-a-weighted-tree-network,Count Pairs of Connectable Servers in a Weighted Tree Network,"```python
from typing import List

class Solution:
    def countPairsOfConnectableServers(self, edges: List[List[int]], signalSpeed: int) -> List[int]:
        n = len(edges) + 1
        graph = [[] for _ in range(n)]
        for a, b, w in edges:
            graph[a].append((b, w))
            graph[b].append((a, w))
        
        res = [0] * n
        
        for c in range(n):
            counts = []
            visited = [False] * n
            visited[c] = True
            
            for neighbor, w in graph[c]:
                stack = [(neighbor, w)]
                visited[neighbor] = True
                cnt = 0
                
                while stack:
                    node, dist = stack.pop()
                    if dist % signalSpeed == 0:
                        cnt += 1
                    for child, child_w in graph[node]:
                        if not visited[child]:
                            visited[child] = True
                            stack.append((child, dist + child_w))
                
                counts.append(cnt)
            
            total = 0
            for i in range(len(counts)):
                for j in range(i + 1, len(counts)):
                    total += counts[i] * counts[j]
            res[c] = total
        
        return res
```",Y,
find-the-largest-area-of-square-inside-two-rectangles,Find the Largest Area of Square Inside Two Rectangles,"```python
from typing import List

class Solution:
    def largestSquareArea(self, bottomLeft: List[List[int]], topRight: List[List[int]]) -> int:
        max_area = 0
        n = len(bottomLeft)
        
        for i in range(n):
            for j in range(i + 1, n):
                x1 = max(bottomLeft[i][0], bottomLeft[j][0])
                y1 = max(bottomLeft[i][1], bottomLeft[j][1])
                x2 = min(topRight[i][0], topRight[j][0])
                y2 = min(topRight[i][1], topRight[j][1])
                
                if x1 < x2 and y1 < y2:
                    side = min(x2 - x1, y2 - y1)
                    max_area = max(max_area, side * side)
        
        return max_area
```",Y,
maximum-number-of-operations-with-the-same-score-ii,Maximum Number of Operations With the Same Score II,"```python
from typing import List

class Solution:
    def maxOperations(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return 0
        
        def helper(start, end, target, memo):
            if start >= end:
                return 0
            if (start, end) in memo:
                return memo[(start, end)]
            
            res = 0
            if nums[start] + nums[start + 1] == target:
                res = max(res, 1 + helper(start + 2, end, target, memo))
            if nums[end] + nums[end - 1] == target:
                res = max(res, 1 + helper(start, end - 2, target, memo))
            if nums[start] + nums[end] == target:
                res = max(res, 1 + helper(start + 1, end - 1, target, memo))
            
            memo[(start, end)] = res
            return res
        
        options = [
            nums[0] + nums[1],
            nums[-1] + nums[-2],
            nums[0] + nums[-1]
        ]
        
        max_ops = 0
        for target in options:
            memo = {}
            current_ops = helper(0, n - 1, target, memo)
            if current_ops > max_ops:
                max_ops = current_ops
        
        return max_ops
```",Y,
maximum-palindromes-after-operations,Maximum Palindromes After Operations,"```python
from collections import defaultdict

class Solution:
    def maxPalindromesAfterOperations(self, words: List[str]) -> int:
        char_counts = defaultdict(int)
        word_lengths = []
        
        for word in words:
            word_lengths.append(len(word))
            for c in word:
                char_counts[c] += 1
        
        total_pairs = 0
        for count in char_counts.values():
            total_pairs += count // 2
        
        word_lengths.sort()
        max_palindromes = 0
        
        for length in word_lengths:
            required_pairs = length // 2
            if total_pairs >= required_pairs:
                total_pairs -= required_pairs
                max_palindromes += 1
            else:
                break
        
        return max_palindromes
```",Y,
most-frequent-prime,Most Frequent Prime,"```python
import math
from typing import List
from collections import defaultdict

class Solution:
    def mostFrequentPrime(self, mat: List[List[int]]) -> int:
        def is_prime(num):
            if num < 2:
                return False
            for i in range(2, int(math.sqrt(num)) + 1):
                if num % i == 0:
                    return False
            return True
        
        directions = [
            (0, 1),   # east
            (1, 1),    # south-east
            (1, 0),    # south
            (1, -1),   # south-west
            (0, -1),   # west
            (-1, -1),  # north-west
            (-1, 0),   # north
            (-1, 1)    # north-east
        ]
        
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        prime_counts = defaultdict(int)
        
        for i in range(m):
            for j in range(n):
                for di, dj in directions:
                    num = 0
                    ni, nj = i, j
                    while 0 <= ni < m and 0 <= nj < n:
                        num = num * 10 + mat[ni][nj]
                        if num > 10 and is_prime(num):
                            prime_counts[num] += 1
                        ni += di
                        nj += dj
        
        if not prime_counts:
            return -1
        
        max_freq = max(prime_counts.values())
        candidates = [num for num, freq in prime_counts.items() if freq == max_freq]
        return max(candidates)
```",Y,
apply-operations-to-make-string-empty,Apply Operations to Make String Empty,"```python
class Solution:
    def lastNonEmptyString(self, s: str) -> str:
        last_occurrence = {}
        for idx, char in enumerate(s):
            last_occurrence[char] = idx
        
        max_last_occurrence = max(last_occurrence.values()) if last_occurrence else -1
        result = []
        for idx, char in enumerate(s):
            if last_occurrence[char] == idx and idx <= max_last_occurrence:
                result.append(char)
        return ''.join(result)
```",Y,
mark-elements-on-array-by-performing-queries,Mark Elements on Array by Performing Queries,"```python
import heapq
from typing import List

class Solution:
    def unmarkedSumArray(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        n = len(nums)
        marked = [False] * n
        total_sum = sum(nums)
        marked_sum = 0
        
        heap = []
        for i in range(n):
            heapq.heappush(heap, (nums[i], i))
        
        res = []
        for index, k in queries:
            if not marked[index]:
                marked[index] = True
                marked_sum += nums[index]
            
            count = 0
            temp = []
            while heap and count < k:
                val, i = heapq.heappop(heap)
                if not marked[i]:
                    marked[i] = True
                    marked_sum += val
                    count += 1
                else:
                    temp.append((val, i))
            
            for val, i in temp:
                heapq.heappush(heap, (val, i))
            
            res.append(total_sum - marked_sum)
        
        return res
```",Y,
find-the-maximum-number-of-elements-in-subset,Find the Maximum Number of Elements in Subset,"```python
from collections import defaultdict
from typing import List

class Solution:
    def maximumLength(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for num in nums:
            freq[num] += 1
        
        max_len = 1
        
        for num in sorted(freq.keys(), reverse=True):
            if num == 1:
                max_len = max(max_len, freq[num] if freq[num] % 2 == 1 else freq[num] - 1)
                continue
            
            current = num
            count = 0
            temp_freq = freq.copy()
            
            while True:
                sqrt = int(current ** 0.5)
                if sqrt * sqrt != current or sqrt not in temp_freq or temp_freq[sqrt] < 2:
                    break
                temp_freq[sqrt] -= 2
                count += 2
                current = sqrt
            
            if count > 0:
                if temp_freq.get(current, 0) >= 1:
                    count += 1
                    max_len = max(max_len, count)
                else:
                    max_len = max(max_len, count - 1)
        
        return max_len
```",Y,
minimum-time-to-revert-word-to-initial-state-i,Minimum Time to Revert Word to Initial State I,"```python
class Solution:
    def minimumTimeToInitialState(self, word: str, k: int) -> int:
        n = len(word)
        for t in range(1, n // k + 2):
            remaining = t * k
            if remaining >= n:
                return t
            match = True
            for i in range(remaining, n):
                if word[i] != word[i - remaining]:
                    match = False
                    break
            if match:
                return t
        return -1
```",Y,
earliest-second-to-mark-indices-i,Earliest Second to Mark Indices I,"```python
from typing import List

class Solution:
    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:
        n = len(nums)
        m = len(changeIndices)
        
        last_pos = {}
        for s in range(m):
            idx = changeIndices[s] - 1  # converting to 0-based
            last_pos[idx] = s + 1  # 1-based second
        
        if len(last_pos) < n:
            return -1
        
        left = 1
        right = m
        answer = -1
        
        while left <= right:
            mid = (left + right) // 2
            total_required = 0
            required_positions = []
            possible = True
            
            last_positions = {}
            for s in range(mid):
                idx = changeIndices[s] - 1
                last_positions[idx] = s + 1  # 1-based
            
            if len(last_positions) < n:
                possible = False
            else:
                total_required = sum(nums[i] + 1 for i in range(n))
                if total_required > mid:
                    possible = False
                else:
                    indices_order = sorted(range(n), key=lambda x: last_positions[x])
                    current_time = 0
                    possible = True
                    for i in indices_order:
                        required = nums[i] + 1
                        if current_time + required > last_positions[i]:
                            possible = False
                            break
                        current_time += required
            
            if possible:
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        
        return answer
```",Y,
find-if-array-can-be-sorted,Find if Array Can Be Sorted,"```python
class Solution:
    def canSortArray(self, nums: List[int]) -> bool:
        set_bits = [num.bit_count() for num in nums]
        
        groups = []
        current_group = []
        current_bit = set_bits[0]
        
        for num, bits in zip(nums, set_bits):
            if bits == current_bit:
                current_group.append(num)
            else:
                groups.append(current_group)
                current_group = [num]
                current_bit = bits
        groups.append(current_group)
        
        sorted_nums = sorted(nums)
        grouped_nums = []
        for group in groups:
            grouped_nums.extend(group)
        
        return grouped_nums == sorted_nums
```",Y,
alice-and-bob-playing-flower-game,Alice and Bob Playing Flower Game,"```python
class Solution:
    def flowerGame(self, n: int, m: int) -> int:
        even_n = n // 2
        odd_n = (n + 1) // 2
        even_m = m // 2
        odd_m = (m + 1) // 2
        return even_n * odd_m + odd_n * even_m
```",Y,
find-the-number-of-ways-to-place-people-i,Find the Number of Ways to Place People I,"```python
from typing import List

class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        count = 0
        n = len(points)
        for i in range(n):
            x1, y1 = points[i]
            for j in range(n):
                if i == j:
                    continue
                x2, y2 = points[j]
                if x1 <= x2 and y1 >= y2:
                    valid = True
                    for k in range(n):
                        if k == i or k == j:
                            continue
                        x, y = points[k]
                        if (x >= x1 and x <= x2) and (y <= y1 and y >= y2):
                            valid = False
                            break
                    if valid:
                        count += 1
        return count
```",Y,
minimum-number-of-pushes-to-type-word-ii,Minimum Number of Pushes to Type Word II,"```python
class Solution:
    def minimumPushes(self, word: str) -> int:
        from collections import defaultdict
        
        freq = defaultdict(int)
        for c in word:
            freq[c] += 1
        
        sorted_freq = sorted(freq.values(), reverse=True)
        
        total_pushes = 0
        for i, count in enumerate(sorted_freq):
            if i < 8:
                total_pushes += count * 1
            elif i < 16:
                total_pushes += count * 2
            elif i < 24:
                total_pushes += count * 3
            else:
                total_pushes += count * 4
        
        return total_pushes
```",Y,
find-the-grid-of-region-average,Find the Grid of Region Average,"```python
from typing import List

class Solution:
    def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:
        m = len(image)
        n = len(image[0]) if m > 0 else 0
        regions = []
        
        for i in range(m - 2):
            for j in range(n - 2):
                is_region = True
                total = 0
                for x in range(i, i + 3):
                    for y in range(j, j + 3):
                        total += image[x][y]
                        if y + 1 < j + 3:
                            if abs(image[x][y] - image[x][y + 1]) > threshold:
                                is_region = False
                                break
                        if x + 1 < i + 3:
                            if abs(image[x][y] - image[x + 1][y]) > threshold:
                                is_region = False
                                break
                    if not is_region:
                        break
                if is_region:
                    avg = total // 9
                    regions.append((i, j, avg))
        
        result = [[0 for _ in range(n)] for _ in range(m)]
        for i in range(m):
            for j in range(n):
                region_avgs = []
                for (x, y, avg) in regions:
                    if x <= i <= x + 2 and y <= j <= y + 2:
                        region_avgs.append(avg)
                if region_avgs:
                    total_avg = sum(region_avgs) // len(region_avgs)
                    result[i][j] = total_avg
                else:
                    result[i][j] = image[i][j]
        return result
```",Y,
count-the-number-of-houses-at-a-certain-distance-i,Count the Number of Houses at a Certain Distance I,"```python
from typing import List

class Solution:
    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:
        x, y = min(x, y), max(x, y)
        res = [0] * n
        for i in range(1, n + 1):
            for j in range(i + 1, n + 1):
                d = min(j - i, abs(x - i) + 1 + abs(y - j))
                if d <= n:
                    res[d - 1] += 2
        return res
```",Y,
minimum-moves-to-capture-the-queen,Minimum Moves to Capture The Queen,"```python
class Solution:
    def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:
        if a == e or b == f:
            blocked = False
            if a == e:
                step = 1 if d > b else -1
                for y in range(b + step, d, step):
                    if a == c and y == d:
                        blocked = True
                        break
                if not blocked:
                    step = 1 if f > b else -1
                    for y in range(b + step, f, step):
                        if a == c and y == d:
                            blocked = True
                            break
            else:  # b == f
                step = 1 if c > a else -1
                for x in range(a + step, c, step):
                    if x == c and b == d:
                        blocked = True
                        break
                if not blocked:
                    step = 1 if e > a else -1
                    for x in range(a + step, e, step):
                        if x == c and b == d:
                            blocked = True
                            break
            if not blocked:
                return 0
        
        if abs(c - e) == abs(d - f):
            blocked = False
            step_x = 1 if e > c else -1
            step_y = 1 if f > d else -1
            x, y = c + step_x, d + step_y
            while x != e and y != f:
                if x == a and y == b:
                    blocked = True
                    break
                x += step_x
                y += step_y
            if not blocked:
                return 0
        
        if (a == e or b == f) and not (a == e and b == f):
            blocked = False
            if a == e:
                step = 1 if f > b else -1
                for y in range(b + step, f, step):
                    if a == c and y == d:
                        blocked = True
                        break
            else:
                step = 1 if e > a else -1
                for x in range(a + step, e, step):
                    if x == c and b == d:
                        blocked = True
                        break
            if not blocked:
                return 1
        
        if abs(a - e) == abs(b - f):
            blocked = False
            step_x = 1 if e > a else -1
            step_y = 1 if f > b else -1
            x, y = a + step_x, b + step_y
            while x != e and y != f:
                if x == c and y == d:
                    blocked = True
                    break
                x += step_x
                y += step_y
            if not blocked:
                return 1
        
        if (a == c or b == d) and not (a == c and b == d):
            blocked = False
            if a == c:
                step = 1 if d > b else -1
                for y in range(b + step, d, step):
                    if a == e and y == f:
                        blocked = True
                        break
            else:
                step = 1 if c > a else -1
                for x in range(a + step, c, step):
                    if x == e and b == f:
                        blocked = True
                        break
            if not blocked:
                if abs(c - e) == abs(d - f):
                    blocked_bishop = False
                    step_x = 1 if e > c else -1
                    step_y = 1 if f > d else -1
                    x, y = c + step_x, d + step_y
                    while x != e and y != f:
                        if x == a and y == b:
                            blocked_bishop = True
                            break
                        x += step_x
                        y += step_y
                    if not blocked_bishop:
                        return 1
        
        if abs(c - a) == abs(d - b):
            blocked = False
            step_x = 1 if a > c else -1
            step_y = 1 if b > d else -1
            x, y = c + step_x, d + step_y
            while x != a and y != b:
                if x == e and y == f:
                    blocked = True
                    break
                x += step_x
                y += step_y
            if not blocked:
                if (a == e or b == f) and not (a == e and b == f):
                    blocked_rook = False
                    if a == e:
                        step = 1 if f > b else -1
                        for y in range(b + step, f, step):
                            if a == c and y == d:
                                blocked_rook = True
                                break
                    else:
                        step = 1 if e > a else -1
                        for x in range(a + step, e, step):
                            if x == c and b == d:
                                blocked_rook = True
                                break
                    if not blocked_rook:
                        return 1
        
        return 2
```",Y,
number-of-subarrays-that-match-a-pattern-i,Number of Subarrays That Match a Pattern I,"```python
from typing import List

class Solution:
    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:
        count = 0
        n = len(nums)
        m = len(pattern)
        for i in range(n - m):
            match = True
            for k in range(m):
                if pattern[k] == 1:
                    if not (nums[i + k + 1] > nums[i + k]):
                        match = False
                        break
                elif pattern[k] == 0:
                    if not (nums[i + k + 1] == nums[i + k]):
                        match = False
                        break
                elif pattern[k] == -1:
                    if not (nums[i + k + 1] < nums[i + k]):
                        match = False
                        break
            if match:
                count += 1
        return count
```",Y,
find-longest-special-substring-that-occurs-thrice-i,Find Longest Special Substring That Occurs Thrice I,"```python
class Solution:
    def maximumLength(self, s: str) -> int:
        from collections import defaultdict

        char_substrings = defaultdict(list)
        n = len(s)
        
        for i in range(n):
            current_char = s[i]
            length = 1
            char_substrings[current_char].append(length)
            for j in range(i + 1, n):
                if s[j] == current_char:
                    length += 1
                    char_substrings[current_char].append(length)
                else:
                    break
        
        max_len = -1
        for char in char_substrings:
            lengths = char_substrings[char]
            if len(lengths) >= 3:
                lengths.sort(reverse=True)
                max_len = max(max_len, lengths[2])
        
        return max_len
```",Y,
find-longest-special-substring-that-occurs-thrice-ii,Find Longest Special Substring That Occurs Thrice II,"```python
class Solution:
    def maximumLength(self, s: str) -> int:
        from collections import defaultdict

        char_length_counts = defaultdict(list)
        
        n = len(s)
        if n < 3:
            return -1
        
        current_char = s[0]
        current_length = 1
        
        for i in range(1, n):
            if s[i] == current_char:
                current_length += 1
            else:
                for l in range(1, current_length + 1):
                    char_length_counts[current_char].append(l)
                current_char = s[i]
                current_length = 1
        
        for l in range(1, current_length + 1):
            char_length_counts[current_char].append(l)
        
        max_len = -1
        
        for char in char_length_counts:
            lengths = char_length_counts[char]
            if len(lengths) < 3:
                continue
            lengths.sort(reverse=True)
            candidate = lengths[2]
            if candidate > max_len:
                max_len = candidate
        
        return max_len
```",Y,
maximum-good-subarray-sum,Maximum Good Subarray Sum,"```python
from typing import List

class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        prefix_sum = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            prefix_sum[i+1] = prefix_sum[i] + nums[i]
        
        value_indices = {}
        max_sum = -float('inf')
        
        for j in range(len(nums)):
            target1 = nums[j] - k
            target2 = nums[j] + k
            
            if target1 in value_indices:
                for i in value_indices[target1]:
                    current_sum = prefix_sum[j+1] - prefix_sum[i]
                    if current_sum > max_sum:
                        max_sum = current_sum
            
            if target2 in value_indices:
                for i in value_indices[target2]:
                    current_sum = prefix_sum[j+1] - prefix_sum[i]
                    if current_sum > max_sum:
                        max_sum = current_sum
            
            if nums[j] not in value_indices:
                value_indices[nums[j]] = []
            value_indices[nums[j]].append(j)
        
        return max_sum if max_sum != -float('inf') else 0
```",Y,
maximum-points-after-enemy-battles,Maximum Points After Enemy Battles,"```python
from typing import List

class Solution:
    def maximumPoints(self, enemyEnergies: List[int], currentEnergy: int) -> int:
        enemyEnergies_sorted = sorted(enemyEnergies)
        n = len(enemyEnergies)
        points = 0
        i = 0
        j = n - 1
        
        while i <= j:
            if currentEnergy >= enemyEnergies_sorted[i]:
                currentEnergy -= enemyEnergies_sorted[i]
                points += 1
                i += 1
            elif points > 0 and j > i:
                currentEnergy += enemyEnergies_sorted[j]
                points -= 1
                j -= 1
            else:
                break
        
        return points
```",Y,
find-polygon-with-the-largest-perimeter,Find Polygon With the Largest Perimeter,"```python
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()
        total = sum(nums)
        for i in range(len(nums) - 1, 1, -1):
            if total - nums[i] > nums[i]:
                return total
            total -= nums[i]
        return -1
```",Y,
maximum-square-area-by-removing-fences-from-a-field,Maximum Square Area by Removing Fences From a Field,"```python
from typing import List

class Solution:
    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:
        hFences = [1] + hFences + [m]
        vFences = [1] + vFences + [n]
        
        h_set = set()
        for i in range(len(hFences)):
            for j in range(i + 1, len(hFences)):
                h_set.add(abs(hFences[j] - hFences[i]))
        
        v_set = set()
        for i in range(len(vFences)):
            for j in range(i + 1, len(vFences)):
                v_set.add(abs(vFences[j] - vFences[i]))
        
        common = h_set & v_set
        if not common:
            return -1
        max_side = max(common)
        return (max_side * max_side) % (10**9 + 7)
```",Y,
minimum-number-of-operations-to-make-array-xor-equal-to-k,Minimum Number of Operations to Make Array XOR Equal to K,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        xor = 0
        for num in nums:
            xor ^= num
        diff = xor ^ k
        return bin(diff).count('1')
```",Y,
find-beautiful-indices-in-the-given-array-i,Find Beautiful Indices in the Given Array I,"```python
class Solution:
    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:
        len_a = len(a)
        len_b = len(b)
        a_indices = []
        b_indices = []
        
        for i in range(len(s) - len_a + 1):
            if s[i:i+len_a] == a:
                a_indices.append(i)
        
        for j in range(len(s) - len_b + 1):
            if s[j:j+len_b] == b:
                b_indices.append(j)
        
        beautiful = []
        if not b_indices:
            return beautiful
        
        for i in a_indices:
            left = i - k
            right = i + k
            
            low = 0
            high = len(b_indices) - 1
            found = False
            while low <= high:
                mid = (low + high) // 2
                j = b_indices[mid]
                if left <= j <= right:
                    found = True
                    break
                elif j < left:
                    low = mid + 1
                else:
                    high = mid - 1
            if found:
                beautiful.append(i)
        
        return beautiful
```",Y,
minimize-length-of-array-using-operations,Minimize Length of Array Using Operations,"```python
from typing import List

class Solution:
    def minimumArrayLength(self, nums: List[int]) -> int:
        min_num = min(nums)
        for num in nums:
            if num % min_num != 0:
                return 1
        return (nums.count(min_num) + 1) // 2
```",Y,
divide-array-into-arrays-with-max-difference,Divide Array Into Arrays With Max Difference,"```python
from typing import List

class Solution:
    def divideArray(self, nums: List[int], k: int) -> List[List[int]]:
        nums.sort()
        result = []
        n = len(nums)
        for i in range(0, n, 3):
            if i + 2 >= n:
                return []
            a, b, c = nums[i], nums[i+1], nums[i+2]
            if c - a > k:
                return []
            result.append([a, b, c])
        return result
```",Y,
maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k,Maximum Number That Sum of the Prices Is Less Than or Equal to K,"```python
class Solution:
    def findMaximumNumber(self, k: int, x: int) -> int:
        left = 1
        right = 1 << 60
        
        def calculate_accumulated_price(num):
            total = 0
            for i in range(x, 60, x):
                divisor = 1 << i
                full_cycles = num // divisor
                remainder = num % divisor
                count = full_cycles * (1 << (i - 1))
                count += max(0, remainder - (1 << (i - 1)) + 1)
                total += count
            return total
        
        best = 0
        while left <= right:
            mid = (left + right) // 2
            price = calculate_accumulated_price(mid)
            if price <= k:
                best = mid
                left = mid + 1
            else:
                right = mid - 1
        return best
```",Y,
minimum-number-of-operations-to-make-x-and-y-equal,Minimum Number of Operations to Make X and Y Equal,"```python
from collections import deque

class Solution:
    def minimumOperationsToMakeEqual(self, x: int, y: int) -> int:
        if x == y:
            return 0
        
        visited = set()
        queue = deque()
        queue.append((x, 0))
        visited.add(x)
        
        while queue:
            current, steps = queue.popleft()
            
            if current == y:
                return steps
            
            next_steps = steps + 1
            candidates = []
            
            if current % 11 == 0:
                candidates.append(current // 11)
            if current % 5 == 0:
                candidates.append(current // 5)
            candidates.append(current - 1)
            candidates.append(current + 1)
            
            for num in candidates:
                if num == y:
                    return next_steps
                if num > 0 and num not in visited:
                    if num <= 10000 + 100:  # Adding a buffer to handle possible +1 operations
                        visited.add(num)
                        queue.append((num, next_steps))
        
        return -1
```",Y,
minimum-cost-to-convert-string-i,Minimum Cost to Convert String I,"```python
import heapq
from typing import List

class Solution:
    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        graph = {}
        nodes = set()
        for o, c, co in zip(original, changed, cost):
            if o not in graph:
                graph[o] = {}
            if c not in graph[o] or graph[o][c] > co:
                graph[o][c] = co
            nodes.add(o)
            nodes.add(c)
        
        dist = {}
        for node in nodes:
            dist[node] = {}
            heap = []
            heapq.heappush(heap, (0, node))
            while heap:
                current_dist, u = heapq.heappop(heap)
                if u in dist[node] and current_dist >= dist[node][u]:
                    continue
                dist[node][u] = current_dist
                if u in graph:
                    for v in graph[u]:
                        new_dist = current_dist + graph[u][v]
                        if v not in dist[node] or new_dist < dist[node].get(v, float('inf')):
                            heapq.heappush(heap, (new_dist, v))
        
        total_cost = 0
        for s_char, t_char in zip(source, target):
            if s_char == t_char:
                continue
            if s_char not in dist or t_char not in dist[s_char]:
                return -1
            total_cost += dist[s_char][t_char]
        
        return total_cost
```",Y,
double-modular-exponentiation,Double Modular Exponentiation,"```python
class Solution:
    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:
        result = []
        for i, (a, b, c, m) in enumerate(variables):
            if ((pow(a, b, 10) ** c) % m == target:
                result.append(i)
        return result
```",Y,
minimum-number-of-coins-to-be-added,Minimum Number of Coins to be Added,"```python
class Solution:
    def minimumAddedCoins(self, coins: List[int], target: int) -> int:
        coins.sort()
        res = 0
        current_max = 0
        i = 0
        n = len(coins)
        
        while current_max < target:
            if i < n and coins[i] <= current_max + 1:
                current_max += coins[i]
                i += 1
            else:
                res += 1
                current_max += current_max + 1
        
        return res
```",Y,
remove-adjacent-almost-equal-characters,Remove Adjacent Almost-Equal Characters,"```python
class Solution:
    def removeAlmostEqualCharacters(self, word: str) -> int:
        n = len(word)
        if n == 1:
            return 0
        res = 0
        i = 1
        while i < n:
            if abs(ord(word[i]) - ord(word[i-1])) <= 1:
                res += 1
                i += 2  # skip the next character to prevent overlapping
            else:
                i += 1
        return res
```",Y,
minimum-cost-to-make-array-equalindromic,Minimum Cost to Make Array Equalindromic,"```python
class Solution:
    def minimumCost(self, nums: List[int]) -> int:
        def is_palindrome(x):
            s = str(x)
            return s == s[::-1]
        
        nums_sorted = sorted(nums)
        n = len(nums_sorted)
        median_candidates = []
        
        median = nums_sorted[n // 2]
        
        candidates = set()
        for x in [median, median + 1, median - 1]:
            if x > 0:
                candidates.add(x)
        
        for delta in range(-100, 101):
            x = median + delta
            if x > 0:
                candidates.add(x)
        
        palindromes = [x for x in candidates if is_palindrome(x)]
        
        if not palindromes:
            return 0
        
        min_cost = float('inf')
        for y in palindromes:
            total_cost = sum(abs(num - y) for num in nums_sorted)
            if total_cost < min_cost:
                min_cost = total_cost
        
        return min_cost
```",Y,
maximum-size-of-a-set-after-removals,Maximum Size of a Set After Removals,"```python
from typing import List

class Solution:
    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        k = n // 2
        set1 = set(nums1)
        set2 = set(nums2)
        common = set1 & set2
        only1 = set1 - set2
        only2 = set2 - set1
        
        max_common = min(len(common), k * 2 - len(only1) - len(only2))
        if max_common < 0:
            max_common = 0
        
        return min(len(only1) + len(only2) + max_common, 2 * k)
```",Y,
length-of-longest-subarray-with-at-most-k-frequency,Length of Longest Subarray With at Most K Frequency,"```python
from typing import List
from collections import defaultdict

class Solution:
    def maxSubarrayLength(self, nums: List[int], k: int) -> int:
        freq = defaultdict(int)
        left = 0
        max_len = 0
        
        for right in range(len(nums)):
            freq[nums[right]] += 1
            
            while freq[nums[right]] > k:
                freq[nums[left]] -= 1
                left += 1
            
            max_len = max(max_len, right - left + 1)
        
        return max_len
```",Y,
make-lexicographically-smallest-array-by-swapping-elements,Make Lexicographically Smallest Array by Swapping Elements,"```python
from typing import List

class Solution:
    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:
        n = len(nums)
        indices = list(range(n))
        indices.sort(key=lambda i: nums[i])
        sorted_nums = [nums[i] for i in indices]
        
        groups = []
        current_group = [indices[0]]
        
        for i in range(1, n):
            if sorted_nums[i] - sorted_nums[i-1] <= limit:
                current_group.append(indices[i])
            else:
                groups.append(current_group)
                current_group = [indices[i]]
        groups.append(current_group)
        
        for group in groups:
            group.sort()
        
        res = [0] * n
        for group in groups:
            sorted_values = sorted([nums[i] for i in group])
            for idx, val in zip(sorted(group), sorted_values):
                res[idx] = val
        
        return res
```",Y,
maximize-area-of-square-hole-in-grid,Maximize Area of Square Hole in Grid,"```python
from typing import List

class Solution:
    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:
        def get_max_consecutive(bars):
            if not bars:
                return 0
            bars = sorted(bars)
            max_len = current = 1
            for i in range(1, len(bars)):
                if bars[i] == bars[i-1] + 1:
                    current += 1
                    max_len = max(max_len, current)
                else:
                    current = 1
            return max_len + 1
        
        h_max = get_max_consecutive(hBars)
        v_max = get_max_consecutive(vBars)
        side = min(h_max, v_max)
        return side * side
```",Y,
count-subarrays-where-max-element-appears-at-least-k-times,Count Subarrays Where Max Element Appears at Least K Times,"```python
from typing import List

class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        max_num = max(nums)
        max_indices = [i for i, num in enumerate(nums) if num == max_num]
        res = 0
        left = 0
        n = len(nums)
        
        for right in range(len(max_indices)):
            if right - left + 1 >= k:
                last_pos = max_indices[right]
                res += (max_indices[left] + 1) * (n - last_pos)
                left += 1
        
        return res
```",Y,
count-beautiful-substrings-i,Count Beautiful Substrings I,"```python
class Solution:
    def beautifulSubstrings(self, s: str, k: int) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        n = len(s)
        count = 0
        for i in range(n):
            v = 0
            c = 0
            for j in range(i, n):
                if s[j] in vowels:
                    v += 1
                else:
                    c += 1
                if v == c and (v * c) % k == 0:
                    count += 1
        return count
```",Y,
minimum-number-of-coins-for-fruits,Minimum Number of Coins for Fruits,"```python
from typing import List

class Solution:
    def minimumCoins(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [float('inf')] * (n + 1)
        dp[n] = 0  # base case: no cost after last fruit
        
        for i in range(n - 1, -1, -1):
            max_free = i + 1  # i is 0-based, next i fruits means up to i+1 (0-based)
            min_cost = float('inf')
            for j in range(i + 1, min(i + 1 + i + 1, n + 1)):
                if dp[j] < min_cost:
                    min_cost = dp[j]
            dp[i] = prices[i] + min_cost
        
        return dp[0]
```",Y,
high-access-employees,High-Access Employees,"```python
from typing import List

class Solution:
    def findHighAccessEmployees(self, access_times: List[List[str]]) -> List[str]:
        from collections import defaultdict

        employee_times = defaultdict(list)
        
        for name, time in access_times:
            hours = int(time[:2])
            minutes = int(time[2:])
            total_minutes = hours * 60 + minutes
            employee_times[name].append(total_minutes)
        
        high_access = []
        
        for name in employee_times:
            times = sorted(employee_times[name])
            n = len(times)
            found = False
            for i in range(n - 2):
                if times[i+2] - times[i] < 60:
                    found = True
                    break
            if found:
                high_access.append(name)
        
        return high_access
```",Y,
distribute-candies-among-children-ii,Distribute Candies Among Children II,"```python
class Solution:
    def distributeCandies(self, n: int, limit: int) -> int:
        def count_ways(x):
            if x < 0:
                return 0
            return (x + 2) * (x + 1) // 2
        
        total = count_ways(n)
        a = count_ways(n - (limit + 1) * 3)
        b = count_ways(n - 2 * (limit + 1)) * 3
        c = count_ways(n - 3 * (limit + 1))
        return total - a + b - c
```",Y,
number-of-strings-which-can-be-rearranged-to-contain-substring,Number of Strings Which Can Be Rearranged to Contain Substring,"```python
class Solution:
    def stringCount(self, n: int) -> int:
        MOD = 10**9 + 7
        if n < 4:
            return 0
        
        total = pow(26, n, MOD)
        
        
        a = pow(25, n, MOD)
        b = pow(25, n, MOD)
        c = (pow(25, n, MOD) + n * pow(25, n - 1, MOD)) % MOD
        
        ab = pow(24, n, MOD)  # missing both 'l' and 't'
        ac = (pow(25, n, MOD) - pow(24, n, MOD) + (n * pow(24, n - 1, MOD)) % MOD  # missing 'l' and at most one 'e'
        ac = (pow(25, n, MOD) + n * pow(24, n - 1, MOD)) % MOD  # Simplified, but needs correction
        bc = (pow(25, n, MOD) + n * pow(24, n - 1, MOD)) % MOD  # missing 't' and at most one 'e'
        abc = (pow(24, n, MOD) + n * pow(23, n - 1, MOD)) % MOD  # missing 'l', 't', and at most one 'e'
        
        union = (a + b + c - ab - ac - bc + abc) % MOD
        
        result = (total - union) % MOD
        return result
```",Y,
separate-black-and-white-balls,Separate Black and White Balls,"```python
class Solution:
    def minimumSteps(self, s: str) -> int:
        steps = 0
        black_pos = 0  # tracks the position where the next black ball should be placed
        
        for i, char in enumerate(s):
            if char == '1':
                steps += i - black_pos
                black_pos += 1
        
        return steps
```",Y,
maximum-xor-product,Maximum Xor Product,"```python
class Solution:
    def maximumXorProduct(self, a: int, b: int, n: int) -> int:
        MOD = 10**9 + 7
        x = 0
        for k in range(n-1, -1, -1):
            mask = 1 << k
            a_bit = (a & mask) != 0
            b_bit = (b & mask) != 0
            if a_bit == b_bit:
                x |= mask
            else:
                current_a = a ^ x
                current_b = b ^ x
                if (current_a < current_b) == (a_bit < b_bit):
                    x |= mask
        return ((a ^ x) * (b ^ x)) % MOD
```",Y,
maximum-score-after-applying-operations-on-a-tree,Maximum Score After Applying Operations on a Tree,"```python
from typing import List

class Solution:
    def maximumScoreAfterOperations(self, edges: List[List[int]], values: List[int]) -> int:
        n = len(values)
        tree = [[] for _ in range(n)]
        for a, b in edges:
            tree[a].append(b)
            tree[b].append(a)
        
        parent = [-1] * n
        stack = [(0, False)]
        order = []
        
        while stack:
            node, visited = stack.pop()
            if visited:
                order.append(node)
                continue
            stack.append((node, True))
            for neighbor in tree[node]:
                if neighbor != parent[node]:
                    parent[neighbor] = node
                    stack.append((neighbor, False))
        
        dp_take = [0] * n  # max score if we take this node
        dp_notake = [0] * n  # max score if we don't take this node
        
        for node in order:
            if node != 0 and len(tree[node]) == 1:  # leaf node (except root)
                dp_take[node] = values[node]
                dp_notake[node] = 0
            else:
                sum_take_children = 0
                sum_notake_children = 0
                for child in tree[node]:
                    if child != parent[node]:
                        sum_take_children += dp_take[child]
                        sum_notake_children += dp_notake[child]
                dp_take[node] = values[node] + sum_take_children
                if node == 0:
                    dp_notake[node] = sum_notake_children
                else:
                    min_diff = float('inf')
                    total = 0
                    has_child = False
                    for child in tree[node]:
                        if child != parent[node]:
                            has_child = True
                            diff = dp_notake[child] - dp_take[child]
                            min_diff = min(min_diff, diff)
                            total += dp_take[child]
                    if has_child:
                        dp_notake[node] = total + min_diff
                    else:
                        dp_notake[node] = 0
        
        return max(dp_take[0], dp_notake[0])
```",Y,
minimum-operations-to-maximize-last-elements-in-arrays,Minimum Operations to Maximize Last Elements in Arrays,"```python
from typing import List

class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        case1_possible = True
        case1_swaps = 0
        max1 = nums1[-1]
        max2 = nums2[-1]
        
        for i in range(n - 1):
            if nums1[i] > max1 or nums2[i] > max2:
                if nums2[i] > max1 or nums1[i] > max2:
                    case1_possible = False
                    break
                case1_swaps += 1
        
        case2_possible = True
        case2_swaps = 1
        max1_swapped = nums2[-1]
        max2_swapped = nums1[-1]
        
        for i in range(n - 1):
            if nums1[i] > max1_swapped or nums2[i] > max2_swapped:
                if nums2[i] > max1_swapped or nums1[i] > max2_swapped:
                    case2_possible = False
                    break
                case2_swaps += 1
        
        if case1_possible and case2_possible:
            return min(case1_swaps, case2_swaps)
        elif case1_possible:
            return case1_swaps
        elif case2_possible:
            return case2_swaps
        else:
            return -1
```",Y,
find-champion-ii,Find Champion II,"```python
from typing import List

class Solution:
    def findChampion(self, n: int, edges: List[List[int]]) -> int:
        in_degree = [0] * n
        for u, v in edges:
            in_degree[v] += 1
        
        champions = []
        for team in range(n):
            if in_degree[team] == 0:
                champions.append(team)
        
        if len(champions) == 1:
            return champions[0]
        else:
            return -1
```",Y,
minimum-sum-of-mountain-triplets-ii,Minimum Sum of Mountain Triplets II,"```python
class Solution:
    def minimumSum(self, nums: List[int]) -> int:
        n = len(nums)
        left_min = [float('inf')] * n
        right_min = [float('inf')] * n
        
        min_so_far = nums[0]
        for i in range(1, n):
            left_min[i] = min_so_far
            if nums[i] < min_so_far:
                min_so_far = nums[i]
        
        min_so_far = nums[-1]
        for i in range(n-2, -1, -1):
            right_min[i] = min_so_far
            if nums[i] < min_so_far:
                min_so_far = nums[i]
        
        min_sum = float('inf')
        for j in range(1, n-1):
            if left_min[j] < nums[j] and right_min[j] < nums[j]:
                current_sum = left_min[j] + nums[j] + right_min[j]
                if current_sum < min_sum:
                    min_sum = current_sum
        
        return min_sum if min_sum != float('inf') else -1
```",Y,
minimum-increment-operations-to-make-array-beautiful,Minimum Increment Operations to Make Array Beautiful,"```python
class Solution:
    def minIncrementOperations(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [0] * n
        
        for i in range(n):
            if i < 3:
                dp[i] = max(0, k - nums[i])
            else:
                dp[i] = max(0, k - nums[i]) + min(dp[i-1], dp[i-2], dp[i-3])
        
        return min(dp[-1], dp[-2], dp[-3]) if n >=3 else 0
```",Y,
minimum-number-of-changes-to-make-binary-string-beautiful,Minimum Number of Changes to Make Binary String Beautiful,"```python
class Solution:
    def minChanges(self, s: str) -> int:
        changes = 0
        for i in range(0, len(s), 2):
            if s[i] != s[i+1]:
                changes += 1
        return changes
```",Y,
minimum-equal-sum-of-two-arrays-after-replacing-zeros,Minimum Equal Sum of Two Arrays After Replacing Zeros,"```python
from typing import List

class Solution:
    def minSum(self, nums1: List[int], nums2: List[int]) -> int:
        sum1 = sum(nums1)
        sum2 = sum(nums2)
        zero1 = nums1.count(0)
        zero2 = nums2.count(0)
        
        min_sum1 = sum1 + zero1
        min_sum2 = sum2 + zero2
        
        if zero1 == 0 and zero2 == 0:
            return sum1 if sum1 == sum2 else -1
        elif zero1 == 0:
            if sum1 < min_sum2:
                return -1
            else:
                return sum1
        elif zero2 == 0:
            if sum2 < min_sum1:
                return -1
            else:
                return sum2
        else:
            return max(min_sum1, min_sum2)
```",Y,
find-indices-with-index-and-value-difference-ii,Find Indices With Index and Value Difference II,"```python
from typing import List

class Solution:
    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:
        n = len(nums)
        for i in range(n):
            for j in range(max(0, i - indexDifference), min(n, i + indexDifference + 1)):
                if abs(nums[i] - nums[j]) >= valueDifference and abs(i - j) >= indexDifference:
                    return [i, j]
        return [-1, -1]
```",Y,
minimum-number-of-groups-to-create-a-valid-assignment,Minimum Number of Groups to Create a Valid Assignment,"```python
from collections import Counter
from typing import List

class Solution:
    def minGroupsForValidAssignment(self, balls: List[int]) -> int:
        freq = Counter(balls)
        counts = list(freq.values())
        
        min_k = min(counts)
        
        for k in range(min_k, 0, -1):
            total = 0
            for count in counts:
                groups = (count + k) // (k + 1)
                if groups * k > count:
                    total = 0
                    break
                total += groups
            if total > 0:
                return total
        
        return len(counts)
```",Y,
maximum-value-of-an-ordered-triplet-ii,Maximum Value of an Ordered Triplet II,"```python
from typing import List

class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        max_i_minus_j = 0
        max_i = nums[0]
        res = 0
        
        for j in range(1, len(nums)):
            res = max(res, max_i_minus_j * nums[j])
            max_i_minus_j = max(max_i_minus_j, max_i - nums[j])
            max_i = max(max_i, nums[j])
        
        return res if res > 0 else 0
```",Y,
minimum-processing-time,Minimum Processing Time,"```python
from typing import List

class Solution:
    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:
        processorTime.sort()
        tasks.sort(reverse=True)
        max_time = 0
        for i in range(len(processorTime)):
            start_time = processorTime[i]
            current_max = start_time + tasks[4*i]
            if current_max > max_time:
                max_time = current_max
            current_max = start_time + tasks[4*i + 1]
            if current_max > max_time:
                max_time = current_max
            current_max = start_time + tasks[4*i + 2]
            if current_max > max_time:
                max_time = current_max
            current_max = start_time + tasks[4*i + 3]
            if current_max > max_time:
                max_time = current_max
        return max_time
```",Y,
shortest-and-lexicographically-smallest-beautiful-string,Shortest and Lexicographically Smallest Beautiful String,"```python
class Solution:
    def shortestBeautifulSubstring(self, s: str, k: int) -> str:
        n = len(s)
        min_len = float('inf')
        result = """"
        
        for i in range(n):
            count = 0
            for j in range(i, n):
                if s[j] == '1':
                    count += 1
                    if count == k:
                        current_len = j - i + 1
                        if current_len < min_len:
                            min_len = current_len
                            result = s[i:j+1]
                        elif current_len == min_len:
                            if s[i:j+1] < result:
                                result = s[i:j+1]
                        break
        return result
```",Y,
longest-unequal-adjacent-groups-subsequence-ii,Longest Unequal Adjacent Groups Subsequence II,"```python
from typing import List

class Solution:
    def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:
        n = len(words)
        dp = [1] * n
        prev = [-1] * n
        
        for i in range(n):
            for j in range(i):
                if groups[i] != groups[j] and len(words[i]) == len(words[j]):
                    hamming = sum(1 for a, b in zip(words[i], words[j]) if a != b)
                    if hamming == 1 and dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
                        prev[i] = j
        
        max_len = max(dp)
        if max_len == 1:
            return [words[0]]
        
        idx = dp.index(max_len)
        res = []
        while idx != -1:
            res.append(words[idx])
            idx = prev[idx]
        
        return res[::-1]
```",Y,
minimum-size-subarray-in-infinite-array,Minimum Size Subarray in Infinite Array,"```python
from typing import List

class Solution:
    def minSizeSubarray(self, nums: List[int], target: int) -> int:
        total_sum = sum(nums)
        n = len(nums)
        min_len = float('inf')
        
        k = target // total_sum
        remaining = target % total_sum
        
        if remaining == 0:
            return k * n
        
        candidates = [remaining]
        if k > 0:
            candidates.append(remaining + total_sum)
        
        extended_nums = nums + nums
        prefix_sum = [0] * (2 * n + 1)
        for i in range(2 * n):
            prefix_sum[i+1] = prefix_sum[i] + extended_nums[i]
        
        from collections import defaultdict
        sum_indices = defaultdict(list)
        for idx, s in enumerate(prefix_sum):
            sum_indices[s].append(idx)
        
        for candidate in candidates:
            if candidate < 0:
                continue
            for i in range(1, 2 * n + 1):
                needed = prefix_sum[i] - candidate
                if needed in sum_indices:
                    for j in sum_indices[needed]:
                        if j < i and (i - j) <= 2 * n:
                            min_len = min(min_len, i - j)
        
        if min_len == float('inf'):
            return -1
        else:
            return k * n + min_len if (remaining + total_sum) in candidates and min_len == (remaining + total_sum) else min_len
```",Y,
beautiful-towers-i,Beautiful Towers I,"```python
from typing import List

class Solution:
    def maximumSumOfHeights(self, heights: List[int]) -> int:
        n = len(heights)
        max_sum = 0
        
        for peak in range(n):
            current_sum = 0
            left = peak
            current_height = heights[peak]
            
            for i in range(peak, -1, -1):
                if heights[i] < current_height:
                    current_height = heights[i]
                current_sum += current_height
            
            current_height = heights[peak]
            for i in range(peak + 1, n):
                if heights[i] < current_height:
                    current_height = heights[i]
                current_sum += current_height
            
            if current_sum > max_sum:
                max_sum = current_sum
        
        return max_sum
```",Y,
beautiful-towers-ii,Beautiful Towers II,"```python
class Solution:
    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:
        n = len(maxHeights)
        left = [0] * n
        stack = []
        total = 0
        
        for i in range(n):
            while stack and maxHeights[i] < maxHeights[stack[-1]]:
                stack.pop()
            if stack:
                j = stack[-1]
                left[i] = left[j] + maxHeights[i] * (i - j)
            else:
                left[i] = maxHeights[i] * (i + 1)
            stack.append(i)
        
        right = [0] * n
        stack = []
        max_sum = 0
        
        for i in range(n-1, -1, -1):
            while stack and maxHeights[i] < maxHeights[stack[-1]]:
                stack.pop()
            if stack:
                j = stack[-1]
                right[i] = right[j] + maxHeights[i] * (j - i)
            else:
                right[i] = maxHeights[i] * (n - i)
            stack.append(i)
            current_sum = left[i] + right[i] - maxHeights[i]
            if current_sum > max_sum:
                max_sum = current_sum
        
        return max_sum
```",Y,
length-of-the-longest-subsequence-that-sums-to-target,Length of the Longest Subsequence That Sums to Target,"```python
from typing import List

class Solution:
    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
        dp = [-1] * (target + 1)
        dp[0] = 0
        for num in nums:
            for t in range(target, num - 1, -1):
                if dp[t - num] != -1:
                    if dp[t] < dp[t - num] + 1:
                        dp[t] = dp[t - num] + 1
        return dp[target]
```",Y,
happy-students,Happy Students,"```python
class Solution:
    def countWays(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        res = 0
        
        if nums[0] > 0:
            res += 1
        
        for i in range(n):
            k = i + 1
            if k > nums[i]:
                if (i == n - 1) or (k < nums[i + 1]):
                    res += 1
        
        if n > nums[-1]:
            res += 1
        
        return res
```",Y,
maximum-number-of-alloys,Maximum Number of Alloys,"```python
from typing import List

class Solution:
    def maxNumberOfAlloys(self, n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:
        max_alloys = 0
        
        for machine in composition:
            left = 0
            right = budget + max(stock)  # Upper bound
            
            best = 0
            while left <= right:
                mid = (left + right) // 2
                total_cost = 0
                for i in range(n):
                    required = machine[i] * mid
                    needed = max(0, required - stock[i])
                    total_cost += needed * cost[i]
                    if total_cost > budget:
                        break
                
                if total_cost <= budget:
                    best = mid
                    left = mid + 1
                else:
                    right = mid - 1
            
            if best > max_alloys:
                max_alloys = best
        
        return max_alloys
```",Y,
minimum-number-of-operations-to-make-array-empty,Minimum Number of Operations to Make Array Empty,"```python
from collections import defaultdict
from typing import List

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for num in nums:
            freq[num] += 1
        
        operations = 0
        for count in freq.values():
            if count == 1:
                return -1
            operations += count // 3
            if count % 3 != 0:
                operations += 1
        return operations
```",Y,
minimum-moves-to-spread-stones-over-grid,Minimum Moves to Spread Stones Over Grid,"```python
from itertools import permutations

class Solution:
    def minimumMoves(self, grid: List[List[int]]) -> int:
        sources = []
        targets = []
        for i in range(3):
            for j in range(3):
                if grid[i][j] > 1:
                    for _ in range(grid[i][j] - 1):
                        sources.append((i, j))
                elif grid[i][j] == 0:
                    targets.append((i, j))
        
        min_moves = float('inf')
        for target_perm in permutations(targets):
            total = 0
            for (s_i, s_j), (t_i, t_j) in zip(sources, target_perm):
                total += abs(s_i - t_i) + abs(s_j - t_j)
            if total < min_moves:
                min_moves = total
        return min_moves
```",Y,
minimum-array-length-after-pair-removals,Minimum Array Length After Pair Removals,"```python
from typing import List

class Solution:
    def minLengthAfterRemovals(self, nums: List[int]) -> int:
        n = len(nums)
        left = 0
        right = (n + 1) // 2
        count = 0
        
        while right < n:
            if nums[left] < nums[right]:
                count += 1
                left += 1
            right += 1
        
        return n - 2 * count
```",Y,
split-array-into-maximum-number-of-subarrays,Split Array Into Maximum Number of Subarrays,"```python
from typing import List

class Solution:
    def maxSubarrays(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        total_and = (1 << 30) - 1  # Initialize with all bits set (for 32-bit integers, but 30 is sufficient for constraints)
        for num in nums:
            total_and &= num
        
        if total_and != 0:
            return 1
        
        res = 0
        current_and = (1 << 30) - 1
        for num in nums:
            current_and &= num
            if current_and == 0:
                res += 1
                current_and = (1 << 30) - 1
        
        return res
```",Y,
determine-if-a-cell-is-reachable-at-a-given-time,Determine if a Cell Is Reachable at a Given Time,"```python
class Solution:
    def isReachableAtTime(self, sx: int, sy: int, fx: int, fy: int, t: int) -> bool:
        if sx == fx and sy == fy:
            return t != 1
        dx = abs(fx - sx)
        dy = abs(fy - sy)
        min_time = max(dx, dy)
        return t >= min_time
```",Y,
minimum-operations-to-make-a-special-number,Minimum Operations to Make a Special Number,"```python
class Solution:
    def minimumOperations(self, num: str) -> int:
        n = len(num)
        min_ops = float('inf')
        
        patterns = ['00', '25', '50', '75']
        
        for pattern in patterns:
            second_char = pattern[1]
            first_char = pattern[0]
            pos2 = -1
            pos1 = -1
            
            for i in range(n-1, -1, -1):
                if num[i] == second_char:
                    pos2 = i
                    break
            
            if pos2 == -1:
                continue
            
            for i in range(pos2 - 1, -1, -1):
                if num[i] == first_char:
                    pos1 = i
                    break
            
            if pos1 == -1:
                continue
            
            deletions = (n - 1 - pos2) + (pos2 - 1 - pos1)
            if deletions < min_ops:
                min_ops = deletions
        
        zero_pos = num.rfind('0')
        if zero_pos != -1:
            deletions = n - 1
            if deletions < min_ops:
                min_ops = deletions
        
        return min_ops if min_ops != float('inf') else n
```",Y,
apply-operations-to-make-two-strings-equal,Apply Operations to Make Two Strings Equal,"```python
class Solution:
    def minOperations(self, s1: str, s2: str, x: int) -> int:
        n = len(s1)
        diff_indices = [i for i in range(n) if s1[i] != s2[i]]
        m = len(diff_indices)
        if m % 2 != 0:
            return -1
        
        if m == 0:
            return 0
        
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        for i in range(1, m + 1):
            if i % 2 == 0:
                dp[i] = dp[i - 1]  # skip, handled by previous
            else:
                if i >= 1:
                    cost = diff_indices[i-1] - diff_indices[i-2]
                    dp[i] = min(dp[i], dp[i-2] + cost)
                dp[i] = min(dp[i], dp[i-1] + x / 2)  # x is total for pair, so x/2 per element
        
        return int(dp[m]) if dp[m] != float('inf') else -1
```",Y,
construct-product-matrix,Construct Product Matrix,"```python
from typing import List

class Solution:
    def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:
        n = len(grid)
        m = len(grid[0]) if n > 0 else 0
        MOD = 12345
        
        total_product = 1
        zero_count = 0
        
        for row in grid:
            for num in row:
                if num == 0:
                    zero_count += 1
                else:
                    total_product = (total_product * num) % MOD
        
        result = [[0 for _ in range(m)] for _ in range(n)]
        
        for i in range(n):
            for j in range(m):
                if zero_count == 0:
                    val = grid[i][j]
                    if val != 0:
                        product = (total_product * pow(val, MOD - 2, MOD)) % MOD
                    else:
                        product = 0  # shouldn't happen as zero_count is 0
                elif zero_count == 1:
                    if grid[i][j] == 0:
                        product = total_product
                    else:
                        product = 0
                else:
                    product = 0
                result[i][j] = product
        
        return result
```",Y,
find-the-minimum-possible-sum-of-a-beautiful-array,Find the Minimum Possible Sum of a Beautiful Array,"```python
class Solution:
    def minimumPossibleSum(self, n: int, target: int) -> int:
        mod = 10**9 + 7
        m = target // 2
        if n <= m:
            return (n * (n + 1) // 2) % mod
        else:
            return (m * (m + 1) // 2 + (target + (target + (n - m) - 1)) * (n - m) // 2) % mod
```",Y,
make-string-a-subsequence-using-cyclic-increments,Make String a Subsequence Using Cyclic Increments,"```python
class Solution:
    def canMakeSubsequence(self, str1: str, str2: str) -> bool:
        m, n = len(str1), len(str2)
        if n > m:
            return False
        
        i = j = 0
        while i < m and j < n:
            c1 = str1[i]
            c2 = str2[j]
            if c1 == c2 or (ord(c2) - ord(c1)) % 26 == 1:
                j += 1
            i += 1
        
        return j == n
```",Y,
minimum-absolute-difference-between-elements-with-constraint,Minimum Absolute Difference Between Elements With Constraint,"```python
import bisect

class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        min_diff = float('inf')
        sorted_list = []
        
        for i in range(x, len(nums)):
            bisect.insort(sorted_list, nums[i - x])
            pos = bisect.bisect_left(sorted_list, nums[i])
            if pos > 0:
                min_diff = min(min_diff, abs(nums[i] - sorted_list[pos - 1]))
            if pos < len(sorted_list):
                min_diff = min(min_diff, abs(nums[i] - sorted_list[pos]))
            if min_diff == 0:
                return 0
        
        return min_diff
```",Y,
maximize-the-profit-as-the-salesman,Maximize the Profit as the Salesman,"```python
from typing import List

class Solution:
    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:
        offers.sort(key=lambda x: x[1])
        dp = [0] * (n + 1)
        current_offer = 0
        m = len(offers)
        
        for end in range(n):
            dp[end + 1] = dp[end]
            while current_offer < m and offers[current_offer][1] == end:
                start, end_i, gold = offers[current_offer]
                if dp[start] + gold > dp[end + 1]:
                    dp[end + 1] = dp[start] + gold
                current_offer += 1
        return dp[n]
```",Y,
check-if-strings-can-be-made-equal-with-operations-ii,Check if Strings Can be Made Equal With Operations II,"```python
class Solution:
    def checkStrings(self, s1: str, s2: str) -> bool:
        if len(s1) != len(s2):
            return False
        n = len(s1)
        even_s1 = []
        odd_s1 = []
        even_s2 = []
        odd_s2 = []
        for i in range(n):
            if i % 2 == 0:
                even_s1.append(s1[i])
                even_s2.append(s2[i])
            else:
                odd_s1.append(s1[i])
                odd_s2.append(s2[i])
        return sorted(even_s1) == sorted(even_s2) and sorted(odd_s1) == sorted(odd_s2)
```",Y,
maximum-sum-of-almost-unique-subarray,Maximum Sum of Almost Unique Subarray,"```python
from collections import defaultdict
from typing import List

class Solution:
    def maxSum(self, nums: List[int], m: int, k: int) -> int:
        max_sum = 0
        current_sum = 0
        freq = defaultdict(int)
        left = 0
        
        for right in range(len(nums)):
            freq[nums[right]] += 1
            current_sum += nums[right]
            
            if right - left + 1 == k:
                if len(freq) >= m:
                    max_sum = max(max_sum, current_sum)
                current_sum -= nums[left]
                freq[nums[left]] -= 1
                if freq[nums[left]] == 0:
                    del freq[nums[left]]
                left += 1
        
        return max_sum
```",Y,
count-pairs-of-points-with-distance-k,Count Pairs of Points With Distance k,"```python
from collections import defaultdict

class Solution:
    def countPairs(self, coordinates: List[List[int]], k: int) -> int:
        freq = defaultdict(int)
        res = 0
        for x, y in coordinates:
            for a in range(k + 1):
                b = k - a
                x_target = x ^ a
                y_target = y ^ b
                res += freq.get((x_target, y_target), 0)
            freq[(x, y)] += 1
        return res
```",Y,
minimum-seconds-to-equalize-a-circular-array,Minimum Seconds to Equalize a Circular Array,"```python
from collections import defaultdict

class Solution:
    def minimumSeconds(self, nums: List[int]) -> int:
        value_indices = defaultdict(list)
        for i, num in enumerate(nums):
            value_indices[num].append(i)
        
        n = len(nums)
        min_time = float('inf')
        
        for indices in value_indices.values():
            max_gap = 0
            m = len(indices)
            for i in range(m):
                prev = indices[i-1] if i > 0 else indices[-1] - n
                gap = indices[i] - prev - 1
                max_gap = max(max_gap, gap)
            current_time = (max_gap + 1) // 2
            min_time = min(min_time, current_time)
        
        return min_time
```",Y,
check-if-it-is-possible-to-split-array,Check if it is Possible to Split Array,"```python
from typing import List

class Solution:
    def canSplitArray(self, nums: List[int], m: int) -> bool:
        n = len(nums)
        if n <= 2:
            return True
        for i in range(n - 1):
            if nums[i] + nums[i + 1] >= m:
                return True
        return False
```",Y,
count-of-interesting-subarrays,Count of Interesting Subarrays,"```python
from typing import List
from collections import defaultdict

class Solution:
    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:
        prefix_counts = defaultdict(int)
        prefix_counts[0] = 1
        res = 0
        current = 0
        
        for num in nums:
            if num % modulo == k:
                current += 1
            key = current % modulo
            target = (key - k) % modulo
            res += prefix_counts.get(target, 0)
            prefix_counts[key] += 1
        
        return res
```",Y,
find-the-safest-path-in-a-grid,Find the Safest Path in a Grid,"```python
from typing import List
import heapq

class Solution:
    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:
        n = len(grid)
        if grid[0][0] == 1 or grid[n-1][n-1] == 1:
            return 0
        
        dist = [[float('inf')] * n for _ in range(n)]
        q = []
        
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1:
                    dist[i][j] = 0
                    q.append((i, j))
        
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        while q:
            new_q = []
            for i, j in q:
                for di, dj in directions:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < n and 0 <= nj < n and dist[ni][nj] == float('inf'):
                        dist[ni][nj] = dist[i][j] + 1
                        new_q.append((ni, nj))
            q = new_q
        
        left, right = 0, min(dist[0][0], dist[n-1][n-1])
        result = 0
        
        while left <= right:
            mid = (left + right) // 2
            visited = [[False] * n for _ in range(n)]
            stack = [(0, 0)]
            visited[0][0] = True
            found = False
            
            while stack:
                i, j = stack.pop()
                if i == n-1 and j == n-1:
                    found = True
                    break
                for di, dj in directions:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < n and 0 <= nj < n and not visited[ni][nj] and dist[ni][nj] >= mid:
                        visited[ni][nj] = True
                        stack.append((ni, nj))
            
            if found:
                result = mid
                left = mid + 1
            else:
                right = mid - 1
        
        return result
```",Y,
sorting-three-groups,Sorting Three Groups,"```python
from typing import List

class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [[0] * 4 for _ in range(n)]
        
        for j in range(1, 4):
            dp[0][j] = 0 if nums[0] == j else 1
        
        for i in range(1, n):
            for j in range(1, 4):
                min_prev = float('inf')
                for k in range(1, j + 1):
                    if dp[i-1][k] < min_prev:
                        min_prev = dp[i-1][k]
                dp[i][j] = min_prev + (0 if nums[i] == j else 1)
        
        return min(dp[-1][1], dp[-1][2], dp[-1][3])
```",Y,
insert-greatest-common-divisors-in-linked-list,Insert Greatest Common Divisors in Linked List,"```python
class Solution:
    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a
        
        current = head
        while current and current.next:
            a = current.val
            b = current.next.val
            gcd_val = gcd(a, b)
            new_node = ListNode(gcd_val, current.next)
            current.next = new_node
            current = new_node.next
        return head
```",Y,
visit-array-positions-to-maximize-score,Visit Array Positions to Maximize Score,"```python
from typing import List

class Solution:
    def maxScore(self, nums: List[int], x: int) -> int:
        n = len(nums)
        dp_even = -float('inf')
        dp_odd = -float('inf')
        
        if nums[0] % 2 == 0:
            dp_even = nums[0]
        else:
            dp_odd = nums[0]
        
        for i in range(1, n):
            current_num = nums[i]
            if current_num % 2 == 0:
                current_max = max(dp_even + current_num, dp_odd + current_num - x)
                dp_even = max(dp_even, current_max)
            else:
                current_max = max(dp_odd + current_num, dp_even + current_num - x)
                dp_odd = max(dp_odd, current_max)
        
        return max(dp_even, dp_odd)
```",Y,
maximum-beauty-of-an-array-after-applying-operation,Maximum Beauty of an Array After Applying Operation,"```python
from typing import List

class Solution:
    def maximumBeauty(self, nums: List[int], k: int) -> int:
        nums.sort()
        left = 0
        max_len = 0
        for right in range(len(nums)):
            while nums[right] - nums[left] > 2 * k:
                left += 1
            max_len = max(max_len, right - left + 1)
        return max_len
```",Y,
number-of-black-blocks,Number of Black Blocks,"```python
from typing import List
from collections import defaultdict

class Solution:
    def countBlackBlocks(self, m: int, n: int, coordinates: List[List[int]]) -> List[int]:
        block_counts = defaultdict(int)
        black_cells = set((x, y) for x, y in coordinates)
        
        for x, y in black_cells:
            for i in [x-1, x]:
                for j in [y-1, y]:
                    if 0 <= i < m - 1 and 0 <= j < n - 1:
                        count = 0
                        count += (i, j) in black_cells
                        count += (i+1, j) in black_cells
                        count += (i, j+1) in black_cells
                        count += (i+1, j+1) in black_cells
                        block_counts[(i, j)] = count
        
        total_blocks = (m - 1) * (n - 1)
        result = [0] * 5
        result[0] = total_blocks - len(block_counts)
        
        for count in block_counts.values():
            if 1 <= count <=4:
                result[count] += 1
        
        return result
```",Y,
minimum-index-of-a-valid-split,Minimum Index of a Valid Split,"```python
from collections import defaultdict
from typing import List

class Solution:
    def minimumIndex(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        dominant = None
        max_count = 0
        
        for num in nums:
            freq[num] += 1
            if freq[num] > max_count:
                max_count = freq[num]
                dominant = num
        
        total = max_count
        left_count = 0
        
        for i in range(len(nums) - 1):
            if nums[i] == dominant:
                left_count += 1
            right_count = total - left_count
            
            left_len = i + 1
            right_len = len(nums) - left_len
            
            if left_count * 2 > left_len and right_count * 2 > right_len:
                return i
        
        return -1
```",Y,
sort-vowels-in-a-string,Sort Vowels in a String,"```python
class Solution:
    def sortVowels(self, s: str) -> str:
        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}
        vowel_indices = []
        vowel_chars = []
        
        for i, char in enumerate(s):
            if char in vowels:
                vowel_indices.append(i)
                vowel_chars.append(char)
        
        vowel_chars.sort()
        
        s_list = list(s)
        for idx, pos in enumerate(vowel_indices):
            s_list[pos] = vowel_chars[idx]
        
        return ''.join(s_list)
```",Y,
partition-string-into-minimum-beautiful-substrings,Partition String Into Minimum Beautiful Substrings,"```python
class Solution:
    def minimumBeautifulSubstrings(self, s: str) -> int:
        power_of_5 = {1, 5, 25, 125, 625, 3125, 15625}
        n = len(s)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        
        for i in range(1, n + 1):
            for j in range(i):
                if s[j] == '0':
                    continue
                substring = s[j:i]
                num = int(substring, 2)
                if num in power_of_5:
                    if dp[j] + 1 < dp[i]:
                        dp[i] = dp[j] + 1
        
        return dp[n] if dp[n] != float('inf') else -1
```",Y,
ways-to-express-an-integer-as-sum-of-powers,Ways to Express an Integer as Sum of Powers,"```python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 10**9 + 7
        max_num = 1
        while max_num ** x <= n:
            max_num += 1
        max_num -= 1
        
        dp = [0] * (n + 1)
        dp[0] = 1
        
        for num in range(1, max_num + 1):
            power = num ** x
            for i in range(n, power - 1, -1):
                dp[i] = (dp[i] + dp[i - power]) % MOD
        return dp[n]
```",Y,
apply-operations-to-make-all-array-elements-equal-to-zero,Apply Operations to Make All Array Elements Equal to Zero,"```python
from typing import List

class Solution:
    def checkArray(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        diff = [0] * (n + 1)
        current = 0
        
        for i in range(n):
            current += diff[i]
            adjusted = nums[i] - current
            
            if adjusted < 0:
                return False
            
            if adjusted > 0:
                if i + k > n:
                    return False
                current += adjusted
                if i + k < n:
                    diff[i + k] -= adjusted
        
        return True
```",Y,
shortest-string-that-contains-three-strings,Shortest String That Contains Three Strings,"```python
class Solution:
    def minimumString(self, a: str, b: str, c: str) -> str:
        def merge(s1, s2):
            if s2 in s1:
                return s1
            max_overlap = 0
            len_s1 = len(s1)
            len_s2 = len(s2)
            for overlap in range(min(len_s1, len_s2), -1, -1):
                if s1.endswith(s2[:overlap]):
                    max_overlap = overlap
                    break
            return s1 + s2[max_overlap:]
        
        candidates = []
        strings = [a, b, c]
        from itertools import permutations
        for perm in permutations(strings):
            s12 = merge(perm[0], perm[1])
            s123 = merge(s12, perm[2])
            candidates.append(s123)
        
        min_len = min(len(s) for s in candidates)
        min_candidates = [s for s in candidates if len(s) == min_len]
        return min(min_candidates)
```",Y,
prime-pairs-with-target-sum,Prime Pairs With Target Sum,"```python
class Solution:
    def findPrimePairs(self, n: int) -> List[List[int]]:
        if n < 2:
            return []
        
        sieve = [True] * (n + 1)
        sieve[0] = sieve[1] = False
        for i in range(2, int(n ** 0.5) + 1):
            if sieve[i]:
                sieve[i*i::i] = [False] * len(sieve[i*i::i])
        
        primes = [i for i, is_prime in enumerate(sieve) if is_prime]
        prime_set = set(primes)
        result = []
        
        for x in primes:
            y = n - x
            if y < x:
                break
            if y in prime_set:
                result.append([x, y])
        
        return result
```",Y,
largest-element-in-an-array-after-merge-operations,Largest Element in an Array after Merge Operations,"```python
class Solution:
    def maxArrayValue(self, nums: List[int]) -> int:
        stack = []
        for num in reversed(nums):
            if stack and stack[-1] >= num:
                stack[-1] += num
            else:
                stack.append(num)
        return max(stack) if stack else 0
```",Y,
double-a-number-represented-as-a-linked-list,Double a Number Represented as a Linked List,"```python
class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def reverse(node):
            prev = None
            while node:
                next_node = node.next
                node.next = prev
                prev = node
                node = next_node
            return prev
        
        reversed_head = reverse(head)
        carry = 0
        current = reversed_head
        prev = None
        while current:
            new_val = current.val * 2 + carry
            current.val = new_val % 10
            carry = new_val // 10
            prev = current
            current = current.next
        
        if carry > 0:
            prev.next = ListNode(carry)
        
        return reverse(reversed_head)
```",Y,
longest-non-decreasing-subarray-from-two-arrays,Longest Non-decreasing Subarray From Two Arrays,"```python
from typing import List

class Solution:
    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        if n == 0:
            return 0
        
        dp1 = dp2 = 1
        max_len = 1
        
        for i in range(1, n):
            new_dp1 = new_dp2 = 1
            if nums1[i] >= nums1[i-1]:
                new_dp1 = max(new_dp1, dp1 + 1)
            if nums1[i] >= nums2[i-1]:
                new_dp1 = max(new_dp1, dp2 + 1)
            if nums2[i] >= nums1[i-1]:
                new_dp2 = max(new_dp2, dp1 + 1)
            if nums2[i] >= nums2[i-1]:
                new_dp2 = max(new_dp2, dp2 + 1)
            
            dp1, dp2 = new_dp1, new_dp2
            max_len = max(max_len, dp1, dp2)
        
        return max_len
```",Y,
continuous-subarrays,Continuous Subarrays,"```python
from collections import deque

class Solution:
    def continuousSubarrays(self, nums: List[int]) -> int:
        min_deque = deque()
        max_deque = deque()
        left = 0
        res = 0
        
        for right, num in enumerate(nums):
            while min_deque and nums[min_deque[-1]] >= num:
                min_deque.pop()
            min_deque.append(right)
            
            while max_deque and nums[max_deque[-1]] <= num:
                max_deque.pop()
            max_deque.append(right)
            
            while nums[max_deque[0]] - nums[min_deque[0]] > 2:
                left += 1
                while min_deque[0] < left:
                    min_deque.popleft()
                while max_deque[0] < left:
                    max_deque.popleft()
            
            res += right - left + 1
        
        return res
```",Y,
ways-to-split-array-into-good-subarrays,Ways to Split Array Into Good Subarrays,"```python
class Solution:
    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        ones = []
        for i, num in enumerate(nums):
            if num == 1:
                ones.append(i)
        if not ones:
            return 0
        if len(ones) == 1:
            return 1
        res = 1
        for i in range(1, len(ones)):
            res *= (ones[i] - ones[i-1])
            res %= MOD
        return res
```",Y,
count-complete-subarrays-in-an-array,Count Complete Subarrays in an Array,"```python
from typing import List

class Solution:
    def countCompleteSubarrays(self, nums: List[int]) -> int:
        distinct = len(set(nums))
        n = len(nums)
        count = 0
        
        for i in range(n):
            seen = set()
            for j in range(i, n):
                seen.add(nums[j])
                if len(seen) == distinct:
                    count += 1
        
        return count
```",Y,
maximum-number-of-jumps-to-reach-the-last-index,Maximum Number of Jumps to Reach the Last Index,"```python
from typing import List

class Solution:
    def maximumJumps(self, nums: List[int], target: int) -> int:
        n = len(nums)
        dp = [-1] * n
        dp[0] = 0
        
        for i in range(n):
            if dp[i] == -1:
                continue
            for j in range(i + 1, n):
                diff = nums[j] - nums[i]
                if -target <= diff <= target:
                    if dp[j] < dp[i] + 1:
                        dp[j] = dp[i] + 1
        
        return dp[-1] if dp[-1] != -1 else -1
```",Y,
decremental-string-concatenation,Decremental String Concatenation,"```python
class Solution:
    def minimizeConcatenatedLength(self, words: List[str]) -> int:
        if not words:
            return 0
        
        n = len(words)
        first_char = words[0][0]
        last_char = words[0][-1]
        total_len = len(words[0])
        
        dp = {}
        dp[(first_char, last_char)] = total_len
        
        for i in range(1, n):
            current_word = words[i]
            current_first = current_word[0]
            current_last = current_word[-1]
            current_len = len(current_word)
            new_dp = {}
            
            for (prev_first, prev_last), prev_total in dp.items():
                if prev_last == current_first:
                    new_total = prev_total + current_len - 1
                else:
                    new_total = prev_total + current_len
                new_first = prev_first
                new_last = current_last
                key = (new_first, new_last)
                if key in new_dp:
                    if new_total < new_dp[key]:
                        new_dp[key] = new_total
                else:
                    new_dp[key] = new_total
                
                if current_last == prev_first:
                    new_total = prev_total + current_len - 1
                else:
                    new_total = prev_total + current_len
                new_first = current_first
                new_last = prev_last
                key = (new_first, new_last)
                if key in new_dp:
                    if new_total < new_dp[key]:
                        new_dp[key] = new_total
                else:
                    new_dp[key] = new_total
            
            dp = new_dp
        
        return min(dp.values()) if dp else 0
```",Y,
construct-the-longest-new-string,Construct the Longest New String,"```python
class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:
        min_xy = min(x, y)
        if x == y:
            return (x + y + z) * 2
        else:
            return (min_xy * 2 + 1 + z) * 2
```",Y,
special-permutations,Special Permutations,"```python
class Solution:
    def specialPerm(self, nums: List[int]) -> int:
        from functools import lru_cache
        
        n = len(nums)
        MOD = 10**9 + 7
        
        @lru_cache(maxsize=None)
        def dfs(prev, mask):
            if mask == (1 << n) - 1:
                return 1
            total = 0
            for i in range(n):
                if not (mask & (1 << i)):
                    if prev % nums[i] == 0 or nums[i] % prev == 0:
                        total += dfs(nums[i], mask | (1 << i))
                        total %= MOD
            return total
        
        result = 0
        for i in range(n):
            result += dfs(nums[i], 1 << i)
            result %= MOD
        return result
```",Y,
find-the-value-of-the-partition,Find the Value of the Partition,"```python
class Solution:
    def findValueOfPartition(self, nums: List[int]) -> int:
        nums.sort()
        min_diff = float('inf')
        for i in range(1, len(nums)):
            diff = nums[i] - nums[i-1]
            if diff < min_diff:
                min_diff = diff
        return min_diff
```",Y,
sum-of-matrix-after-queries,Sum of Matrix After Queries,"```python
class Solution:
    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:
        row_seen = set()
        col_seen = set()
        total = 0
        row_sum = 0
        col_sum = 0
        for type_i, index_i, val_i in reversed(queries):
            if type_i == 0:  # row operation
                if index_i not in row_seen:
                    row_seen.add(index_i)
                    cnt = n - len(col_seen)
                    total += cnt * val_i
            else:  # column operation
                if index_i not in col_seen:
                    col_seen.add(index_i)
                    cnt = n - len(row_seen)
                    total += cnt * val_i
        return total
```",Y,
minimum-operations-to-make-the-integer-zero,Minimum Operations to Make the Integer Zero,"```python
class Solution:
    def makeTheIntegerZero(self, num1: int, num2: int) -> int:
        for k in range(1, 61):
            target = num1 - k * num2
            if target < 0:
                continue
            bits = bin(target).count('1')
            if bits <= k and target >= k:
                return k
        return -1
```",Y,
relocate-marbles,Relocate Marbles,"```python
from typing import List

class Solution:
    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:
        marble_positions = set(nums)
        for from_pos, to_pos in zip(moveFrom, moveTo):
            if from_pos in marble_positions:
                marble_positions.remove(from_pos)
                marble_positions.add(to_pos)
        return sorted(marble_positions)
```",Y,
count-zero-request-servers,Count Zero Request Servers,"```python
from collections import defaultdict
import bisect

class Solution:
    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:
        server_times = defaultdict(list)
        for server_id, time in logs:
            server_times[server_id].append(time)
        
        for server_id in server_times:
            server_times[server_id].sort()
        
        res = []
        for q in queries:
            start = q - x
            end = q
            count = 0
            for server_id in range(1, n + 1):
                times = server_times.get(server_id, [])
                left = bisect.bisect_left(times, start)
                right = bisect.bisect_right(times, end)
                if left == right:
                    count += 1
            res.append(count)
        return res
```",Y,
find-the-longest-equal-subarray,Find the Longest Equal Subarray,"```python
from collections import defaultdict
from typing import List

class Solution:
    def longestEqualSubarray(self, nums: List[int], k: int) -> int:
        pos_dict = defaultdict(list)
        for idx, num in enumerate(nums):
            pos_dict[num].append(idx)
        
        max_len = 0
        for num in pos_dict:
            indices = pos_dict[num]
            left = 0
            for right in range(len(indices)):
                while (indices[right] - indices[left] + 1) - (right - left + 1) > k:
                    left += 1
                max_len = max(max_len, right - left + 1)
        return max_len
```",Y,
lexicographically-smallest-string-after-substring-operation,Lexicographically Smallest String After Substring Operation,"```python
class Solution:
    def smallestString(self, s: str) -> str:
        s = list(s)
        n = len(s)
        i = 0
        while i < n and s[i] == 'a':
            i += 1
        if i == n:
            s[-1] = 'z'
            return ''.join(s)
        j = i
        while j < n and s[j] != 'a':
            s[j] = chr(ord(s[j]) - 1)
            j += 1
        return ''.join(s)
```",Y,
minimum-cost-to-make-all-characters-equal,Minimum Cost to Make All Characters Equal,"```python
class Solution:
    def minimumCost(self, s: str) -> int:
        n = len(s)
        res = 0
        for i in range(1, n):
            if s[i] != s[i-1]:
                res += min(i, n - i)
        return res
```",Y,
determine-the-minimum-sum-of-a-k-avoiding-array,Determine the Minimum Sum of a k-avoiding Array,"```python
class Solution:
    def minimumSum(self, n: int, k: int) -> int:
        used = set()
        num = 1
        total = 0
        count = 0
        
        while count < n:
            if (k - num) not in used:
                used.add(num)
                total += num
                count += 1
            num += 1
        return total
```",Y,
collecting-chocolates,Collecting Chocolates,"```python
class Solution:
    def minCost(self, nums: List[int], x: int) -> int:
        n = len(nums)
        res = float('inf')
        min_costs = nums.copy()
        
        for rotate in range(n):
            current_cost = sum(min_costs) + rotate * x
            if current_cost < res:
                res = current_cost
            new_min_costs = [0] * n
            for i in range(n):
                new_min_costs[i] = min(min_costs[i], min_costs[(i + 1) % n])
            min_costs = new_min_costs
        
        return res
```",Y,
find-the-punishment-number-of-an-integer,Find the Punishment Number of an Integer,"```python
class Solution:
    def punishmentNumber(self, n: int) -> int:
        def can_partition(s, target):
            if not s and target == 0:
                return True
            if target < 0:
                return False
            for i in range(1, len(s)+1):
                num = int(s[:i])
                if can_partition(s[i:], target - num):
                    return True
            return False
        
        total = 0
        for i in range(1, n+1):
            square = i * i
            if can_partition(str(square), i):
                total += square
        return total
```",Y,
difference-of-number-of-distinct-values-on-diagonals,Difference of Number of Distinct Values on Diagonals,"```python
from typing import List

class Solution:
    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        answer = [[0 for _ in range(n)] for _ in range(m)]
        
        for r in range(m):
            for c in range(n):
                left_above = set()
                i, j = r - 1, c - 1
                while i >= 0 and j >= 0:
                    left_above.add(grid[i][j])
                    i -= 1
                    j -= 1
                
                right_below = set()
                i, j = r + 1, c + 1
                while i < m and j < n:
                    right_below.add(grid[i][j])
                    i += 1
                    j += 1
                
                answer[r][c] = abs(len(left_above) - len(right_below))
        
        return answer
```",Y,
maximum-number-of-moves-in-a-grid,Maximum Number of Moves in a Grid,"```python
from typing import List

class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        dp = [[0] * n for _ in range(m)]
        max_moves = 0
        
        for col in range(n-2, -1, -1):
            for row in range(m):
                current_val = grid[row][col]
                max_next = 0
                for dr in [-1, 0, 1]:
                    next_row = row + dr
                    next_col = col + 1
                    if 0 <= next_row < m and next_col < n and grid[next_row][next_col] > current_val:
                        max_next = max(max_next, dp[next_row][next_col] + 1)
                dp[row][col] = max_next
                if col == 0:
                    max_moves = max(max_moves, dp[row][col])
        
        return max_moves
```",Y,
count-the-number-of-complete-components,Count the Number of Complete Components,"```python
from typing import List

class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        parent = [i for i in range(n)]
        rank = [1] * n
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root == v_root:
                return
            if rank[u_root] > rank[v_root]:
                parent[v_root] = u_root
                rank[u_root] += rank[v_root]
            else:
                parent[u_root] = v_root
                rank[v_root] += rank[u_root]
        
        for u, v in edges:
            union(u, v)
        
        components = {}
        for u in range(n):
            root = find(u)
            if root not in components:
                components[root] = []
            components[root].append(u)
        
        count = 0
        for component in components.values():
            m = len(component)
            required_edges = m * (m - 1) // 2
            actual_edges = 0
            for u, v in edges:
                if u in component and v in component:
                    actual_edges += 1
            if actual_edges == required_edges:
                count += 1
        return count
```",Y,
neighboring-bitwise-xor,Neighboring Bitwise XOR,"```python
from typing import List

class Solution:
    def doesValidArrayExist(self, derived: List[int]) -> bool:
        n = len(derived)
        original0 = 0
        current = original0
        for i in range(n - 1):
            current = derived[i] ^ current
        if (current ^ original0) == derived[-1]:
            return True
        original0 = 1
        current = original0
        for i in range(n - 1):
            current = derived[i] ^ current
        if (current ^ original0) == derived[-1]:
            return True
        return False
```",Y,
movement-of-robots,Movement of Robots,"```python
class Solution:
    def sumDistance(self, nums: List[int], s: str, d: int) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        final_positions = []
        
        for i in range(n):
            direction = s[i]
            if direction == 'R':
                final_positions.append(nums[i] + d)
            else:
                final_positions.append(nums[i] - d)
        
        final_positions.sort()
        prefix = [0] * (n + 1)
        res = 0
        
        for i in range(n):
            prefix[i+1] = prefix[i] + final_positions[i]
        
        for i in range(n):
            res += final_positions[i] * i - prefix[i]
            res %= MOD
        
        return res
```",Y,
find-the-longest-semi-repetitive-substring,Find the Longest Semi-Repetitive Substring,"```python
class Solution:
    def longestSemiRepetitiveSubstring(self, s: str) -> int:
        max_len = 1
        n = len(s)
        for i in range(n):
            count = 0
            for j in range(i + 1, n):
                if s[j] == s[j - 1]:
                    count += 1
                    if count > 1:
                        break
                current_len = j - i + 1
                if current_len > max_len:
                    max_len = current_len
        return max_len
```",Y,
make-costs-of-paths-equal-in-a-binary-tree,Make Costs of Paths Equal in a Binary Tree,"```python
from typing import List

class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:
        res = 0
        for i in range(n // 2 - 1, -1, -1):
            left = 2 * i + 1
            right = 2 * i + 2
            res += abs(cost[left] - cost[right])
            cost[i] += max(cost[left], cost[right])
        return res
```",Y,
number-of-adjacent-elements-with-the-same-color,Number of Adjacent Elements With the Same Color,"```python
from typing import List

class Solution:
    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:
        colors = [0] * n
        res = []
        count = 0
        for idx, color in queries:
            left = idx - 1
            right = idx + 1
            if left >= 0 and colors[left] == colors[idx] and colors[idx] != 0:
                count -= 1
            if right < n and colors[right] == colors[idx] and colors[idx] != 0:
                count -= 1
            colors[idx] = color
            if left >= 0 and colors[left] == colors[idx]:
                count += 1
            if right < n and colors[right] == colors[idx]:
                count += 1
            res.append(count)
        return res
```",Y,
frequency-tracker,Frequency Tracker,"```python
class FrequencyTracker:

    def __init__(self):
        self.number_counts = {}
        self.frequency_counts = {}

    def add(self, number: int) -> None:
        if number in self.number_counts:
            old_freq = self.number_counts[number]
            self.frequency_counts[old_freq] -= 1
            if self.frequency_counts[old_freq] == 0:
                del self.frequency_counts[old_freq]
            new_freq = old_freq + 1
            self.number_counts[number] = new_freq
            self.frequency_counts[new_freq] = self.frequency_counts.get(new_freq, 0) + 1
        else:
            self.number_counts[number] = 1
            self.frequency_counts[1] = self.frequency_counts.get(1, 0) + 1

    def deleteOne(self, number: int) -> None:
        if number in self.number_counts:
            old_freq = self.number_counts[number]
            self.frequency_counts[old_freq] -= 1
            if self.frequency_counts[old_freq] == 0:
                del self.frequency_counts[old_freq]
            new_freq = old_freq - 1
            if new_freq == 0:
                del self.number_counts[number]
            else:
                self.number_counts[number] = new_freq
                self.frequency_counts[new_freq] = self.frequency_counts.get(new_freq, 0) + 1

    def hasFrequency(self, frequency: int) -> bool:
        return frequency in self.frequency_counts


```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
find-the-prefix-common-array-of-two-arrays,Find the Prefix Common Array of Two Arrays,"```python
from typing import List

class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        n = len(A)
        C = []
        set_a = set()
        set_b = set()
        common = set()
        
        for i in range(n):
            set_a.add(A[i])
            set_b.add(B[i])
            if A[i] in set_b:
                common.add(A[i])
            if B[i] in set_a:
                common.add(B[i])
            C.append(len(common))
        
        return C
```",Y,
maximum-number-of-fish-in-a-grid,Maximum Number of Fish in a Grid,"```python
from typing import List

class Solution:
    def findMaxFish(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        max_fish = 0
        
        def dfs(r, c):
            if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] == 0:
                return 0
            fish = grid[r][c]
            grid[r][c] = 0  # Mark as visited
            fish += dfs(r + 1, c)
            fish += dfs(r - 1, c)
            fish += dfs(r, c + 1)
            fish += dfs(r, c - 1)
            return fish
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] > 0:
                    current_fish = dfs(i, j)
                    if current_fish > max_fish:
                        max_fish = current_fish
        return max_fish
```",Y,
extra-characters-in-a-string,Extra Characters in a String,"```python
from typing import List

class Solution:
    def minExtraChar(self, s: str, dictionary: List[str]) -> int:
        n = len(s)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        dictionary_set = set(dictionary)
        
        for i in range(1, n + 1):
            dp[i] = dp[i - 1] + 1
            for j in range(i):
                if s[j:i] in dictionary_set:
                    dp[i] = min(dp[i], dp[j])
        
        return dp[n]
```",Y,
maximum-strength-of-a-group,Maximum Strength of a Group,"```python
from typing import List

class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        
        nums.sort()
        product = 1
        count_neg = 0
        count_zero = 0
        max_neg = -float('inf')
        
        for num in nums:
            if num < 0:
                count_neg += 1
                max_neg = max(max_neg, num)
            elif num == 0:
                count_zero += 1
                continue
        
        if count_zero == len(nums):
            return 0
        
        res = 1
        used = False
        for num in nums:
            if num == 0:
                continue
            if num < 0 and num == max_neg and count_neg % 2 == 1 and not used:
                used = True
                continue
            res *= num
        
        return res if res != 1 or count_zero == 0 else 0
```",Y,
minimum-number-of-operations-to-make-all-array-elements-equal-to-1,Minimum Number of Operations to Make All Array Elements Equal to 1,"```python
import math
from math import gcd
from functools import reduce

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        if 1 in nums:
            return len(nums) - nums.count(1)
        
        min_operations = float('inf')
        n = len(nums)
        
        for i in range(n):
            current_gcd = nums[i]
            for j in range(i + 1, n):
                current_gcd = gcd(current_gcd, nums[j])
                if current_gcd == 1:
                    operations = j - i + (n - 1)
                    if operations < min_operations:
                        min_operations = operations
                    break
        
        return min_operations if min_operations != float('inf') else -1
```",Y,
sliding-subarray-beauty,Sliding Subarray Beauty,"```python
from typing import List
from collections import defaultdict

class Solution:
    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        freq = defaultdict(int)
        negatives = []
        
        for i in range(len(nums)):
            num = nums[i]
            if num < 0:
                freq[num] += 1
            
            if i >= k:
                left_num = nums[i - k]
                if left_num < 0:
                    freq[left_num] -= 1
                    if freq[left_num] == 0:
                        del freq[left_num]
            
            if i >= k - 1:
                sorted_negatives = sorted(freq.keys())
                count = 0
                beauty = 0
                for num in sorted_negatives:
                    count += freq[num]
                    if count >= x:
                        beauty = num
                        break
                if count < x:
                    beauty = 0
                result.append(beauty)
        
        return result
```",Y,
minimum-additions-to-make-valid-string,Minimum Additions to Make Valid String,"```python
class Solution:
    def addMinimum(self, word: str) -> int:
        res = 0
        expected = 'a'
        for c in word:
            if c != expected:
                res += 1
                if expected == 'a':
                    if c == 'b':
                        expected = 'c'
                    else:
                        expected = 'b'
                elif expected == 'b':
                    if c == 'a':
                        res += 1
                        expected = 'b'
                    else:
                        expected = 'a'
                else:  # expected == 'c'
                    if c == 'a':
                        expected = 'b'
                    else:
                        res += 1
                        expected = 'a'
            if expected == 'a':
                expected = 'b'
            elif expected == 'b':
                expected = 'c'
            else:
                expected = 'a'
        if expected != 'a':
            res += 4 - (ord(expected) - ord('a')) - 1
        return res
```",Y,
maximum-or,Maximum OR,"```python
from typing import List

class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        max_or = 0
        prefix = [0] * (len(nums) + 1)
        suffix = [0] * (len(nums) + 1)
        
        for i in range(len(nums)):
            prefix[i+1] = prefix[i] | nums[i]
        
        for i in range(len(nums)-1, -1, -1):
            suffix[i] = suffix[i+1] | nums[i]
        
        max_or = 0
        for i in range(len(nums)):
            current = nums[i] << k
            total = prefix[i] | current | suffix[i+1]
            if total > max_or:
                max_or = total
        
        return max_or
```",Y,
sum-in-a-matrix,Sum in a Matrix,"```python
from typing import List

class Solution:
    def matrixSum(self, nums: List[List[int]]) -> int:
        score = 0
        for row in nums:
            row.sort(reverse=True)
        for i in range(len(nums[0])):
            max_val = 0
            for row in nums:
                if i < len(row):
                    if row[i] > max_val:
                        max_val = row[i]
            score += max_val
        return score
```",Y,
mice-and-cheese,Mice and Cheese,"```python
from typing import List

class Solution:
    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:
        n = len(reward1)
        diff = [(reward1[i] - reward2[i], i) for i in range(n)]
        diff.sort(reverse=True, key=lambda x: x[0])
        
        total = 0
        for i in range(n):
            if i < k:
                total += reward1[diff[i][1]]
            else:
                total += reward2[diff[i][1]]
        return total
```",Y,
convert-an-array-into-a-2d-array-with-conditions,Convert an Array Into a 2D Array With Conditions,"```python
from typing import List

class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        freq = {}
        for num in nums:
            freq[num] = freq.get(num, 0) + 1
        
        result = []
        while freq:
            row = []
            keys = list(freq.keys())
            for num in keys:
                row.append(num)
                freq[num] -= 1
                if freq[num] == 0:
                    del freq[num]
            result.append(row)
        return result
```",Y,
sum-of-distances,Sum of Distances,"```python
from typing import List
from collections import defaultdict

class Solution:
    def distance(self, nums: List[int]) -> List[int]:
        num_indices = defaultdict(list)
        for idx, num in enumerate(nums):
            num_indices[num].append(idx)
        
        res = [0] * len(nums)
        for indices in num_indices.values():
            n = len(indices)
            if n == 1:
                continue
            prefix = [0] * (n + 1)
            for i in range(n):
                prefix[i+1] = prefix[i] + indices[i]
            for i in range(n):
                left_sum = indices[i] * i - prefix[i]
                right_sum = (prefix[n] - prefix[i+1]) - indices[i] * (n - 1 - i)
                res[indices[i]] = left_sum + right_sum
        return res
```",Y,
minimize-the-maximum-difference-of-pairs,Minimize the Maximum Difference of Pairs,"```python
class Solution:
    def minimizeMax(self, nums: List[int], p: int) -> int:
        if p == 0:
            return 0
        
        nums.sort()
        left, right = 0, nums[-1] - nums[0]
        answer = right
        
        def is_possible(mid):
            count = 0
            i = 0
            while i < len(nums) - 1:
                if nums[i+1] - nums[i] <= mid:
                    count += 1
                    i += 2
                else:
                    i += 1
                if count >= p:
                    return True
            return count >= p
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        return answer
```",Y,
minimum-operations-to-make-all-array-elements-equal,Minimum Operations to Make All Array Elements Equal,"```python
import bisect

class Solution:
    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:
        nums.sort()
        n = len(nums)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + nums[i]
        
        res = []
        for q in queries:
            idx = bisect.bisect_left(nums, q)
            left_sum = q * idx - prefix[idx]
            right_sum = (prefix[n] - prefix[idx]) - q * (n - idx)
            res.append(left_sum + right_sum)
        return res
```",Y,
prime-subtraction-operation,Prime Subtraction Operation,"```python
class Solution:
    def primeSubOperation(self, nums: List[int]) -> bool:
        def is_prime(n):
            if n <= 1:
                return False
            if n == 2:
                return True
            if n % 2 == 0:
                return False
            for i in range(3, int(n**0.5) + 1, 2):
                if n % i == 0:
                    return False
            return True

        def get_primes_less_than(n):
            primes = []
            for p in range(2, n):
                if is_prime(p):
                    primes.append(p)
            return primes

        n = len(nums)
        if n == 1:
            return True
        
        prev = 0
        for i in range(n):
            if nums[i] <= prev:
                return False
            primes = get_primes_less_than(nums[i] - prev)
            max_p = 0
            for p in primes:
                if p < nums[i] - prev and (nums[i] - p) > prev:
                    if p > max_p:
                        max_p = p
            if max_p > 0:
                nums[i] -= max_p
            prev = nums[i]
        return True
```",Y,
find-the-divisibility-array-of-a-string,Find the Divisibility Array of a String,"```python
class Solution:
    def divisibilityArray(self, word: str, m: int) -> List[int]:
        n = len(word)
        div = [0] * n
        current_remainder = 0
        for i in range(n):
            digit = int(word[i])
            current_remainder = (current_remainder * 10 + digit) % m
            if current_remainder == 0:
                div[i] = 1
        return div
```",Y,
find-the-maximum-number-of-marked-indices,Find the Maximum Number of Marked Indices,"```python
class Solution:
    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        left = 0
        right = n // 2
        marked = 0
        
        while left < n // 2 and right < n:
            if 2 * nums[left] <= nums[right]:
                marked += 2
                left += 1
                right += 1
            else:
                right += 1
        
        return marked
```",Y,
minimum-operations-to-reduce-an-integer-to-0,Minimum Operations to Reduce an Integer to 0,"```python
class Solution:
    def minOperations(self, n: int) -> int:
        res = 0
        while n > 0:
            if n & 1:
                if n & 2:
                    n += 1
                res += 1
            n >>= 1
        return res
```",Y,
count-the-number-of-square-free-subsets,Count the Number of Square-Free Subsets,"```python
class Solution:
    def squareFreeSubsets(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
        square_free_masks = {}
        
        for num in range(1, 31):
            mask = 0
            tmp = num
            is_square_free = True
            for i, p in enumerate(primes):
                if tmp % (p * p) == 0:
                    is_square_free = False
                    break
                if tmp % p == 0:
                    mask |= (1 << i)
            if is_square_free:
                square_free_masks[num] = mask
        
        freq = [0] * 31
        for num in nums:
            if num in square_free_masks:
                freq[num] += 1
        
        dp = [0] * (1 << 10)
        dp[0] = 1
        
        for num in range(1, 31):
            if freq[num] == 0:
                continue
            mask = square_free_masks[num]
            for m in range((1 << 10) - 1, -1, -1):
                if (m & mask) == 0:
                    new_mask = m | mask
                    dp[new_mask] = (dp[new_mask] + dp[m] * freq[num]) % MOD
        
        total = (sum(dp) - 1) % MOD
        return total
```",Y,
minimum-score-by-changing-two-elements,Minimum Score by Changing Two Elements,"```python
from typing import List

class Solution:
    def minimizeSum(self, nums: List[int]) -> int:
        nums.sort()
        option1 = nums[-3] - nums[0]
        option2 = nums[-1] - nums[2]
        option3 = nums[-2] - nums[1]
        min_high = min(option1, option2, option3)
        return min_high
```",Y,
minimum-impossible-or,Minimum Impossible OR,"```python
class Solution:
    def minImpossibleOR(self, nums: List[int]) -> int:
        nums_set = set(nums)
        res = 1
        while res in nums_set:
            res <<= 1
        return res
```",Y,
substring-xor-queries,Substring XOR Queries,"```python
class Solution:
    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:
        n = len(s)
        val_map = {}
        for l in range(1, 33):
            for i in range(n - l + 1):
                substring = s[i:i+l]
                val = int(substring, 2)
                if val not in val_map or (i + l - 1 - i) < (val_map[val][1] - val_map[val][0]):
                    val_map[val] = [i, i + l - 1]
        
        res = []
        for first, second in queries:
            target = first ^ second
            if target in val_map:
                res.append(val_map[target])
            else:
                res.append([-1, -1])
        return res
```",Y,
count-the-number-of-fair-pairs,Count the Number of Fair Pairs,"```python
class Solution:
    def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:
        nums.sort()
        n = len(nums)
        res = 0
        
        for i in range(n):
            left = i + 1
            right = n - 1
            lower_bound = lower - nums[i]
            upper_bound = upper - nums[i]
            
            l = left
            r = right
            low_pos = n
            while l <= r:
                mid = (l + r) // 2
                if nums[mid] >= lower_bound:
                    low_pos = mid
                    r = mid - 1
                else:
                    l = mid + 1
            
            l = left
            r = right
            high_pos = -1
            while l <= r:
                mid = (l + r) // 2
                if nums[mid] <= upper_bound:
                    high_pos = mid
                    l = mid + 1
                else:
                    r = mid - 1
            
            if low_pos <= high_pos:
                res += high_pos - low_pos + 1
        
        return res
```",Y,
the-number-of-beautiful-subsets,The Number of Beautiful Subsets,"```python
from typing import List

class Solution:
    def beautifulSubsets(self, nums: List[int], k: int) -> int:
        from collections import defaultdict
        
        count = 0
        freq = defaultdict(int)
        
        def backtrack(index):
            nonlocal count
            if index == len(nums):
                if freq:
                    count += 1
                return
            
            backtrack(index + 1)
            
            num = nums[index]
            if freq[num - k] == 0 and freq[num + k] == 0:
                freq[num] += 1
                backtrack(index + 1)
                freq[num] -= 1
                if freq[num] == 0:
                    del freq[num]
        
        backtrack(0)
        return count
```",Y,
find-score-of-an-array-after-marking-all-elements,Find Score of an Array After Marking All Elements,"```python
import heapq

class Solution:
    def findScore(self, nums: List[int]) -> int:
        n = len(nums)
        marked = [False] * n
        heap = []
        for i in range(n):
            heapq.heappush(heap, (nums[i], i))
        
        score = 0
        while heap:
            num, i = heapq.heappop(heap)
            if not marked[i]:
                score += num
                marked[i] = True
                if i > 0:
                    marked[i-1] = True
                if i < n - 1:
                    marked[i+1] = True
        return score
```",Y,
count-vowel-strings-in-ranges,Count Vowel Strings in Ranges,"```python
class Solution:
    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        prefix = [0] * (len(words) + 1)
        for i in range(len(words)):
            word = words[i]
            if word and word[0] in vowels and word[-1] in vowels:
                prefix[i+1] = prefix[i] + 1
            else:
                prefix[i+1] = prefix[i]
        
        ans = []
        for l, r in queries:
            ans.append(prefix[r+1] - prefix[l])
        return ans
```",Y,
house-robber-iv,House Robber IV,"```python
class Solution:
    def minCapability(self, nums: List[int], k: int) -> int:
        left = min(nums)
        right = max(nums)
        
        def can_rob(mid):
            count = 0
            i = 0
            n = len(nums)
            while i < n:
                if nums[i] <= mid:
                    count += 1
                    i += 2
                else:
                    i += 1
                if count >= k:
                    return True
            return count >= k
        
        while left < right:
            mid = (left + right) // 2
            if can_rob(mid):
                right = mid
            else:
                left = mid + 1
        return left
```",Y,
minimum-cost-of-a-path-with-special-roads,Minimum Cost of a Path With Special Roads,"```python
import heapq
from typing import List

class Solution:
    def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:
        start_x, start_y = start
        target_x, target_y = target
        
        min_cost = abs(target_x - start_x) + abs(target_y - start_y)
        
        heap = []
        heapq.heappush(heap, (0, start_x, start_y))
        
        visited = {}
        visited[(start_x, start_y)] = 0
        
        while heap:
            current_cost, x, y = heapq.heappop(heap)
            
            if x == target_x and y == target_y:
                return current_cost
            
            if current_cost > visited.get((x, y), float('inf')):
                continue
            
            direct_cost = current_cost + abs(target_x - x) + abs(target_y - y)
            if direct_cost < min_cost:
                min_cost = direct_cost
            
            for road in specialRoads:
                x1, y1, x2, y2, cost = road
                cost_to_start = current_cost + abs(x1 - x) + abs(y1 - y)
                total_cost = cost_to_start + cost
                if total_cost < visited.get((x2, y2), float('inf')):
                    visited[(x2, y2)] = total_cost
                    heapq.heappush(heap, (total_cost, x2, y2))
        
        return min_cost
```",Y,
first-completely-painted-row-or-column,First Completely Painted Row or Column,"```python
from typing import List

class Solution:
    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        
        value_to_pos = {}
        for r in range(m):
            for c in range(n):
                value_to_pos[mat[r][c]] = (r, c)
        
        row_counts = [0] * m
        col_counts = [0] * n
        
        for i in range(len(arr)):
            val = arr[i]
            r, c = value_to_pos[val]
            row_counts[r] += 1
            if row_counts[r] == n:
                return i
            col_counts[c] += 1
            if col_counts[c] == m:
                return i
        
        return -1
```",Y,
count-collisions-of-monkeys-on-a-polygon,Count Collisions of Monkeys on a Polygon,"```python
class Solution:
    def monkeyMove(self, n: int) -> int:
        MOD = 10**9 + 7
        return (pow(2, n, MOD) - 2 % MOD
```",Y,
cousins-in-binary-tree-ii,Cousins in Binary Tree II,"```python
from collections import deque

class Solution:
    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        
        root.val = 0
        queue = deque([root])
        
        while queue:
            level_size = len(queue)
            level_sum = 0
            level_nodes = []
            parent_sum = {}
            
            for _ in range(level_size):
                node = queue.popleft()
                level_nodes.append(node)
                if node.left:
                    level_sum += node.left.val
                    queue.append(node.left)
                if node.right:
                    level_sum += node.right.val
                    queue.append(node.right)
                parent_sum[node] = (node.left.val if node.left else 0) + (node.right.val if node.right else 0)
            
            for node in level_nodes:
                total = level_sum - parent_sum.get(node, 0)
                if node.left:
                    node.left.val = total
                if node.right:
                    node.right.val = total
        
        return root
```",Y,
find-the-score-of-all-prefixes-of-an-array,Find the Score of All Prefixes of an Array,"```python
from typing import List

class Solution:
    def findPrefixScore(self, nums: List[int]) -> List[int]:
        max_so_far = 0
        total = 0
        ans = []
        for num in nums:
            max_so_far = max(max_so_far, num)
            total += num + max_so_far
            ans.append(total)
        return ans
```",Y,
maximize-win-from-two-segments,Maximize Win From Two Segments,"```python
from typing import List

class Solution:
    def maximizeWin(self, prizePositions: List[int], k: int) -> int:
        n = len(prizePositions)
        if n == 0:
            return 0
        
        left = 0
        dp = [0] * (n + 1)
        res = 0
        
        for right in range(n):
            while prizePositions[right] - prizePositions[left] > k:
                left += 1
            current_prizes = right - left + 1
            dp[right + 1] = max(dp[right], current_prizes)
            res = max(res, current_prizes + dp[left])
        
        return res
```",Y,
make-k-subarray-sums-equal,Make K-Subarray Sums Equal,"```python
import math
from typing import List

class Solution:
    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:
        n = len(arr)
        visited = [False] * n
        total_operations = 0
        
        for i in range(n):
            if not visited[i]:
                group = []
                j = i
                while not visited[j]:
                    visited[j] = True
                    group.append(arr[j])
                    j = (j + k) % n
                group.sort()
                median = group[len(group) // 2]
                total_operations += sum(abs(num - median) for num in group)
        
        return total_operations
```",Y,
find-the-substring-with-maximum-cost,Find the Substring With Maximum Cost,"```python
from typing import List

class Solution:
    def maximumCostSubstring(self, s: str, chars: str, vals: List[int]) -> int:
        char_to_val = {}
        for c, v in zip(chars, vals):
            char_to_val[c] = v
        
        max_cost = current_cost = 0
        for c in s:
            if c in char_to_val:
                val = char_to_val[c]
            else:
                val = ord(c) - ord('a') + 1
            current_cost = max(val, current_cost + val)
            max_cost = max(max_cost, current_cost)
        return max_cost
```",Y,
minimum-time-to-repair-cars,Minimum Time to Repair Cars,"```python
import bisect
from typing import List

class Solution:
    def repairCars(self, ranks: List[int], cars: int) -> int:
        left = 0
        right = min(ranks) * cars * cars
        
        def can_repair(t):
            total = 0
            for r in ranks:
                total += int((t // r) ** 0.5)
                if total >= cars:
                    return True
            return total >= cars
        
        while left < right:
            mid = (left + right) // 2
            if can_repair(mid):
                right = mid
            else:
                left = mid + 1
        return left
```",Y,
maximize-greatness-of-an-array,Maximize Greatness of an Array,"```python
class Solution:
    def maximizeGreatness(self, nums: List[int]) -> int:
        nums_sorted = sorted(nums)
        perm_sorted = sorted(nums)
        
        res = 0
        i = 0
        j = 0
        n = len(nums)
        
        while j < n:
            if perm_sorted[j] > nums_sorted[i]:
                res += 1
                i += 1
            j += 1
        
        return res
```",Y,
check-knight-tour-configuration,Check Knight Tour Configuration,"```python
from typing import List

class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:
        if grid[0][0] != 0:
            return False
        
        n = len(grid)
        positions = {}
        for i in range(n):
            for j in range(n):
                positions[grid[i][j]] = (i, j)
        
        for step in range(1, n * n):
            prev_x, prev_y = positions[step - 1]
            curr_x, curr_y = positions[step]
            dx = abs(curr_x - prev_x)
            dy = abs(curr_y - prev_y)
            if not ((dx == 2 and dy == 1) or (dx == 1 and dy == 2)):
                return False
        
        return True
```",Y,
smallest-missing-non-negative-integer-after-operations,Smallest Missing Non-negative Integer After Operations,"```python
from typing import List
from collections import defaultdict

class Solution:
    def findSmallestInteger(self, nums: List[int], value: int) -> int:
        freq = defaultdict(int)
        for num in nums:
            mod = num % value
            if mod < 0:
                mod += value
            freq[mod] += 1
        
        mex = 0
        while True:
            mod = mex % value
            if freq[mod] > 0:
                freq[mod] -= 1
                mex += 1
            else:
                return mex
```",Y,
count-the-number-of-beautiful-subarrays,Count the Number of Beautiful Subarrays,"```python
from typing import List
from collections import defaultdict

class Solution:
    def beautifulSubarrays(self, nums: List[int]) -> int:
        prefix_xor = 0
        xor_counts = defaultdict(int)
        xor_counts[0] = 1
        result = 0
        
        for num in nums:
            prefix_xor ^= num
            result += xor_counts[prefix_xor]
            xor_counts[prefix_xor] += 1
        
        return result
```",Y,
rearrange-array-to-maximize-prefix-score,Rearrange Array to Maximize Prefix Score,"```python
class Solution:
    def maxScore(self, nums: List[int]) -> int:
        nums.sort(reverse=True)
        prefix_sum = 0
        score = 0
        for num in nums:
            prefix_sum += num
            if prefix_sum > 0:
                score += 1
            else:
                break
        return score
```",Y,
count-ways-to-group-overlapping-ranges,Count Ways to Group Overlapping Ranges,"```python
class Solution:
    def countWays(self, ranges: List[List[int]]) -> int:
        ranges.sort()
        merged = []
        for start, end in ranges:
            if not merged:
                merged.append([start, end])
            else:
                last_start, last_end = merged[-1]
                if start <= last_end:
                    merged[-1][1] = max(last_end, end)
                else:
                    merged.append([start, end])
        return pow(2, len(merged), 10**9 + 7)
```",Y,
count-total-number-of-colored-cells,Count Total Number of Colored Cells,"```python
class Solution:
    def coloredCells(self, n: int) -> int:
        return 2 * n * n - 2 * n + 1
```",Y,
kth-largest-sum-in-a-binary-tree,Kth Largest Sum in a Binary Tree,"```python
from collections import deque

class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        if not root:
            return -1
        
        queue = deque([root])
        level_sums = []
        
        while queue:
            level_size = len(queue)
            current_sum = 0
            for _ in range(level_size):
                node = queue.popleft()
                current_sum += node.val
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            level_sums.append(current_sum)
        
        if len(level_sums) < k:
            return -1
        
        level_sums.sort(reverse=True)
        return level_sums[k-1]
```",Y,
disconnect-path-in-a-binary-matrix-by-at-most-one-flip,Disconnect Path in a Binary Matrix by at Most One Flip,"```python
from typing import List

class Solution:
    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:
        m, n = len(grid), len(grid[0])
        
        def dfs(i, j):
            if i == m - 1 and j == n - 1:
                return True
            grid[i][j] = 0
            if i + 1 < m and grid[i + 1][j] == 1 and dfs(i + 1, j):
                return True
            if j + 1 < n and grid[i][j + 1] == 1 and dfs(i, j + 1):
                return True
            return False
        
        if not dfs(0, 0):
            return True
        grid[0][0] = 1
        return not dfs(0, 0)
```",Y,
maximum-number-of-integers-to-choose-from-a-range-i,Maximum Number of Integers to Choose From a Range I,"```python
from typing import List

class Solution:
    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:
        banned_set = set(banned)
        total = 0
        count = 0
        for num in range(1, n + 1):
            if num not in banned_set:
                if total + num <= maxSum:
                    total += num
                    count += 1
                else:
                    break
        return count
```",Y,
maximum-subsequence-score,Maximum Subsequence Score,"```python
import heapq
from typing import List

class Solution:
    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:
        pairs = sorted(zip(nums2, nums1), reverse=True)
        min_heap = []
        total = 0
        res = 0
        
        for num2, num1 in pairs:
            heapq.heappush(min_heap, num1)
            total += num1
            if len(min_heap) > k:
                val = heapq.heappop(min_heap)
                total -= val
            if len(min_heap) == k:
                res = max(res, total * num2)
        
        return res
```",Y,
apply-bitwise-operations-to-make-strings-equal,Apply Bitwise Operations to Make Strings Equal,"```python
class Solution:
    def makeStringsEqual(self, s: str, target: str) -> bool:
        if s == target:
            return True
        has_one_in_s = '1' in s
        has_one_in_target = '1' in target
        return has_one_in_s and has_one_in_target
```",Y,
sort-the-students-by-their-kth-score,Sort the Students by Their Kth Score,"```python
class Solution:
    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:
        return sorted(score, key=lambda x: -x[k])
```",Y,
minimize-the-maximum-of-two-arrays,Minimize the Maximum of Two Arrays,"```python
import math

class Solution:
    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:
        def lcm(a, b):
            return a * b // math.gcd(a, b)
        
        lcm_val = lcm(divisor1, divisor2)
        left, right = 0, 2 * 10**18
        
        while left < right:
            mid = (left + right) // 2
            not_div1 = mid - mid // divisor1
            not_div2 = mid - mid // divisor2
            not_div_both = mid - mid // divisor1 - mid // divisor2 + mid // lcm_val
            
            if (not_div1 >= uniqueCnt1 and 
                not_div2 >= uniqueCnt2 and 
                (not_div1 + not_div2 - not_div_both) >= (uniqueCnt1 + uniqueCnt2)):
                right = mid
            else:
                left = mid + 1
        return left
```",Y,
count-the-number-of-good-subarrays,Count the Number of Good Subarrays,"```python
from collections import defaultdict
from typing import List

class Solution:
    def countGood(self, nums: List[int], k: int) -> int:
        left = 0
        count = defaultdict(int)
        res = 0
        pairs = 0
        
        for right in range(len(nums)):
            num = nums[right]
            pairs += count[num]
            count[num] += 1
            
            while pairs >= k:
                res += len(nums) - right
                left_num = nums[left]
                count[left_num] -= 1
                pairs -= count[left_num]
                left += 1
        
        return res
```",Y,
increment-submatrices-by-one,Increment Submatrices by One,"```python
class Solution:
    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:
        mat = [[0] * n for _ in range(n)]
        for row1, col1, row2, col2 in queries:
            for i in range(row1, row2 + 1):
                for j in range(col1, col2 + 1):
                    mat[i][j] += 1
        return mat
```",Y,
find-xor-beauty-of-array,Find Xor-Beauty of Array,"```python
from typing import List

class Solution:
    def xorBeauty(self, nums: List[int]) -> int:
        result = 0
        for num in nums:
            result ^= num
        return result
```",Y,
find-consecutive-integers-from-a-data-stream,Find Consecutive Integers from a Data Stream,"```python
class DataStream:

    def __init__(self, value: int, k: int):
        self.value = value
        self.k = k
        self.queue = []
        self.count = 0

    def consec(self, num: int) -> bool:
        self.queue.append(num)
        if num == self.value:
            self.count += 1
        else:
            self.count = 0
        
        if len(self.queue) < self.k:
            return False
        return self.count >= self.k
```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
maximal-score-after-applying-k-operations,Maximal Score After Applying K Operations,"```python
import heapq
from typing import List

class Solution:
    def maxKelements(self, nums: List[int], k: int) -> int:
        max_heap = []
        for num in nums:
            heapq.heappush(max_heap, -num)
        
        total = 0
        for _ in range(k):
            if not max_heap:
                break
            current = -heapq.heappop(max_heap)
            total += current
            new_val = (current + 2) // 3  # Equivalent to math.ceil(current / 3)
            heapq.heappush(max_heap, -new_val)
        
        return total
```",Y,
make-number-of-distinct-characters-equal,Make Number of Distinct Characters Equal,"```python
class Solution:
    def isItPossible(self, word1: str, word2: str) -> bool:
        from collections import defaultdict

        count1 = defaultdict(int)
        count2 = defaultdict(int)
        
        for c in word1:
            count1[c] += 1
        for c in word2:
            count2[c] += 1
        
        distinct1 = len(count1)
        distinct2 = len(count2)
        
        for c1 in list(count1.keys()):
            for c2 in list(count2.keys()):
                new_count1 = count1.copy()
                new_count2 = count2.copy()
                
                new_count1[c1] -= 1
                if new_count1[c1] == 0:
                    del new_count1[c1]
                new_count1[c2] += 1
                
                new_count2[c2] -= 1
                if new_count2[c2] == 0:
                    del new_count2[c2]
                new_count2[c1] += 1
                
                if len(new_count1) == len(new_count2):
                    return True
        return False
```",Y,
closest-prime-numbers-in-range,Closest Prime Numbers in Range,"```python
import math

class Solution:
    def closestPrimes(self, left: int, right: int) -> List[int]:
        def is_prime(n):
            if n < 2:
                return False
            for p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]:
                if n % p == 0:
                    return n == p
            d = n - 1
            s = 0
            while d % 2 == 0:
                d //= 2
                s += 1
            for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
                if a >= n:
                    continue
                x = pow(a, d, n)
                if x == 1 or x == n - 1:
                    continue
                for _ in range(s - 1):
                    x = pow(x, 2, n)
                    if x == n - 1:
                        break
                else:
                    return False
            return True

        primes = []
        for num in range(left, right + 1):
            if is_prime(num):
                primes.append(num)
        
        if len(primes) < 2:
            return [-1, -1]
        
        min_diff = float('inf')
        result = [-1, -1]
        for i in range(len(primes) - 1):
            diff = primes[i+1] - primes[i]
            if diff < min_diff:
                min_diff = diff
                result = [primes[i], primes[i+1]]
                if min_diff == 2:
                    break
        
        return result
```",Y,
distinct-prime-factors-of-product-of-array,Distinct Prime Factors of Product of Array,"```python
class Solution:
    def distinctPrimeFactors(self, nums: List[int]) -> int:
        def get_prime_factors(x):
            factors = set()
            if x == 1:
                return factors
            while x % 2 == 0:
                factors.add(2)
                x = x // 2
            i = 3
            while i * i <= x:
                while x % i == 0:
                    factors.add(i)
                    x = x // i
                i += 2
            if x > 1:
                factors.add(x)
            return factors
        
        prime_factors = set()
        for num in nums:
            factors = get_prime_factors(num)
            prime_factors.update(factors)
        return len(prime_factors)
```",Y,
difference-between-ones-and-zeros-in-row-and-column,Difference Between Ones and Zeros in Row and Column,"```python
from typing import List

class Solution:
    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        
        onesRow = [0] * m
        zerosRow = [0] * m
        for i in range(m):
            onesRow[i] = sum(grid[i])
            zerosRow[i] = n - onesRow[i]
        
        onesCol = [0] * n
        zerosCol = [0] * n
        for j in range(n):
            col_sum = sum(grid[i][j] for i in range(m))
            onesCol[j] = col_sum
            zerosCol[j] = m - col_sum
        
        diff = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                diff[i][j] = onesRow[i] + onesCol[j] - zerosRow[i] - zerosCol[j]
        
        return diff
```",Y,
minimum-operations-to-make-array-equal-ii,Minimum Operations to Make Array Equal II,"```python
from typing import List

class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        if k == 0:
            return 0 if nums1 == nums2 else -1
        
        total_pos = 0
        total_neg = 0
        
        for a, b in zip(nums1, nums2):
            diff = b - a
            if diff % k != 0:
                return -1
            ops = diff // k
            if ops > 0:
                total_pos += ops
            elif ops < 0:
                total_neg += -ops
        
        if total_pos != total_neg:
            return -1
        
        return total_pos
```",Y,
reward-top-k-students,Reward Top K Students,"```python
from typing import List

class Solution:
    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:
        positive = set(positive_feedback)
        negative = set(negative_feedback)
        student_points = {}
        
        for i in range(len(report)):
            words = report[i].split()
            points = 0
            for word in words:
                if word in positive:
                    points += 3
                elif word in negative:
                    points -= 1
            current_id = student_id[i]
            student_points[current_id] = points
        
        sorted_students = sorted(student_points.keys(), key=lambda x: (-student_points[x], x))
        return sorted_students[:k]
```",Y,
maximum-tastiness-of-candy-basket,Maximum Tastiness of Candy Basket,"```python
class Solution:
    def maximumTastiness(self, price: List[int], k: int) -> int:
        price.sort()
        left, right = 0, price[-1] - price[0]
        answer = 0
        
        def is_possible(mid):
            count = 1
            last = price[0]
            for i in range(1, len(price)):
                if price[i] - last >= mid:
                    count += 1
                    last = price[i]
                    if count >= k:
                        return True
            return count >= k
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                answer = mid
                left = mid + 1
            else:
                right = mid - 1
        return answer
```",Y,
take-k-of-each-character-from-left-and-right,Take K of Each Character From Left and Right,"```python
class Solution:
    def takeCharacters(self, s: str, k: int) -> int:
        if k == 0:
            return 0
        
        n = len(s)
        count = {'a': 0, 'b': 0, 'c': 0}
        for c in s:
            count[c] += 1
        
        if any(count[char] < k for char in 'abc'):
            return -1
        
        left_counts = {'a': 0, 'b': 0, 'c': 0}
        right_counts = {'a': 0, 'b': 0, 'c': 0}
        left = 0
        right = n - 1
        min_time = float('inf')
        
        for left in range(n + 1):
            if left > 0:
                left_counts[s[left - 1]] += 1
            current_right_counts = {'a': 0, 'b': 0, 'c': 0}
            temp_right = n - 1
            found = False
            for take_right in range(n - left + 1):
                if take_right > 0:
                    current_right_counts[s[temp_right]] += 1
                    temp_right -= 1
                total_a = left_counts['a'] + current_right_counts['a']
                total_b = left_counts['b'] + current_right_counts['b']
                total_c = left_counts['c'] + current_right_counts['c']
                if total_a >= k and total_b >= k and total_c >= k:
                    total_time = left + take_right
                    if total_time < min_time:
                        min_time = total_time
                    found = True
                    break
            if found:
                break
        
        right_counts = {'a': 0, 'b': 0, 'c': 0}
        for right_taken in range(n + 1):
            if right_taken > 0:
                right_counts[s[n - right_taken]] += 1
            current_left_counts = {'a': 0, 'b': 0, 'c': 0}
            temp_left = 0
            found = False
            for take_left in range(n - right_taken + 1):
                if take_left > 0:
                    current_left_counts[s[temp_left]] += 1
                    temp_left += 1
                total_a = current_left_counts['a'] + right_counts['a']
                total_b = current_left_counts['b'] + right_counts['b']
                total_c = current_left_counts['c'] + right_counts['c']
                if total_a >= k and total_b >= k and total_c >= k:
                    total_time = take_left + right_taken
                    if total_time < min_time:
                        min_time = total_time
                    found = True
                    break
            if found:
                break
        
        return min_time if min_time != float('inf') else -1
```",Y,
smallest-value-after-replacing-with-sum-of-prime-factors,Smallest Value After Replacing With Sum of Prime Factors,"```python
class Solution:
    def smallestValue(self, n: int) -> int:
        def get_prime_factors(x):
            factors = []
            while x % 2 == 0:
                factors.append(2)
                x = x // 2
            i = 3
            while i * i <= x:
                while x % i == 0:
                    factors.append(i)
                    x = x // i
                i += 2
            if x > 1:
                factors.append(x)
            return factors
        
        seen = set()
        current = n
        while current not in seen:
            seen.add(current)
            factors = get_prime_factors(current)
            if len(factors) == 1:
                break
            current = sum(factors)
        return current
```",Y,
frog-jump-ii,Frog Jump II,"```python
from typing import List

class Solution:
    def maxJump(self, stones: List[int]) -> int:
        if len(stones) == 2:
            return stones[1] - stones[0]
        max_cost = 0
        for i in range(2, len(stones)):
            max_cost = max(max_cost, stones[i] - stones[i-2])
        return max_cost
```",Y,
maximum-star-sum-of-a-graph,Maximum Star Sum of a Graph,"```python
from typing import List

class Solution:
    def maxStarSum(self, vals: List[int], edges: List[List[int]], k: int) -> int:
        from collections import defaultdict
        
        if not edges:
            return max(vals)
        
        graph = defaultdict(list)
        for a, b in edges:
            if vals[b] > 0:
                graph[a].append(vals[b])
            if vals[a] > 0:
                graph[b].append(vals[a])
        
        max_sum = -float('inf')
        for node in range(len(vals)):
            neighbors = sorted(graph.get(node, []), reverse=True)
            current_sum = vals[node] + sum(neighbors[:k])
            if current_sum > max_sum:
                max_sum = current_sum
        
        return max_sum
```",Y,
design-memory-allocator,Design Memory Allocator,"```python
class Allocator:

    def __init__(self, n: int):
        self.memory = [0] * n

    def allocate(self, size: int, mID: int) -> int:
        consecutive = 0
        start = -1
        for i in range(len(self.memory)):
            if self.memory[i] == 0:
                if consecutive == 0:
                    start = i
                consecutive += 1
                if consecutive == size:
                    for j in range(start, start + size):
                        self.memory[j] = mID
                    return start
            else:
                consecutive = 0
        return -1

    def freeMemory(self, mID: int) -> int:
        count = 0
        for i in range(len(self.memory)):
            if self.memory[i] == mID:
                self.memory[i] = 0
                count += 1
        return count


```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
longest-square-streak-in-an-array,Longest Square Streak in an Array,"```python
from typing import List

class Solution:
    def longestSquareStreak(self, nums: List[int]) -> int:
        num_set = set(nums)
        max_streak = -1
        
        for num in sorted(nums):
            current_streak = 1
            next_num = num * num
            while next_num in num_set:
                current_streak += 1
                next_num *= next_num
            if current_streak >= 2 and current_streak > max_streak:
                max_streak = current_streak
        
        return max_streak if max_streak != -1 else -1
```",Y,
minimum-score-of-a-path-between-two-cities,Minimum Score of a Path Between Two Cities,"```python
from typing import List
from collections import deque

class Solution:
    def minScore(self, n: int, roads: List[List[int]]) -> int:
        graph = [[] for _ in range(n + 1)]
        for a, b, d in roads:
            graph[a].append((b, d))
            graph[b].append((a, d))
        
        visited = [False] * (n + 1)
        queue = deque()
        queue.append(1)
        visited[1] = True
        min_score = float('inf')
        
        while queue:
            node = queue.popleft()
            for neighbor, d in graph[node]:
                min_score = min(min_score, d)
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
        
        return min_score
```",Y,
divide-players-into-teams-of-equal-skill,Divide Players Into Teams of Equal Skill,"```python
from typing import List

class Solution:
    def dividePlayers(self, skill: List[int]) -> int:
        skill.sort()
        n = len(skill)
        total_skill = sum(skill)
        if total_skill % (n // 2) != 0:
            return -1
        target = total_skill // (n // 2)
        left, right = 0, n - 1
        chemistry_sum = 0
        while left < right:
            if skill[left] + skill[right] != target:
                return -1
            chemistry_sum += skill[left] * skill[right]
            left += 1
            right -= 1
        return chemistry_sum
```",Y,
minimum-penalty-for-a-shop,Minimum Penalty for a Shop,"```python
class Solution:
    def bestClosingTime(self, customers: str) -> int:
        n = len(customers)
        prefix_n = [0] * (n + 1)
        suffix_y = [0] * (n + 1)
        
        for i in range(1, n + 1):
            prefix_n[i] = prefix_n[i - 1] + (1 if customers[i - 1] == 'N' else 0)
        
        for i in range(n - 1, -1, -1):
            suffix_y[i] = suffix_y[i + 1] + (1 if customers[i] == 'Y' else 0)
        
        min_penalty = float('inf')
        best_hour = 0
        
        for hour in range(n + 1):
            penalty = prefix_n[hour] + suffix_y[hour]
            if penalty < min_penalty:
                min_penalty = penalty
                best_hour = hour
        
        return best_hour
```",Y,
remove-nodes-from-linked-list,Remove Nodes From Linked List,"```python
class Solution:
    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:
        stack = []
        current = head
        while current:
            while stack and stack[-1].val < current.val:
                stack.pop()
            stack.append(current)
            current = current.next
        
        dummy = ListNode()
        prev = dummy
        for node in stack:
            prev.next = node
            prev = node
        prev.next = None
        return dummy.next
```",Y,
append-characters-to-string-to-make-subsequence,Append Characters to String to Make Subsequence,"```python
class Solution:
    def appendCharacters(self, s: str, t: str) -> int:
        s_ptr = 0
        t_ptr = 0
        s_len = len(s)
        t_len = len(t)
        
        while s_ptr < s_len and t_ptr < t_len:
            if s[s_ptr] == t[t_ptr]:
                t_ptr += 1
            s_ptr += 1
        
        return t_len - t_ptr
```",Y,
minimum-fuel-cost-to-report-to-the-capital,Minimum Fuel Cost to Report to the Capital,"```python
from typing import List
from collections import defaultdict, deque

class Solution:
    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:
        if not roads:
            return 0
        
        graph = defaultdict(list)
        for a, b in roads:
            graph[a].append(b)
            graph[b].append(a)
        
        parent = {}
        children = defaultdict(list)
        queue = deque([0])
        parent[0] = -1
        
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if neighbor != parent[node]:
                    parent[neighbor] = node
                    children[node].append(neighbor)
                    queue.append(neighbor)
        
        fuel = 0
        
        def dfs(node):
            nonlocal fuel
            total_people = 1
            for child in children[node]:
                people = dfs(child)
                total_people += people
                fuel += (people + seats - 1) // seats
            return total_people
        
        dfs(0)
        return fuel
```",Y,
closest-nodes-queries-in-a-binary-search-tree,Closest Nodes Queries in a Binary Search Tree,"```python
class Solution:
    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:
        values = []
        def inorder(node):
            if node:
                inorder(node.left)
                values.append(node.val)
                inorder(node.right)
        inorder(root)
        
        answer = []
        for q in queries:
            mini = -1
            maxi = -1
            left, right = 0, len(values) - 1
            while left <= right:
                mid = (left + right) // 2
                if values[mid] <= q:
                    mini = values[mid]
                    left = mid + 1
                else:
                    right = mid - 1
            left, right = 0, len(values) - 1
            while left <= right:
                mid = (left + right) // 2
                if values[mid] >= q:
                    maxi = values[mid]
                    right = mid - 1
                else:
                    left = mid + 1
            answer.append([mini, maxi])
        return answer
```",Y,
most-profitable-path-in-a-tree,Most Profitable Path in a Tree,"```python
from typing import List
from collections import deque

class Solution:
    def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
        n = len(edges) + 1
        graph = [[] for _ in range(n)]
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)
        
        parent = [ -1 ] * n
        q = deque([0])
        while q:
            u = q.popleft()
            for v in graph[u]:
                if parent[v] == -1 and v != 0:
                    parent[v] = u
                    q.append(v)
        
        bob_path = []
        u = bob
        while u != -1:
            bob_path.append(u)
            u = parent[u]
        bob_path.reverse()
        
        bob_time = {}
        for t, node in enumerate(bob_path):
            bob_time[node] = t
        
        max_profit = -float('inf')
        q = deque()
        q.append((0, 0, 0))  # (node, time, current_profit)
        visited = [False] * n
        visited[0] = True
        
        while q:
            node, time, profit = q.popleft()
            
            if node in bob_time:
                if time < bob_time[node]:
                    current_amount = amount[node]
                elif time == bob_time[node]:
                    current_amount = amount[node] // 2
                else:
                    current_amount = 0
            else:
                current_amount = amount[node]
            
            new_profit = profit + current_amount
            
            is_leaf = True
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    is_leaf = False
                    break
            
            if is_leaf and node != 0:
                max_profit = max(max_profit, new_profit)
            else:
                for neighbor in graph[node]:
                    if not visited[neighbor]:
                        visited[neighbor] = True
                        q.append((neighbor, time + 1, new_profit))
        
        return max_profit
```",Y,
count-ways-to-build-good-strings,Count Ways To Build Good Strings,"```python
class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        MOD = 10**9 + 7
        dp = [0] * (high + 1)
        dp[0] = 1
        for i in range(1, high + 1):
            if i >= zero:
                dp[i] += dp[i - zero]
            if i >= one:
                dp[i] += dp[i - one]
            dp[i] %= MOD
        total = 0
        for i in range(low, high + 1):
            total += dp[i]
            total %= MOD
        return total
```",Y,
minimum-number-of-operations-to-sort-a-binary-tree-by-level,Minimum Number of Operations to Sort a Binary Tree by Level,"```python
from collections import deque

class Solution:
    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        queue = deque([root])
        operations = 0
        
        while queue:
            level_size = len(queue)
            current_level = []
            for _ in range(level_size):
                node = queue.popleft()
                current_level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            sorted_level = sorted(current_level)
            value_to_index = {val: idx for idx, val in enumerate(current_level)}
            
            for i in range(len(current_level)):
                if current_level[i] != sorted_level[i]:
                    correct_val = sorted_level[i]
                    current_val = current_level[i]
                    
                    swap_idx = value_to_index[correct_val]
                    current_level[i], current_level[swap_idx] = current_level[swap_idx], current_level[i]
                    
                    value_to_index[current_val] = swap_idx
                    value_to_index[correct_val] = i
                    
                    operations += 1
        
        return operations
```",Y,
number-of-subarrays-with-lcm-equal-to-k,Number of Subarrays With LCM Equal to K,"```python
import math
from typing import List

class Solution:
    def subarrayLCM(self, nums: List[int], k: int) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            current_lcm = 1
            for j in range(i, n):
                current_lcm = math.lcm(current_lcm, nums[j])
                if current_lcm == k:
                    count += 1
                elif current_lcm > k:
                    break
        return count
```",Y,
total-cost-to-hire-k-workers,Total Cost to Hire K Workers,"```python
import heapq

class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        left_heap = []
        right_heap = []
        n = len(costs)
        left_ptr = 0
        right_ptr = n - 1
        total_cost = 0
        
        for _ in range(k):
            while left_ptr <= right_ptr and len(left_heap) < candidates:
                heapq.heappush(left_heap, (costs[left_ptr], left_ptr))
                left_ptr += 1
            while left_ptr <= right_ptr and len(right_heap) < candidates:
                heapq.heappush(right_heap, (costs[right_ptr], right_ptr))
                right_ptr -= 1
            
            left_min = left_heap[0] if left_heap else (float('inf'), -1)
            right_min = right_heap[0] if right_heap else (float('inf'), -1)
            
            if left_min[0] <= right_min[0]:
                total_cost += left_min[0]
                heapq.heappop(left_heap)
            else:
                total_cost += right_min[0]
                heapq.heappop(right_heap)
        
        return total_cost
```",Y,
maximum-sum-of-distinct-subarrays-with-length-k,Maximum Sum of Distinct Subarrays With Length K,"```python
from typing import List
from collections import defaultdict

class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        max_sum = 0
        current_sum = 0
        freq = defaultdict(int)
        left = 0
        
        for right in range(len(nums)):
            freq[nums[right]] += 1
            current_sum += nums[right]
            
            if right - left + 1 == k:
                if len(freq) == k:
                    max_sum = max(max_sum, current_sum)
                
                freq[nums[left]] -= 1
                if freq[nums[left]] == 0:
                    del freq[nums[left]]
                current_sum -= nums[left]
                left += 1
        
        return max_sum
```",Y,
words-within-two-edits-of-dictionary,Words Within Two Edits of Dictionary,"```python
from typing import List

class Solution:
    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:
        result = []
        for query in queries:
            found = False
            for word in dictionary:
                if len(query) != len(word):
                    continue
                diff = 0
                for a, b in zip(query, word):
                    if a != b:
                        diff += 1
                        if diff > 2:
                            break
                if diff <= 2:
                    found = True
                    break
            if found:
                result.append(query)
        return result
```",Y,
destroy-sequential-targets,Destroy Sequential Targets,"```python
from typing import List
from collections import defaultdict

class Solution:
    def destroyTargets(self, nums: List[int], space: int) -> int:
        mod_counts = defaultdict(int)
        mod_min = {}
        
        for num in nums:
            mod = num % space
            mod_counts[mod] += 1
            if mod in mod_min:
                if num < mod_min[mod]:
                    mod_min[mod] = num
            else:
                mod_min[mod] = num
        
        max_count = max(mod_counts.values()) if mod_counts else 0
        candidates = [mod_min[mod] for mod in mod_counts if mod_counts[mod] == max_count]
        
        return min(candidates) if candidates else min(nums)
```",Y,
number-of-subarrays-with-gcd-equal-to-k,Number of Subarrays With GCD Equal to K,"```python
import math
from typing import List

class Solution:
    def subarrayGCD(self, nums: List[int], k: int) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            current_gcd = 0
            for j in range(i, n):
                current_gcd = math.gcd(current_gcd, nums[j])
                if current_gcd == k:
                    count += 1
                elif current_gcd < k:
                    break
        return count
```",Y,
minimum-addition-to-make-integer-beautiful,Minimum Addition to Make Integer Beautiful,"```python
class Solution:
    def makeIntegerBeautiful(self, n: int, target: int) -> int:
        def digit_sum(num):
            s = 0
            while num > 0:
                s += num % 10
                num = num // 10
            return s
        
        x = 0
        power = 1
        while digit_sum(n + x) > target:
            step = power * 10 - (n + x) % (power * 10)
            x += step
            power *= 10
        return x
```",Y,
most-popular-video-creator,Most Popular Video Creator,"```python
from typing import List

class Solution:
    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:
        from collections import defaultdict
        
        creator_total_views = defaultdict(int)
        creator_videos = defaultdict(list)
        
        for creator, video_id, view in zip(creators, ids, views):
            creator_total_views[creator] += view
            creator_videos[creator].append((view, video_id))
        
        if not creator_total_views:
            return []
        
        max_popularity = max(creator_total_views.values())
        popular_creators = [creator for creator, total in creator_total_views.items() if total == max_popularity]
        
        result = []
        for creator in popular_creators:
            videos = creator_videos[creator]
            max_view = max(v[0] for v in videos)
            candidates = [v[1] for v in videos if v[0] == max_view]
            candidates.sort()
            result.append([creator, candidates[0]])
        
        return result
```",Y,
sum-of-number-and-its-reverse,Sum of Number and Its Reverse,"```python
class Solution:
    def sumOfNumberAndReverse(self, num: int) -> bool:
        for i in range(num + 1):
            reversed_i = int(str(i)[::-1])
            if i + reversed_i == num:
                return True
        return False
```",Y,
bitwise-xor-of-all-pairings,Bitwise XOR of All Pairings,"```python
from typing import List

class Solution:
    def xorAllNums(self, nums1: List[int], nums2: List[int]) -> int:
        xor1 = 0
        xor2 = 0
        len1 = len(nums1)
        len2 = len(nums2)
        
        for num in nums1:
            xor1 ^= num
        
        for num in nums2:
            xor2 ^= num
        
        if len1 % 2 == 0 and len2 % 2 == 0:
            return 0
        elif len1 % 2 == 0:
            return xor1
        elif len2 % 2 == 0:
            return xor2
        else:
            return xor1 ^ xor2
```",Y,
minimize-maximum-of-array,Minimize Maximum of Array,"```python
class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        total = 0
        res = 0
        for i in range(len(nums)):
            total += nums[i]
            res = max(res, (total + i) // (i + 1))
        return res
```",Y,
range-product-queries-of-powers,Range Product Queries of Powers,"```python
class Solution:
    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        MOD = 10**9 + 7
        powers = []
        current_power = 1
        while current_power <= n:
            if n & current_power:
                powers.append(current_power)
            current_power <<= 1
        
        prefix = [1] * (len(powers) + 1)
        for i in range(len(powers)):
            prefix[i+1] = (prefix[i] * powers[i]) % MOD
        
        answers = []
        for left, right in queries:
            inv = pow(prefix[left], MOD-2, MOD)
            product = (prefix[right+1] * inv) % MOD
            answers.append(product)
        return answers
```",Y,
count-number-of-distinct-integers-after-reverse-operations,Count Number of Distinct Integers After Reverse Operations,"```python
class Solution:
    def countDistinctIntegers(self, nums: List[int]) -> int:
        distinct = set(nums)
        for num in nums:
            reversed_num = int(str(num)[::-1])
            distinct.add(reversed_num)
        return len(distinct)
```",Y,
using-a-robot-to-print-the-lexicographically-smallest-string,Using a Robot to Print the Lexicographically Smallest String,"```python
class Solution:
    def robotWithString(self, s: str) -> str:
        t = []
        res = []
        freq = [0] * 26
        for c in s:
            freq[ord(c) - ord('a')] += 1
        
        for c in s:
            t.append(c)
            freq[ord(c) - ord('a')] -= 1
            while t:
                current = t[-1]
                has_smaller = False
                for i in range(ord(current) - ord('a')):
                    if freq[i] > 0:
                        has_smaller = True
                        break
                if not has_smaller:
                    res.append(t.pop())
                else:
                    break
        return ''.join(res)
```",Y,
find-the-original-array-of-prefix-xor,Find The Original Array of Prefix Xor,"```python
from typing import List

class Solution:
    def findArray(self, pref: List[int]) -> List[int]:
        arr = [pref[0]]
        for i in range(1, len(pref)):
            arr.append(pref[i] ^ pref[i-1])
        return arr
```",Y,
longest-uploaded-prefix,Longest Uploaded Prefix,"```python
class LUPrefix:

    def __init__(self, n: int):
        self.uploaded = set()
        self.longest_prefix = 0

    def upload(self, video: int) -> None:
        self.uploaded.add(video)
        while self.longest_prefix + 1 in self.uploaded:
            self.longest_prefix += 1

    def longest(self) -> int:
        return self.longest_prefix


```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
partition-string-into-substrings-with-values-at-most-k,Partition String Into Substrings With Values at Most K,"```python
class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        n = len(s)
        res = 0
        current = 0
        for c in s:
            digit = int(c)
            if digit > k:
                return -1
            if current * 10 + digit > k:
                res += 1
                current = digit
            else:
                current = current * 10 + digit
        return res + 1
```",Y,
minimize-xor,Minimize XOR,"```python
class Solution:
    def minimizeXor(self, num1: int, num2: int) -> int:
        count = bin(num2).count('1')
        num1_bits = bin(num1)[2:]
        res = ['0'] * len(num1_bits)
        
        for i in range(len(num1_bits)):
            if count == 0:
                break
            if num1_bits[i] == '1':
                res[i] = '1'
                count -= 1
        
        for i in range(len(num1_bits) - 1, -1, -1):
            if count == 0:
                break
            if res[i] == '0':
                res[i] = '1'
                count -= 1
        
        remaining_bits = []
        while count > 0:
            remaining_bits.append('1')
            count -= 1
        res = remaining_bits + res
        
        return int(''.join(res), 2)
```",Y,
maximum-sum-of-an-hourglass,Maximum Sum of an Hourglass,"```python
from typing import List

class Solution:
    def maxSum(self, grid: List[List[int]]) -> int:
        max_sum = 0
        m = len(grid)
        n = len(grid[0])
        
        for i in range(m - 2):
            for j in range(n - 2):
                current_sum = (
                    grid[i][j] + grid[i][j+1] + grid[i][j+2] +
                    grid[i+1][j+1] +
                    grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]
                )
                if current_sum > max_sum:
                    max_sum = current_sum
        
        return max_sum
```",Y,
find-all-good-indices,Find All Good Indices,"```python
from typing import List

class Solution:
    def goodIndices(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        non_inc = [1] * n
        non_dec = [1] * n
        
        for i in range(1, n):
            if nums[i] <= nums[i-1]:
                non_inc[i] = non_inc[i-1] + 1
        
        for i in range(n-2, -1, -1):
            if nums[i] <= nums[i+1]:
                non_dec[i] = non_dec[i+1] + 1
        
        res = []
        for i in range(k, n - k):
            if non_inc[i-1] >= k and non_dec[i+1] >= k:
                res.append(i)
        
        return res
```",Y,
longest-subarray-with-maximum-bitwise-and,Longest Subarray With Maximum Bitwise AND,"```python
from typing import List

class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        max_and = max(nums)
        max_length = 0
        current_length = 0
        
        for num in nums:
            if num == max_and:
                current_length += 1
                max_length = max(max_length, current_length)
            else:
                current_length = 0
        
        return max_length
```",Y,
smallest-subarrays-with-maximum-bitwise-or,Smallest Subarrays With Maximum Bitwise OR,"```python
class Solution:
    def smallestSubarrays(self, nums: List[int]) -> List[int]:
        n = len(nums)
        answer = [1] * n
        bits = [0] * 32
        left = n - 1
        
        for i in range(n - 1, -1, -1):
            num = nums[i]
            for j in range(32):
                if num & (1 << j):
                    bits[j] = i
            max_or_pos = max(bits)
            answer[i] = max_or_pos - i + 1 if max_or_pos != 0 else 1
        
        return answer
```",Y,
maximum-matching-of-players-with-trainers,Maximum Matching of Players With Trainers,"```python
class Solution:
    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:
        players.sort()
        trainers.sort()
        i = j = count = 0
        while i < len(players) and j < len(trainers):
            if players[i] <= trainers[j]:
                count += 1
                i += 1
                j += 1
            else:
                j += 1
        return count
```",Y,
reverse-odd-levels-of-binary-tree,Reverse Odd Levels of Binary Tree,"```python
from collections import deque

class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        
        queue = deque([root])
        level = 0
        
        while queue:
            size = len(queue)
            if level % 2 == 1:
                values = [node.val for node in queue]
                values = values[::-1]
                for i in range(size):
                    queue[i].val = values[i]
            
            for _ in range(size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            level += 1
        
        return root
```",Y,
length-of-the-longest-alphabetical-continuous-substring,Length of the Longest Alphabetical Continuous Substring,"```python
class Solution:
    def longestContinuousSubstring(self, s: str) -> int:
        max_len = 1
        current_len = 1
        for i in range(1, len(s)):
            if ord(s[i]) - ord(s[i-1]) == 1:
                current_len += 1
                max_len = max(max_len, current_len)
            else:
                current_len = 1
        return max_len
```",Y,
divide-intervals-into-minimum-number-of-groups,Divide Intervals Into Minimum Number of Groups,"```python
import heapq

class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        heap = []
        for start, end in intervals:
            if heap and heap[0] < start:
                heapq.heappop(heap)
            heapq.heappush(heap, end)
        return len(heap)
```",Y,
optimal-partition-of-string,Optimal Partition of String,"```python
class Solution:
    def partitionString(self, s: str) -> int:
        count = 1
        seen = set()
        for char in s:
            if char in seen:
                count += 1
                seen = set()
            seen.add(char)
        return count
```",Y,
count-beautiful-numbers,Count Beautiful Numbers,"```python
class Solution:
    def beautifulNumbers(self, l: int, r: int) -> int:
        count = 0
        for num in range(l, r + 1):
            digits = list(map(int, str(num)))
            sum_digits = sum(digits)
            if sum_digits == 0:
                continue
            product = 1
            for d in digits:
                product *= d
            if product % sum_digits == 0:
                count += 1
        return count
```",Y,
longest-special-path-ii,Longest Special Path II,"```python
from collections import defaultdict
from typing import List

class Solution:
    def longestSpecialPath(self, edges: List[List[int]], nums: List[int]) -> List[int]:
        tree = defaultdict(list)
        for u, v, length in edges:
            tree[u].append((v, length))
            tree[v].append((u, length))
        
        root = 0
        parent = {root: -1}
        children = defaultdict(list)
        stack = [root]
        while stack:
            node = stack.pop()
            for neighbor, length in tree[node]:
                if neighbor != parent[node]:
                    parent[neighbor] = node
                    children[node].append((neighbor, length))
                    stack.append(neighbor)
        
        max_length = 0
        min_nodes = float('inf')
        
        
        def dfs(node):
            nonlocal max_length, min_nodes
            paths = []
            current_val = nums[node]
            single_path = {current_val: (0, 1)}  # length, node count
            double_paths = {}  # key: duplicated value, value: (length, node count)
            
            for child, length in children[node]:
                child_single, child_double = dfs(child)
                for val in child_single:
                    child_len, child_nodes = child_single[val]
                    new_len = child_len + length
                    new_nodes = child_nodes + 1
                    if val == current_val:
                        if current_val in double_paths:
                            existing_len, existing_nodes = double_paths[current_val]
                            if new_len > existing_len or (new_len == existing_len and new_nodes < existing_nodes):
                                double_paths[current_val] = (new_len, new_nodes)
                        else:
                            double_paths[current_val] = (new_len, new_nodes)
                    else:
                        if val in single_path:
                            existing_len, existing_nodes = single_path[val]
                            if new_len > existing_len or (new_len == existing_len and new_nodes < existing_nodes):
                                single_path[val] = (new_len, new_nodes)
                        else:
                            single_path[val] = (new_len, new_nodes)
                
                for val in child_double:
                    child_len, child_nodes = child_double[val]
                    new_len = child_len + length
                    new_nodes = child_nodes + 1
                    if val in double_paths:
                        existing_len, existing_nodes = double_paths[val]
                        if new_len > existing_len or (new_len == existing_len and new_nodes < existing_nodes):
                            double_paths[val] = (new_len, new_nodes)
                    else:
                        double_paths[val] = (new_len, new_nodes)
            
            single_path[current_val] = max(single_path.get(current_val, (0, 1)), (0, 1))
            
            for val in single_path:
                length, nodes = single_path[val]
                if length > max_length:
                    max_length = length
                    min_nodes = nodes
                elif length == max_length:
                    if nodes < min_nodes:
                        min_nodes = nodes
            
            for val in double_paths:
                length, nodes = double_paths[val]
                if length > max_length:
                    max_length = length
                    min_nodes = nodes
                elif length == max_length:
                    if nodes < min_nodes:
                        min_nodes = nodes
            
            return (single_path, double_paths)
        
        dfs(root)
        return [max_length, min_nodes]
```",Y,
maximize-subarrays-after-removing-one-conflicting-pair,Maximize Subarrays After Removing One Conflicting Pair,"```python
from typing import List

class Solution:
    def maxSubarrays(self, n: int, conflictingPairs: List[List[int]]) -> int:
        if not conflictingPairs:
            return n * (n + 1) // 2
        
        max_subarrays = 0
        
        for i in range(len(conflictingPairs)):
            temp_pairs = conflictingPairs[:i] + conflictingPairs[i+1:]
            conflict_dict = {}
            for a, b in temp_pairs:
                if a not in conflict_dict:
                    conflict_dict[a] = set()
                if b not in conflict_dict:
                    conflict_dict[b] = set()
                conflict_dict[a].add(b)
                conflict_dict[b].add(a)
            
            total = n * (n + 1) // 2
            invalid = 0
            left = 0
            for right in range(1, n + 1):
                current = right
                if current in conflict_dict:
                    for neighbor in conflict_dict[current]:
                        while left < right and neighbor in range(left + 1, right + 1):
                            left += 1
                invalid += right - left
            
            current_subarrays = total - invalid
            if current_subarrays > max_subarrays:
                max_subarrays = current_subarrays
        
        return max_subarrays
```",Y,
longest-common-prefix-of-k-strings-after-removal,Longest Common Prefix of K Strings After Removal,"```python
from typing import List
from collections import defaultdict

class Solution:
    def longestCommonPrefix(self, words: List[str], k: int) -> List[int]:
        n = len(words)
        if n - 1 < k:
            return [0] * n
        
        prefix_maps = []
        for word in words:
            prefix_map = defaultdict(int)
            for l in range(1, len(word)+1):
                prefix = word[:l]
                prefix_map[prefix] += 1
            prefix_maps.append(prefix_map)
        
        result = []
        for i in range(n):
            merged = defaultdict(int)
            for j in range(n):
                if j == i:
                    continue
                for prefix in prefix_maps[j]:
                    merged[prefix] += prefix_maps[j][prefix]
            
            max_len = 0
            for prefix in merged:
                if merged[prefix] >= k:
                    if len(prefix) > max_len:
                        max_len = len(prefix)
            result.append(max_len)
        
        return result
```",Y,
permutations-iv,Permutations IV,"```python
class Solution:
    def permute(self, n: int, k: int) -> List[int]:
        from itertools import permutations
        
        nums = list(range(1, n + 1))
        alternating_perms = []
        
        for perm in permutations(nums):
            is_alternating = True
            for i in range(len(perm) - 1):
                if (perm[i] % 2) == (perm[i + 1] % 2):
                    is_alternating = False
                    break
            if is_alternating:
                alternating_perms.append(list(perm))
        
        if k <= len(alternating_perms):
            return alternating_perms[k - 1]
        else:
            return []
```",Y,
maximize-the-distance-between-points-on-a-square,Maximize the Distance Between Points on a Square,"```python
from typing import List

class Solution:
    def maxDistance(self, side: int, points: List[List[int]], k: int) -> int:
        def manhattan(p1, p2):
            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
        
        points.sort()
        left, right = 0, 2 * side
        best = 0
        
        def is_possible(mid):
            count = 1
            last = points[0]
            for point in points[1:]:
                if manhattan(last, point) >= mid:
                    count += 1
                    last = point
                    if count >= k:
                        return True
            return count >= k
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                best = mid
                left = mid + 1
            else:
                right = mid - 1
        return best
```",Y,
separate-squares-ii,Separate Squares II,"```python
class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        events = []
        for x, y, l in squares:
            top = y + l
            events.append((y, 1, x, x + l))
            events.append((top, -1, x, x + l))
        
        events.sort()
        
        active_intervals = []
        total_area = 0
        prev_y = None
        
        for y, typ, x1, x2 in events:
            if prev_y is not None and y != prev_y and active_intervals:
                delta_y = y - prev_y
                merged = []
                for interval in sorted(active_intervals):
                    if not merged:
                        merged.append(interval)
                    else:
                        last_x1, last_x2 = merged[-1]
                        if interval[0] <= last_x2:
                            merged[-1] = (last_x1, max(last_x2, interval[1]))
                        else:
                            merged.append(interval)
                current_width = 0
                for (start, end) in merged:
                    current_width += end - start
                total_area += current_width * delta_y
            
            if typ == 1:
                active_intervals.append((x1, x2))
            else:
                active_intervals.remove((x1, x2))
            
            prev_y = y
        
        target = total_area / 2
        
        events = []
        for x, y, l in squares:
            top = y + l
            events.append((y, 1, x, x + l))
            events.append((top, -1, x, x + l))
        
        events.sort()
        
        active_intervals = []
        current_area = 0
        prev_y = None
        result = 0.0
        
        for y, typ, x1, x2 in events:
            if prev_y is not None and y != prev_y and active_intervals:
                delta_y = y - prev_y
                merged = []
                for interval in sorted(active_intervals):
                    if not merged:
                        merged.append(interval)
                    else:
                        last_x1, last_x2 = merged[-1]
                        if interval[0] <= last_x2:
                            merged[-1] = (last_x1, max(last_x2, interval[1]))
                        else:
                            merged.append(interval)
                current_width = 0
                for (start, end) in merged:
                    current_width += end - start
                if current_area + current_width * delta_y >= target:
                    remaining = target - current_area
                    result = prev_y + remaining / current_width
                    return result
                current_area += current_width * delta_y
            
            if typ == 1:
                active_intervals.append((x1, x2))
            else:
                active_intervals.remove((x1, x2))
            
            prev_y = y
        
        return result
```",Y,
check-if-digits-are-equal-in-string-after-operations-ii,Check If Digits Are Equal in String After Operations II,"```python
class Solution:
    def hasSameDigits(self, s: str) -> bool:
        while len(s) > 2:
            new_s = []
            for i in range(len(s) - 1):
                new_digit = (int(s[i]) + int(s[i+1])) % 10
                new_s.append(str(new_digit))
            s = ''.join(new_s)
        return s[0] == s[1]
```",Y,
lexicographically-smallest-generated-string,Lexicographically Smallest Generated String,"```python
class Solution:
    def generateString(self, str1: str, str2: str) -> str:
        n = len(str1)
        m = len(str2)
        if n == 0 or m == 0:
            return """"
        
        total_length = n + m - 1
        result = ['a'] * total_length
        
        for i in range(n):
            if str1[i] == 'T':
                if i + m > total_length:
                    return """"
                for k in range(m):
                    if result[i + k] == 'a' or result[i + k] == str2[k]:
                        result[i + k] = str2[k]
                    else:
                        return """"
        
        for i in range(n):
            if str1[i] == 'F':
                if i + m > total_length:
                    continue  # out of bounds, no need to check
                match = True
                for k in range(m):
                    if i + k >= total_length:
                        match = False
                        break
                    if result[i + k] != 'a' and result[i + k] != str2[k]:
                        match = False
                        break
                if match:
                    found = False
                    for k in range(m):
                        if i + k >= total_length:
                            break
                        if result[i + k] == 'a':
                            for c in 'abcdefghijklmnopqrstuvwxyz':
                                if c != str2[k]:
                                    result[i + k] = c
                                    found = True
                                    break
                            if found:
                                break
                    if not found:
                        return """"
        
        for i in range(n):
            if i + m > total_length:
                continue
            substring = ''.join(result[i:i+m])
            if str1[i] == 'T':
                if substring != str2:
                    return """"
            else:
                if substring == str2:
                    return """"
        
        return ''.join(result)
```",Y,
maximize-the-minimum-game-score,Maximize the Minimum Game Score,"```python
class Solution:
    def maxScore(self, points: List[int], m: int) -> int:
        left, right = 1, sum(points)
        n = len(points)
        
        def is_possible(min_val):
            total_moves = 0
            current_sum = 0
            for num in points:
                current_sum += num
                if current_sum >= min_val:
                    total_moves += 1
                    current_sum = 0
                    if total_moves >= m:
                        return True
            return False
        
        result = 0
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                result = mid
                left = mid + 1
            else:
                right = mid - 1
        return result
```",Y,
maximum-difference-between-even-and-odd-frequency-ii,Maximum Difference Between Even and Odd Frequency II,"```python
class Solution:
    def maxDifference(self, s: str, k: int) -> int:
        max_diff = -float('inf')
        n = len(s)
        
        for i in range(n - k + 1):
            for j in range(i + k, n + 1):
                substr = s[i:j]
                freq = {}
                for c in substr:
                    freq[c] = freq.get(c, 0) + 1
                
                max_odd = -float('inf')
                min_even = float('inf')
                
                for c in freq:
                    if freq[c] % 2 == 1:
                        if freq[c] > max_odd:
                            max_odd = freq[c]
                    else:
                        if freq[c] < min_even:
                            min_even = freq[c]
                
                if max_odd != -float('inf') and min_even != float('inf'):
                    current_diff = max_odd - min_even
                    if current_diff > max_diff:
                        max_diff = current_diff
        
        return max_diff if max_diff != -float('inf') else -1
```",Y,
minimum-operations-to-make-array-elements-zero,Minimum Operations to Make Array Elements Zero,"```python
import math
from typing import List

class Solution:
    def minOperations(self, queries: List[List[int]]) -> int:
        total_operations = 0
        
        for l, r in queries:
            max_num = r
            operations = 0
            while max_num > 0:
                operations += 1
                max_num = max_num // 4
            total_operations += operations
        
        return total_operations
```",Y,
manhattan-distances-of-all-arrangements-of-pieces,Manhattan Distances of All Arrangements of Pieces,"```python
class Solution:
    def distanceSum(self, m: int, n: int, k: int) -> int:
        MOD = 10**9 + 7
        
        def compute_S(N, k):
            if N < k:
                return 0
            total = 0
            for d in range(1, N):
                cnt = (N - d) * d
                ways = comb(N * n_total - 2, k - 2) if m * n_total >= k else 0
                total += cnt * ways
            return total
        
        n_total = n
        m_total = m
        total_cells = m * n
        
        if k < 2 or total_cells < k:
            return 0
        
        max_n = total_cells
        fact = [1] * (max_n + 1)
        inv_fact = [1] * (max_n + 1)
        
        for i in range(1, max_n + 1):
            fact[i] = fact[i-1] * i % MOD
        
        inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)
        for i in range(max_n - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD
        
        def comb(a, b):
            if a < 0 or b < 0 or a < b:
                return 0
            return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD
        
        x_sum = 0
        for d in range(1, m):
            cnt = (m - d) * d * n * n
            ways = comb(total_cells - 2, k - 2)
            x_sum = (x_sum + cnt * ways) % MOD
        
        y_sum = 0
        for d in range(1, n):
            cnt = (n - d) * d * m * m
            ways = comb(total_cells - 2, k - 2)
            y_sum = (y_sum + cnt * ways) % MOD
        
        total = (x_sum + y_sum) % MOD
        return total
```",Y,
length-of-longest-v-shaped-diagonal-segment,Length of Longest V-Shaped Diagonal Segment,"```python
from typing import List

class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        n, m = len(grid), len(grid[0])
        max_len = 0
        
        directions = [(-1, -1), (-1, 1), (1, -1), (1, 1)]
        
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    for di, dj in directions:
                        length = 1
                        ni, nj = i + di, j + dj
                        step = 0  # 0 means next should be 2, 1 means next should be 0
                        while 0 <= ni < n and 0 <= nj < m:
                            expected = 2 if step % 2 == 0 else 0
                            if grid[ni][nj] != expected:
                                break
                            length += 1
                            step += 1
                            ni += di
                            nj += dj
                        
                        if length >= 2:
                            new_di, new_dj = dj, di
                            ni_turn, nj_turn = ni - di + new_di, nj - dj + new_dj
                            step_turn = step
                            temp_len = length
                            
                            while 0 <= ni_turn < n and 0 <= nj_turn < m:
                                expected = 2 if step_turn % 2 == 0 else 0
                                if grid[ni_turn][nj_turn] != expected:
                                    break
                                temp_len += 1
                                step_turn += 1
                                ni_turn += new_di
                                nj_turn += new_dj
                            
                            if temp_len > max_len:
                                max_len = temp_len
                        
                        if length > max_len:
                            max_len = length
        
        return max_len if max_len != 0 else 1 if any(grid[i][j] == 1 for i in range(n) for j in range(m)) else 0
```",Y,
maximum-and-minimum-sums-of-at-most-size-k-subarrays,Maximum and Minimum Sums of at Most Size K Subarrays,"```python
from collections import deque
from typing import List

class Solution:
    def minMaxSubarraySum(self, nums: List[int], k: int) -> int:
        total = 0
        
        def compute_sum(is_max):
            dq = deque()
            res = 0
            for i, num in enumerate(nums):
                while dq and nums[dq[-1]] <= num if is_max else nums[dq[-1]] >= num:
                    dq.pop()
                dq.append(i)
                while dq[0] <= i - k:
                    dq.popleft()
                res += nums[dq[0]]
            return res
        
        max_sum = 0
        min_sum = 0
        
        for window_size in range(1, k + 1):
            current_max = 0
            current_min = 0
            dq_max = deque()
            dq_min = deque()
            
            for i in range(len(nums)):
                while dq_max and nums[dq_max[-1]] <= nums[i]:
                    dq_max.pop()
                dq_max.append(i)
                if dq_max[0] <= i - window_size:
                    dq_max.popleft()
                
                while dq_min and nums[dq_min[-1]] >= nums[i]:
                    dq_min.pop()
                dq_min.append(i)
                if dq_min[0] <= i - window_size:
                    dq_min.popleft()
                
                if i >= window_size - 1:
                    current_max += nums[dq_max[0]]
                    current_min += nums[dq_min[0]]
            
            max_sum += current_max
            min_sum += current_min
        
        return max_sum + min_sum
```",Y,
frequencies-of-shortest-supersequences,Frequencies of Shortest Supersequences,"```python
from typing import List
from collections import defaultdict

class Solution:
    def supersequences(self, words: List[str]) -> List[List[int]]:
        all_chars = set()
        for word in words:
            all_chars.update(word)
        sorted_chars = sorted(all_chars)
        
        word_freqs = []
        for word in words:
            freq = defaultdict(int)
            for c in word:
                freq[c] += 1
            word_freqs.append(freq)
        
        total_freq = defaultdict(int)
        for freq in word_freqs:
            for c in freq:
                total_freq[c] = max(total_freq[c], freq[c])
        
        def are_permutations(freqs):
            if not freqs:
                return True
            first = freqs[0]
            for freq in freqs[1:]:
                if freq != first:
                    return False
            return True
        
        if are_permutations(word_freqs):
            scs_freq = [0] * 26
            for c in total_freq:
                scs_freq[ord(c) - ord('a')] = total_freq[c]
            return [scs_freq]
        
        
        
        
        
        
        
        
        chars = []
        for word in words:
            chars.extend(list(word))
        
        
        
        
        
        
        from functools import lru_cache
        
        
        
        
        
        
        
        if len(words) == 1:
            freq = [0] * 26
            for c in words[0]:
                freq[ord(c) - ord('a')] += 1
            return [freq]
        
        if len(words) == 2:
            a, b = words[0], words[1]
            scs_candidates = []
            scs1 = a + b
            scs_candidates.append(scs1)
            if a[1] == b[0]:
                scs2 = a[0] + a[1] + b[1]
                scs_candidates.append(scs2)
            if a == b:
                scs_candidates = [a + a[1]]  # or just a?
            
            
            freq_list = []
            for scs in scs_candidates:
                freq = [0] * 26
                for c in scs:
                    freq[ord(c) - ord('a')] += 1
                freq_list.append(freq)
            
            unique_freqs = []
            seen = set()
            for freq in freq_list:
                key = tuple(sorted((chr(i + ord('a')), freq[i]) for i in range(26) if freq[i] > 0))
                if key not in seen:
                    seen.add(key)
                    unique_freqs.append(freq)
            
            return unique_freqs
        
        
        
        
        
        if are_permutations(word_freqs):
            scs_freq = [0] * 26
            for c in total_freq:
                scs_freq[ord(c) - ord('a')] = total_freq[c]
            return [scs_freq]
        
        scs_freq = [0] * 26
        for c in total_freq:
            scs_freq[ord(c) - ord('a')] = total_freq[c]
        return [scs_freq]
```",Y,
smallest-substring-with-identical-characters-ii,Smallest Substring With Identical Characters II,"```python
class Solution:
    def minLength(self, s: str, numOps: int) -> int:
        if not s:
            return 0
        
        def get_min_run(ch):
            runs = []
            current_run = 0
            for c in s:
                if c == ch:
                    current_run += 1
                else:
                    if current_run > 0:
                        runs.append(current_run)
                    current_run = 0
            if current_run > 0:
                runs.append(current_run)
            if not runs:
                return 0
            runs.sort()
            total_ops = numOps
            i = 0
            n = len(runs)
            while i < n - 1 and total_ops > 0:
                diff = runs[i+1] - runs[i]
                ops_needed = (i + 1) * diff
                if ops_needed <= total_ops:
                    total_ops -= ops_needed
                    for j in range(i + 1):
                        runs[j] += diff
                else:
                    add = total_ops // (i + 1)
                    remaining = total_ops % (i + 1)
                    for j in range(i + 1):
                        runs[j] += add
                    for j in range(remaining):
                        runs[j] += 1
                    total_ops = 0
                i += 1
            if total_ops > 0:
                add = total_ops // n
                remaining = total_ops % n
                for j in range(n):
                    runs[j] += add
                for j in range(remaining):
                    runs[j] += 1
            return max(runs) if runs else 0
        
        min_0 = get_min_run('0')
        min_1 = get_min_run('1')
        return min(min_0, min_1)
```",Y,
minimum-cost-good-caption,Minimum Cost Good Caption,"```python
class Solution:
    def minCostGoodCaption(self, caption: str) -> str:
        if not caption:
            return """"
        
        n = len(caption)
        if n < 3:
            return """"
        
        runs = []
        current_char = caption[0]
        count = 1
        for c in caption[1:]:
            if c == current_char:
                count += 1
            else:
                runs.append((current_char, count))
                current_char = c
                count = 1
        runs.append((current_char, count))
        
        
        
        all_good = True
        for c, cnt in runs:
            if cnt < 3:
                all_good = False
                break
        if all_good:
            return caption
        
        possible_chars = set()
        for i in range(len(runs)):
            c, cnt = runs[i]
            possible_chars.add(c)
            if c != 'a':
                possible_chars.add(chr(ord(c) - 1))
            if c != 'z':
                possible_chars.add(chr(ord(c) + 1))
        
        min_cost = float('inf')
        best_candidate = None
        
        for target in sorted(possible_chars):
            total_cost = 0
            possible = True
            
            
            
            current_seg_len = 0
            current_seg_cost = 0
            total_segments = 0
            total_seg_cost = 0
            valid = True
            
            for c, cnt in runs:
                cost = 0
                for orig_c in c:
                    if orig_c == target:
                        cost_add = 0
                    else:
                        if target > orig_c:
                            cost_add = ord(target) - ord(orig_c)
                        else:
                            cost_add = ord(orig_c) - ord(target)
                    cost += cost_add
                
                if current_seg_len == 0:
                    current_seg_len = cnt
                    current_seg_cost = cost
                else:
                    current_seg_len += cnt
                    current_seg_cost += cost
                
                if current_seg_len >=3:
                    total_segments += 1
                    total_seg_cost += current_seg_cost
                    current_seg_len = 0
                    current_seg_cost = 0
            
            if current_seg_len > 0:
                valid = False
            
            if valid and total_seg_cost < min_cost:
                min_cost = total_seg_cost
                best_candidate = target * n
            elif valid and total_seg_cost == min_cost:
                candidate = target * n
                if candidate < best_candidate:
                    best_candidate = candidate
        
        if best_candidate is not None:
            return best_candidate
        
        if n >=3:
            min_full_cost = float('inf')
            best_full_candidate = None
            for target in sorted(set(caption)):
                total_cost = 0
                for c in caption:
                    total_cost += abs(ord(c) - ord(target))
                if total_cost < min_full_cost:
                    min_full_cost = total_cost
                    best_full_candidate = target * n
                elif total_cost == min_full_cost:
                    candidate = target * n
                    if candidate < best_full_candidate:
                        best_full_candidate = candidate
            if best_full_candidate is not None:
                return best_full_candidate
        
        return """"
```",Y,
subsequences-with-a-unique-middle-mode-i,Subsequences with a Unique Middle Mode I,"```python
from typing import List
from collections import defaultdict

class Solution:
    def subsequencesWithMiddleMode(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        count = 0
        n = len(nums)
        
        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j + 1, n):
                    for l in range(k + 1, n):
                        for m in range(l + 1, n):
                            subsequence = [nums[i], nums[j], nums[k], nums[l], nums[m]]
                            freq = defaultdict(int)
                            for num in subsequence:
                                freq[num] += 1
                            max_freq = max(freq.values())
                            modes = [num for num, cnt in freq.items() if cnt == max_freq]
                            if len(modes) == 1 and modes[0] == subsequence[2]:
                                count += 1
        
        return count % MOD
```",Y,
minimum-increments-for-target-multiples-in-an-array,Minimum Increments for Target Multiples in an Array,"```python
from typing import List

class Solution:
    def minimumIncrements(self, nums: List[int], target: List[int]) -> int:
        nums.sort()
        target.sort()
        res = 0
        used = [False] * len(nums)
        
        for t in target:
            min_ops = float('inf')
            best_idx = -1
            for i in range(len(nums)):
                if not used[i]:
                    if nums[i] >= t:
                        ops = 0
                        if ops < min_ops:
                            min_ops = ops
                            best_idx = i
                        break
                    else:
                        remainder = t % nums[i]
                        if remainder == 0:
                            ops = 0
                            if ops < min_ops:
                                min_ops = ops
                                best_idx = i
                                break
                        else:
                            ops = nums[i] - remainder
                            if ops < min_ops:
                                min_ops = ops
                                best_idx = i
            if best_idx != -1:
                res += min_ops
                nums[best_idx] += min_ops
                used[best_idx] = True
        
        return res
```",Y,
count-substrings-divisible-by-last-digit,Count Substrings Divisible By Last Digit,"```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        count = 0
        n = len(s)
        for i in range(n):
            for j in range(i, n):
                last_digit = int(s[j])
                if last_digit == 0:
                    continue
                num = int(s[i:j+1])
                if num % last_digit == 0:
                    count += 1
        return count
```",Y,
shortest-matching-substring,Shortest Matching Substring,"```python
class Solution:
    def shortestMatchingSubstring(self, s: str, p: str) -> int:
        star_indices = [i for i, ch in enumerate(p) if ch == '*']
        if len(star_indices) != 2:
            return -1
        
        prefix = p[:star_indices[0]]
        middle = p[star_indices[0]+1:star_indices[1]]
        suffix = p[star_indices[1]+1:]
        
        min_len = float('inf')
        
        prefix_matches = []
        n = len(s)
        m_prefix = len(prefix)
        if m_prefix == 0:
            prefix_matches = list(range(n+1))
        else:
            for i in range(n - m_prefix + 1):
                if s[i:i+m_prefix] == prefix:
                    prefix_matches.append(i + m_prefix)
        
        suffix_matches = []
        m_suffix = len(suffix)
        if m_suffix == 0:
            suffix_matches = list(range(n+1))
        else:
            for j in range(m_suffix, n+1):
                if s[j-m_suffix:j] == suffix:
                    suffix_matches.append(j - m_suffix)
        
        m_middle = len(middle)
        if m_middle == 0:
            for start in prefix_matches:
                for end in suffix_matches:
                    if end >= start:
                        current_len = end - start
                        if current_len < min_len:
                            min_len = current_len
        else:
            middle_indices = []
            for i in range(n - m_middle + 1):
                if s[i:i+m_middle] == middle:
                    middle_indices.append(i)
            
            for prefix_end in prefix_matches:
                left = 0
                right = len(middle_indices)
                low, high = 0, len(middle_indices) - 1
                first_middle = -1
                while low <= high:
                    mid = (low + high) // 2
                    if middle_indices[mid] >= prefix_end:
                        first_middle = mid
                        high = mid - 1
                    else:
                        low = mid + 1
                if first_middle == -1:
                    continue
                middle_start = middle_indices[first_middle]
                middle_end = middle_start + m_middle
                
                low_suffix, high_suffix = 0, len(suffix_matches) - 1
                first_suffix = -1
                while low_suffix <= high_suffix:
                    mid_suffix = (low_suffix + high_suffix) // 2
                    if suffix_matches[mid_suffix] >= middle_end:
                        first_suffix = mid_suffix
                        high_suffix = mid_suffix - 1
                    else:
                        low_suffix = mid_suffix + 1
                if first_suffix == -1:
                    continue
                suffix_start = suffix_matches[first_suffix]
                current_len = suffix_start - prefix_end
                if current_len < min_len:
                    min_len = current_len
        
        if min_len != float('inf'):
            return min_len
        else:
            return -1
```",Y,
smallest-substring-with-identical-characters-i,Smallest Substring With Identical Characters I,"```python
class Solution:
    def minLength(self, s: str, numOps: int) -> int:
        n = len(s)
        if n == 0:
            return 0
        
        def get_min_segment(target):
            segments = []
            current = 0
            for c in s:
                if c == target:
                    current += 1
                else:
                    if current > 0:
                        segments.append(current)
                    current = 0
            if current > 0:
                segments.append(current)
            if not segments:
                return 0
            segments.sort()
            ops = numOps
            i = len(segments) - 1
            while ops > 0 and i >= 0:
                max_seg = segments[i]
                if i == 0:
                    reduce = min(ops, max_seg)
                    segments[i] -= reduce
                    ops -= reduce
                else:
                    next_seg = segments[i-1]
                    diff = max_seg - next_seg
                    reduce = min(ops, diff)
                    segments[i] -= reduce
                    ops -= reduce
                i -= 1
            segments.sort()
            return segments[-1] if segments else 0
        
        res0 = get_min_segment('0')
        res1 = get_min_segment('1')
        
        return min(res0, res1) if numOps > 0 else max(res0, res1)
```",Y,
maximum-area-rectangle-with-point-constraints-ii,Maximum Area Rectangle With Point Constraints II,"```python
from typing import List
from collections import defaultdict

class Solution:
    def maxRectangleArea(self, xCoord: List[int], yCoord: List[int]) -> int:
        points = set(zip(xCoord, yCoord))
        x_to_ys = defaultdict(set)
        y_to_xs = defaultdict(set)
        
        for x, y in points:
            x_to_ys[x].add(y)
            y_to_xs[y].add(x)
        
        max_area = -1
        
        x_candidates = [x for x in x_to_ys if len(x_to_ys[x]) >= 2]
        x_candidates.sort()
        
        for i in range(len(x_candidates)):
            x1 = x_candidates[i]
            ys_x1 = sorted(x_to_ys[x1])
            for j in range(i + 1, len(x_candidates)):
                x2 = x_candidates[j]
                ys_x2 = sorted(x_to_ys[x2])
                
                common_ys = []
                ptr1, ptr2 = 0, 0
                while ptr1 < len(ys_x1) and ptr2 < len(ys_x2):
                    if ys_x1[ptr1] == ys_x2[ptr2]:
                        common_ys.append(ys_x1[ptr1])
                        ptr1 += 1
                        ptr2 += 1
                    elif ys_x1[ptr1] < ys_x2[ptr2]:
                        ptr1 += 1
                    else:
                        ptr2 += 1
                
                for k in range(len(common_ys)):
                    y1 = common_ys[k]
                    for l in range(k + 1, len(common_ys)):
                        y2 = common_ys[l]
                        has_internal_point = False
                        for x in range(x1 + 1, x2):
                            if x in x_to_ys:
                                ys = x_to_ys[x]
                                left = bisect.bisect_right(ys, y1)
                                right = bisect.bisect_left(ys, y2)
                                if left < right:
                                    has_internal_point = True
                                    break
                            if has_internal_point:
                                break
                        if not has_internal_point:
                            area = (x2 - x1) * (y2 - y1)
                            if area > max_area:
                                max_area = area
        return max_area
```",Y,
maximize-subarray-sum-after-removing-all-occurrences-of-one-element,Maximize Subarray Sum After Removing All Occurrences of One Element,"```python
from typing import List

class Solution:
    def maxSubarraySum(self, nums: List[int]) -> int:
        def kadane(arr):
            max_current = max_global = arr[0]
            for num in arr[1:]:
                max_current = max(num, max_current + num)
                max_global = max(max_global, max_current)
            return max_global
        
        max_original = kadane(nums)
        unique_elements = set(nums)
        max_after_removal = -float('inf')
        
        for x in unique_elements:
            filtered = [num for num in nums if num != x]
            if not filtered:
                continue
            current_max = kadane(filtered)
            if current_max > max_after_removal:
                max_after_removal = current_max
        
        return max(max_original, max_after_removal)
```",Y,
longest-special-path,Longest Special Path,"```python
from typing import List
from collections import defaultdict

class Solution:
    def longestSpecialPath(self, edges: List[List[int]], nums: List[int]) -> List[int]:
        n = len(nums)
        tree = defaultdict(list)
        for u, v, length in edges:
            tree[u].append((v, length))
            tree[v].append((u, length))
        
        max_length = 0
        min_nodes = float('inf')
        
        stack = [(0, -1, 0, set())]  # (node, parent, current_length, current_values)
        
        while stack:
            node, parent, current_length, current_values = stack.pop()
            if nums[node] in current_values:
                if current_length > max_length:
                    max_length = current_length
                    min_nodes = len(current_values)
                elif current_length == max_length:
                    if len(current_values) < min_nodes:
                        min_nodes = len(current_values)
                continue
            
            new_values = set(current_values)
            new_values.add(nums[node])
            
            is_leaf = True
            for neighbor, length in tree[node]:
                if neighbor != parent:
                    is_leaf = False
                    stack.append((neighbor, node, current_length + length, new_values))
            
            if is_leaf:
                path_length = current_length
                num_nodes = len(new_values)
                if path_length > max_length:
                    max_length = path_length
                    min_nodes = num_nodes
                elif path_length == max_length:
                    if num_nodes < min_nodes:
                        min_nodes = num_nodes
        
        return [max_length, min_nodes] if max_length != 0 else [0, 1]
```",Y,
count-the-number-of-arrays-with-k-matching-adjacent-elements,Count the Number of Arrays with K Matching Adjacent Elements,"```python
class Solution:
    def countGoodArrays(self, n: int, m: int, k: int) -> int:
        MOD = 10**9 + 7
        
        if k > n - 1:
            return 0
        
        
        
        max_n = n - 1
        fact = [1] * (max_n + 1)
        inv_fact = [1] * (max_n + 1)
        
        for i in range(1, max_n + 1):
            fact[i] = fact[i-1] * i % MOD
        
        inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)
        for i in range(max_n - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD
        
        def comb(a, b):
            if a < 0 or b < 0 or a < b:
                return 0
            return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD
        
        c = comb(n - 1, k)
        res = c * m % MOD
        exponent = (n - 1 - k)
        res = res * pow(m - 1, exponent, MOD) % MOD
        return res
```",Y,
count-connected-components-in-lcm-graph,Count Connected Components in LCM Graph,"```python
import math
from typing import List
from collections import defaultdict

class Solution:
    def countComponents(self, nums: List[int], threshold: int) -> int:
        parent = {}
        size = defaultdict(int)
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root == v_root:
                return
            if size[u_root] < size[v_root]:
                u_root, v_root = v_root, u_root
            parent[v_root] = u_root
            size[u_root] += size[v_root]
        
        num_set = set(nums)
        nums_sorted = sorted(num_set)
        for num in nums_sorted:
            parent[num] = num
            size[num] = 1
        
        for num in nums_sorted:
            if num > threshold:
                continue
            max_factor = math.isqrt(num) + 1
            for factor in range(1, max_factor):
                if num % factor == 0:
                    for neighbor in (factor, num // factor):
                        if neighbor != num and neighbor in num_set:
                            lcm = (num * neighbor) // math.gcd(num, neighbor)
                            if lcm <= threshold:
                                union(num, neighbor)
        
        roots = set()
        for num in nums:
            roots.add(find(num))
        return len(roots)
```",Y,
maximize-sum-of-weights-after-edge-removals,Maximize Sum of Weights after Edge Removals,"```python
from collections import defaultdict

class Solution:
    def maximizeSumOfWeights(self, edges: List[List[int]], k: int) -> int:
        adjacency = defaultdict(list)
        for u, v, w in edges:
            adjacency[u].append((v, w))
            adjacency[v].append((u, w))
        
        degrees = defaultdict(int)
        for u, v, _ in edges:
            degrees[u] += 1
            degrees[v] += 1
        
        heap = []
        for u in degrees:
            heap.append((-degrees[u], u))
        
        import heapq
        heapq.heapify(heap)
        
        edge_removed = set()
        total = sum(w for _, _, w in edges)
        removed_sum = 0
        
        while heap:
            neg_degree, u = heapq.heappop(heap)
            current_degree = -neg_degree
            if current_degree <= k:
                continue
            
            min_w = float('inf')
            min_edge = None
            for v, w in adjacency[u]:
                edge_key = tuple(sorted((u, v)))
                if edge_key not in edge_removed:
                    if w < min_w:
                        min_w = w
                        min_edge = edge_key
            
            if min_edge is not None:
                edge_removed.add(min_edge)
                removed_sum += min_w
                a, b = min_edge
                degrees[a] -= 1
                degrees[b] -= 1
                if degrees[a] > k:
                    heapq.heappush(heap, (-degrees[a], a))
                if degrees[b] > k:
                    heapq.heappush(heap, (-degrees[b], b))
        
        return total - removed_sum
```",Y,
count-non-decreasing-subarrays-after-k-operations,Count Non-Decreasing Subarrays After K Operations,"```python
class Solution:
    def countNonDecreasingSubarrays(self, nums: List[int], k: int) -> int:
        n = len(nums)
        total_subarrays = n * (n + 1) // 2
        non_decreasing = 0
        left = 0
        
        for right in range(1, n):
            if nums[right] >= nums[right - 1]:
                continue
            length = right - left
            non_decreasing += length * (length + 1) // 2
            left = right
        
        length = n - left
        non_decreasing += length * (length + 1) // 2
        
        res = non_decreasing
        left = 0
        
        for right in range(1, n):
            if nums[right] >= nums[right - 1]:
                continue",Y,
minimize-the-maximum-adjacent-element-difference,Minimize the Maximum Adjacent Element Difference,"```python
from typing import List

class Solution:
    def minDifference(self, nums: List[int]) -> int:
        known = [num for num in nums if num != -1]
        if not known:
            return 0
        
        min_val = min(known)
        max_val = max(known)
        
        candidates = []
        n = len(nums)
        
        for i in range(n):
            if nums[i] == -1:
                left = nums[i-1] if i > 0 else None
                right = nums[i+1] if i < n-1 else None
                
                if left is not None and left != -1:
                    candidates.append(left)
                if right is not None and right != -1:
                    candidates.append(right)
        
        if not candidates:
            return 0
        
        candidates.append(min_val)
        candidates.append(max_val)
        candidates.sort()
        
        min_diff = float('inf')
        for i in range(1, len(candidates)):
            diff = candidates[i] - candidates[i-1]
            if diff < min_diff:
                min_diff = diff
        
        max_diff = max_val - min_val
        return min(min_diff, max_diff)
```",Y,
find-the-maximum-number-of-fruits-collected,Find the Maximum Number of Fruits Collected,"```python
from typing import List

class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        if n == 0:
            return 0
        
        dp1 = [[0] * n for _ in range(n)]
        dp2 = [[0] * n for _ in range(n)]
        dp3 = [[0] * n for _ in range(n)]
        
        dp1[0][0] = fruits[0][0]
        dp2[0][n-1] = fruits[0][n-1]
        dp3[n-1][0] = fruits[n-1][0]
        
        for i in range(n):
            for j in range(n):
                if i == 0 and j == 0:
                    continue
                max_val = 0
                if i > 0 and j > 0:
                    max_val = max(max_val, dp1[i-1][j-1])
                if i > 0:
                    max_val = max(max_val, dp1[i-1][j])
                if j > 0:
                    max_val = max(max_val, dp1[i][j-1])
                if max_val > 0:
                    dp1[i][j] = max_val + fruits[i][j]
        
        for i in range(n):
            for j in range(n-1, -1, -1):
                if i == 0 and j == n-1:
                    continue
                max_val = 0
                if i > 0 and j < n-1:
                    max_val = max(max_val, dp2[i-1][j+1])
                if i > 0:
                    max_val = max(max_val, dp2[i-1][j])
                if j < n-1:
                    max_val = max(max_val, dp2[i][j+1])
                if max_val > 0:
                    dp2[i][j] = max_val + fruits[i][j]
        
        for i in range(n-1, -1, -1):
            for j in range(n):
                if i == n-1 and j == 0:
                    continue
                max_val = 0
                if i < n-1 and j > 0:
                    max_val = max(max_val, dp3[i+1][j-1])
                if j > 0:
                    max_val = max(max_val, dp3[i][j-1])
                if i < n-1:
                    max_val = max(max_val, dp3[i+1][j])
                if max_val > 0:
                    dp3[i][j] = max_val + fruits[i][j]
        
        max_fruits = 0
        for i in range(n):
            for j in range(n):
                total = dp1[i][j] + dp2[i][j] + dp3[i][j]
                if (i, j) == (0, 0):
                    total -= 2 * fruits[i][j]
                elif (i, j) == (0, n-1):
                    total -= 2 * fruits[i][j]
                elif (i, j) == (n-1, 0):
                    total -= 2 * fruits[i][j]
                else:
                    total -= 2 * fruits[i][j] if (dp1[i][j] > 0 and dp2[i][j] > 0) or (dp1[i][j] > 0 and dp3[i][j] > 0) or (dp2[i][j] > 0 and dp3[i][j] > 0) else 0
                max_fruits = max(max_fruits, total)
        
        return max_fruits
```",Y,
sum-of-good-subsequences,Sum of Good Subsequences,"```python
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        max_num = max(nums) if nums else 0
        dp_sum = [0] * (max_num + 2)
        dp_count = [0] * (max_num + 2)
        
        for num in nums:
            total = 1  # the subsequence [num] itself
            if num - 1 >= 0:
                total += dp_count[num - 1]
            if num + 1 <= max_num:
                total += dp_count[num + 1]
            total %= MOD
            
            added_sum = num * (1 + dp_count[num - 1] + dp_count[num + 1]) % MOD
            dp_sum[num] = (dp_sum[num] + added_sum) % MOD
            dp_count[num] = (dp_count[num] + total) % MOD
        
        return sum(dp_sum) % MOD
```",Y,
maximize-the-number-of-target-nodes-after-connecting-trees-ii,Maximize the Number of Target Nodes After Connecting Trees II,"```python
from typing import List
from collections import deque

class Solution:
    def maxTargetNodes(self, edges1: List[List[int]], edges2: List[List[int]]) -> List[int]:
        n = len(edges1) + 1
        m = len(edges2) + 1
        
        tree1 = [[] for _ in range(n)]
        for u, v in edges1:
            tree1[u].append(v)
            tree1[v].append(u)
        
        tree2 = [[] for _ in range(m)]
        for u, v in edges2:
            tree2[u].append(v)
            tree2[v].append(u)
        
        parity2 = [0] * m
        q = deque()
        q.append(0)
        visited = [False] * m
        visited[0] = True
        
        while q:
            u = q.popleft()
            for v in tree2[u]:
                if not visited[v]:
                    visited[v] = True
                    parity2[v] = 1 - parity2[u]
                    q.append(v)
        
        count0 = parity2.count(0)
        count1 = m - count0
        
        parity1 = [0] * n
        q = deque()
        q.append(0)
        visited = [False] * n
        visited[0] = True
        
        while q:
            u = q.popleft()
            for v in tree1[u]:
                if not visited[v]:
                    visited[v] = True
                    parity1[v] = 1 - parity1[u]
                    q.append(v)
        
        answer = []
        for u in range(n):
            if parity1[u] == 0:
                answer.append(n + count0 - 1)
            else:
                answer.append(n + count1 - 1)
        
        return answer
```",Y,
maximum-frequency-of-an-element-after-performing-operations-ii,Maximum Frequency of an Element After Performing Operations II,"```python
from collections import defaultdict

class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        if not nums:
            return 0
        
        nums.sort()
        freq = defaultdict(int)
        n = len(nums)
        left = 0
        total = 0
        max_freq = 0
        
        for right in range(n):
            target = nums[right]
            total += target
            
            while (right - left + 1) * target - total > k * numOperations:
                total -= nums[left]
                left += 1
            
            current_window = right - left + 1
            if current_window > max_freq:
                max_freq = current_window
        
        return max_freq
```",Y,
minimum-operations-to-make-character-frequencies-equal,Minimum Operations to Make Character Frequencies Equal,"```python
class Solution:
    def makeStringGood(self, s: str) -> int:
        from collections import defaultdict

        freq = defaultdict(int)
        for c in s:
            freq[c] += 1
        
        counts = sorted(freq.values())
        operations = 0
        
        for i in range(1, len(counts)):
            if counts[i] <= counts[i-1]:
                target = max(0, counts[i-1] - 1)
                operations += counts[i] - target if target < counts[i] else 0
                counts[i] = target if target < counts[i] else counts[i]
        
        return operations
```",Y,
count-number-of-balanced-permutations,Count Number of Balanced Permutations,"```python
from collections import defaultdict
import math

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        velunexorai = num
        freq = defaultdict(int)
        for d in velunexorai:
            freq[d] += 1
        
        n = len(velunexorai)
        total = 0
        
        from itertools import permutations
        
        seen = set()
        balanced_count = 0
        
        for p in permutations(velunexorai):
            s = ''.join(p)
            if s in seen:
                continue
            seen.add(s)
            odd_sum = 0
            even_sum = 0
            for i in range(len(s)):
                if i % 2 == 0:
                    even_sum += int(s[i])
                else:
                    odd_sum += int(s[i])
            if odd_sum == even_sum:
                balanced_count += 1
        
        return balanced_count % (10**9 + 7)
```",Y,
smallest-divisible-digit-product-ii,Smallest Divisible Digit Product II,"```python
import math

class Solution:
    def smallestNumber(self, num: str, t: int) -> str:
        def is_valid(s):
            product = 1
            for ch in s:
                if ch == '0':
                    return False
                product *= int(ch)
            return product % t == 0
        
        n = len(num)
        if is_valid(num):
            return num
        
        digits = [int(c) for c in num]
        
        def find_next(digits):
            n = len(digits)
            pos = n - 1
            while pos >= 0:
                if digits[pos] < 9:
                    digits[pos] += 1
                    for i in range(pos + 1, n):
                        digits[i] = 1
                    s = ''.join(map(str, digits))
                    if is_valid(s):
                        return s
                    return find_next(digits.copy())
                else:
                    pos -= 1
            return find_next([1] * (n + 1))
        
        next_num = str(int(num) + 1)
        if len(next_num) > len(num):
            digits = [1] * len(next_num)
        else:
            digits = [int(c) for c in next_num]
        
        result = find_next(digits.copy())
        return result if result else ""-1""
```",Y,
count-k-reducible-numbers-less-than-n,Count K-Reducible Numbers Less Than N,"```python
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10**9 + 7
        n = int(s, 2)
        if n == 1:
            return 0
        
        memo = {}
        
        def is_k_reducible(x):
            original_x = x
            steps = 0
            while x != 1 and steps <= k:
                if x in memo:
                    steps += memo[x]
                    break
                x = bin(x).count('1')
                steps += 1
            if original_x not in memo:
                memo[original_x] = steps
            return steps <= k
        
        count = 0
        for x in range(1, n):
            if is_k_reducible(x):
                count += 1
        return count % MOD
```",Y,
total-characters-in-string-after-transformations-ii,Total Characters in String After Transformations II,"```python
class Solution:
    def lengthAfterTransformations(self, s: str, t: int, nums: List[int]) -> int:
        MOD = 10**9 + 7
        
        
        
        total_length = 0
        for c in s:
            original_pos = ord(c) - ord('a')
            shift_per_step = nums[original_pos]
            multiplier = pow(shift_per_step, t, MOD)
            total_length = (total_length + multiplier) % MOD
        
        return total_length
```",Y,
find-the-original-typed-string-ii,Find the Original Typed String II,"```python
class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        MOD = 10**9 + 7
        n = len(word)
        if k > n:
            return 0
        
        groups = []
        current_char = word[0]
        count = 1
        for c in word[1:]:
            if c == current_char:
                count += 1
            else:
                groups.append((current_char, count))
                current_char = c
                count = 1
        groups.append((current_char, count))
        
        m = len(groups)
        if m < k:
            return 0
        
        dp = [[0] * (m + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        
        for i in range(1, m + 1):
            for j in range(1, m + 1):
                if j > i:
                    continue
                if i - 1 >= 0 and j - 1 >= 0:
                    dp[i][j] += dp[i-1][j-1]
                if i - 2 >= 0 and j - 1 >= 0 and groups[i-1][0] == groups[i-2][0]:
                    dp[i][j] += dp[i-2][j-1] * (groups[i-1][1] + groups[i-2][1] - 1)
                dp[i][j] %= MOD
        
        total = 0
        for l in range(k, m + 1):
            total = (total + dp[m][l]) % MOD
        return total
```",Y,
find-the-number-of-subsequences-with-equal-gcd,Find the Number of Subsequences With Equal GCD,"```python
import math
from collections import defaultdict
from typing import List

class Solution:
    def subsequencePairCount(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        g = defaultdict(int)
        
        for mask in range(1, 1 << n):
            current_gcd = 0
            for i in range(n):
                if mask & (1 << i):
                    current_gcd = math.gcd(current_gcd, nums[i])
            g[current_gcd] += 1
        
        total = 0
        for gcd_val in g:
            cnt = g[gcd_val]
            total = (total + cnt * (cnt - 1) // 2) % MOD
        
        return total
```",Y,
find-the-number-of-possible-ways-for-an-event,Find the Number of Possible Ways for an Event,"```python
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        
        dp = [[0] * (x + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for i in range(1, n + 1):
            for k in range(1, x + 1):
                dp[i][k] = (dp[i-1][k-1] + dp[i-1][k] * k) % MOD
        
        total = 0
        fact = [1] * (x + 1)
        for i in range(1, x + 1):
            fact[i] = fact[i-1] * i % MOD
        
        for k in range(1, x + 1):
            ways_partition = dp[n][k] * fact[k] % MOD
            ways_score = pow(y, k, MOD)
            total = (total + ways_partition * ways_score) % MOD
        
        return total
```",Y,
check-if-dfs-strings-are-palindromes,Check if DFS Strings Are Palindromes,"```python
from typing import List

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)
        
        answer = [False] * n
        
        for i in range(n):
            stack = [(i, False)]
            dfs_str = []
            while stack:
                node, processed = stack.pop()
                if processed:
                    dfs_str.append(s[node])
                else:
                    for child in reversed(sorted(children[node])):
                        stack.append((child, False))
                    stack.append((node, True))
            if dfs_str == dfs_str[::-1]:
                answer[i] = True
        return answer
```",Y,
find-the-k-th-character-in-string-game-ii,Find the K-th Character in String Game II,"```python
from typing import List

class Solution:
    def kthCharacter(self, k: int, operations: List[int]) -> str:
        word_len = 1
        shift = 0
        
        for op in operations:
            if op == 0:
                word_len *= 2
            elif op == 1:
                shift += 1
        
        k -= 1  # convert to 0-based index
        for op in reversed(operations):
            if op == 0:
                if k >= word_len // 2:
                    k -= word_len // 2
                word_len //= 2
            elif op == 1:
                if k >= word_len:
                    pass  # shouldn't happen as per problem constraints
                shift -= 1
        
        initial_char = 'a'
        shifted_char = chr((ord(initial_char) - ord('a') + shift) % 26 + ord('a'))
        return shifted_char
```",Y,
find-x-sum-of-all-k-long-subarrays-ii,Find X-Sum of All K-Long Subarrays II,"```python
from collections import defaultdict
from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        result = []
        freq = defaultdict(int)
        
        for num in nums[:k]:
            freq[num] += 1
        
        left = 0
        for right in range(k, n + 1):
            items = list(freq.items())
            items.sort(key=lambda item: (-item[1], -item[0]))
            
            total = 0
            for i in range(min(x, len(items))):
                val, count = items[i]
                total += val * count
            
            result.append(total)
            
            if right < n:
                left_num = nums[left]
                freq[left_num] -= 1
                if freq[left_num] == 0:
                    del freq[left_num]
                
                right_num = nums[right]
                freq[right_num] += 1
                left += 1
        
        return result
```",Y,
count-the-number-of-winning-sequences,Count The Number of Winning Sequences,"```python
class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        
        alice_points = [0] * n
        for i in range(n):
            c = s[i]
            if c == 'F':
                alice_points[i] = [0, 1, -1]  # Bob's F, W, E: Alice's points
            elif c == 'W':
                alice_points[i] = [-1, 0, 1]
            elif c == 'E':
                alice_points[i] = [1, -1, 0]
        
        
        dp = {}
        for move in range(3):
            diff = -alice_points[0][move]
            dp[(move, diff)] = 1
        
        for i in range(1, n):
            new_dp = {}
            for (last_move, current_diff), count in dp.items():
                for next_move in range(3):
                    if next_move == last_move:
                        continue
                    new_diff = current_diff - alice_points[i][next_move]
                    key = (next_move, new_diff)
                    new_dp[key] = (new_dp.get(key, 0) + count) % MOD
            dp = new_dp
        
        total = 0
        for (last_move, diff), count in dp.items():
            if diff > 0:
                total = (total + count) % MOD
        return total
```",Y,
sorted-gcd-pair-queries,Sorted GCD Pair Queries,"```python
import math
from collections import defaultdict
from bisect import bisect_left

class Solution:
    def gcdValues(self, nums: List[int], queries: List[int]) -> List[int]:
        freq = defaultdict(int)
        n = len(nums)
        
        for i in range(n):
            for j in range(i + 1, min(i + 100, n)):  # Limit the range to avoid O(n^2)
                g = math.gcd(nums[i], nums[j])
                freq[g] += 1
        
        value_counts = defaultdict(int)
        for num in nums:
            value_counts[num] += 1
        
        for num, cnt in value_counts.items():
            if cnt >= 2:
                pairs = cnt * (cnt - 1) // 2
                freq[num] += pairs
        
        sorted_gcds = sorted(freq.keys())
        cumulative = []
        total = 0
        for g in sorted_gcds:
            total += freq[g]
            cumulative.append(total)
        
        answer = []
        for q in queries:
            pos = q + 1  # 1-based to find the smallest g where cumulative >= pos
            idx = bisect_left(cumulative, pos)
            answer.append(sorted_gcds[idx])
        
        return answer
```",Y,
find-the-occurrence-of-first-almost-equal-substring,Find the Occurrence of First Almost Equal Substring,"```python
class Solution:
    def minStartingIndex(self, s: str, pattern: str) -> int:
        len_pattern = len(pattern)
        len_s = len(s)
        
        for i in range(len_s - len_pattern + 1):
            mismatch = 0
            for j in range(len_pattern):
                if s[i + j] != pattern[j]:
                    mismatch += 1
                    if mismatch > 1:
                        break
            if mismatch <= 1:
                return i
        return -1
```",Y,
construct-2d-grid-matching-graph-layout,Construct 2D Grid Matching Graph Layout,"```python
from collections import defaultdict, deque
from typing import List

class Solution:
    def constructGridLayout(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        graph = defaultdict(set)
        for u, v in edges:
            graph[u].add(v)
            graph[v].add(u)
        
        start = 0
        for node in graph:
            if len(graph[node]) <= 2:
                start = node
                break
        
        visited = set()
        queue = deque()
        queue.append(start)
        visited.add(start)
        order = []
        
        while queue:
            node = queue.popleft()
            order.append(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        grid = []
        if not order:
            return grid
        
        current_row = [order[0]]
        remaining_nodes = order[1:]
        
        while remaining_nodes:
            last_in_row = current_row[-1]
            found = False
            for i, node in enumerate(remaining_nodes):
                if node in graph[last_in_row]:
                    current_row.append(node)
                    remaining_nodes.pop(i)
                    found = True
                    break
            if not found:
                grid.append(current_row)
                current_row = [remaining_nodes.pop(0)]
        
        if current_row:
            grid.append(current_row)
        
        return grid
```",Y,
find-the-maximum-sequence-value-of-array,Find the Maximum Sequence Value of Array,"```python
from typing import List

class Solution:
    def maxValue(self, nums: List[int], k: int) -> int:
        max_val = 0
        n = len(nums)
        for i in range(n - 2 * k + 1):
            for j in range(i + k, n - k + 1):
                left_or = 0
                for num in nums[i:i+k]:
                    left_or |= num
                right_or = 0
                for num in nums[j:j+k]:
                    right_or |= num
                current = left_or ^ right_or
                if current > max_val:
                    max_val = current
        return max_val
```",Y,
count-substrings-that-can-be-rearranged-to-contain-a-string-ii,Count Substrings That Can Be Rearranged to Contain a String II,"```python
class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        len1, len2 = len(word1), len(word2)
        if len1 < len2:
            return 0
        
        target = [0] * 26
        for c in word2:
            target[ord(c) - ord('a')] += 1
        
        current = [0] * 26
        left = 0
        res = 0
        
        for right in range(len1):
            current[ord(word1[right]) - ord('a')] += 1
            
            while right - left + 1 > len2:
                current[ord(word1[left]) - ord('a')] -= 1
                left += 1
            
            if right - left + 1 == len2:
                valid = True
                for i in range(26):
                    if current[i] < target[i]:
                        valid = False
                        break
                if valid:
                    res += len1 - right
                    current[ord(word1[left]) - ord('a')] -= 1
                    left += 1
        
        return res
```",Y,
length-of-the-longest-increasing-path,Length of the Longest Increasing Path,"```python
class Solution:
    def maxPathLength(self, coordinates: List[List[int]], k: int) -> int:
        coordinates.sort()
        n = len(coordinates)
        dp = [1] * n
        target = coordinates[k]
        max_len = 1
        
        for i in range(n):
            x, y = coordinates[i]
            if x == target[0] and y == target[1]:
                current_max = 1
                for j in range(i):
                    prev_x, prev_y = coordinates[j]
                    if prev_x < x and prev_y < y:
                        if dp[j] + 1 > current_max:
                            current_max = dp[j] + 1
                dp[i] = current_max
                if current_max > max_len:
                    max_len = current_max
            else:
                current_max = 1
                for j in range(i):
                    prev_x, prev_y = coordinates[j]
                    if prev_x < x and prev_y < y:
                        if dp[j] + 1 > current_max:
                            current_max = dp[j] + 1
                dp[i] = current_max
        
        return max_len
```",Y,
select-cells-in-grid-with-maximum-score,Select Cells in Grid With Maximum Score,"```python
from typing import List
import heapq

class Solution:
    def maxScore(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        
        elements = []
        for i in range(m):
            for j in range(n):
                elements.append((-grid[i][j], i, j))  # Using max heap by storing negatives
        
        elements.sort()
        
        used_rows = set()
        used_values = set()
        total = 0
        
        for val, i, j in elements:
            current_val = -val
            if i not in used_rows and current_val not in used_values:
                used_rows.add(i)
                used_values.add(current_val)
                total += current_val
        
        return total
```",Y,
maximum-score-of-non-overlapping-intervals,Maximum Score of Non-overlapping Intervals,"```python
from typing import List

class Solution:
    def maximumWeight(self, intervals: List[List[int]]) -> List[int]:
        if not intervals:
            return []
        
        indexed_intervals = [(interval[0], interval[1], interval[2], i) for i, interval in enumerate(intervals)]
        indexed_intervals.sort(key=lambda x: x[1])
        
        n = len(indexed_intervals)
        prev = [-1] * n
        for i in range(n):
            low, high = 0, i - 1
            while low <= high:
                mid = (low + high) // 2
                if indexed_intervals[mid][1] < indexed_intervals[i][0]:
                    low = mid + 1
                else:
                    high = mid - 1
            prev[i] = high
        
        dp = [[0] * n for _ in range(5)]
        selected = [[[] for _ in range(n)] for _ in range(5)]
        
        for k in range(1, 5):
            for i in range(n):
                if i > 0:
                    dp[k][i] = dp[k][i-1]
                    selected[k][i] = selected[k][i-1].copy()
                
                if prev[i] == -1:
                    if k == 1:
                        if intervals[indexed_intervals[i][3]][2] > dp[k][i]:
                            dp[k][i] = intervals[indexed_intervals[i][3]][2]
                            selected[k][i] = [indexed_intervals[i][3]]
                else:
                    if dp[k-1][prev[i]] + intervals[indexed_intervals[i][3]][2] > dp[k][i]:
                        dp[k][i] = dp[k-1][prev[i]] + intervals[indexed_intervals[i][3]][2]
                        selected[k][i] = selected[k-1][prev[i]] + [indexed_intervals[i][3]]
        
        max_k = 0
        max_score = 0
        best_indices = []
        for k in range(1, 5):
            if dp[k][-1] > max_score:
                max_score = dp[k][-1]
                max_k = k
                best_indices = selected[k][-1]
            elif dp[k][-1] == max_score and len(selected[k][-1]) > len(best_indices):
                best_indices = selected[k][-1]
        
        best_indices.sort()
        return best_indices
```",Y,
maximum-number-of-moves-to-kill-all-pawns,Maximum Number of Moves to Kill All Pawns,"```python
from typing import List
from collections import deque

class Solution:
    def maxMoves(self, kx: int, ky: int, positions: List[List[int]]) -> int:
        pawns = positions
        n = len(pawns)
        distance_maps = {}
        directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2),
                      (1, -2), (1, 2), (2, -1), (2, 1)]
        
        for i, (px, py) in enumerate(pawns):
            q = deque()
            q.append((px, py))
            dist = {}
            dist[(px, py)] = 0
            while q:
                x, y = q.popleft()
                for dx, dy in directions:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in dist:
                        dist[(nx, ny)] = dist[(x, y)] + 1
                        q.append((nx, ny))
            distance_maps[i] = dist
        
        
        initial_steps = []
        for i in range(n):
            px, py = pawns[i]
            if (kx, ky) in distance_maps[i]:
                initial_steps.append(distance_maps[i][(kx, ky)])
            else:
                initial_steps.append(0)  # should not happen per problem statement
        
        
        step_matrix = [[0] * n for _ in range(n)]
        for i in range(n):
            for j in range(n):
                if i == j:
                    step_matrix[i][j] = 0
                else:
                    px, py = pawns[j]
                    if (px, py) in distance_maps[i]:
                        step_matrix[i][j] = distance_maps[i][(px, py)]
                    else:
                        step_matrix[i][j] = 0  # should not happen
        
        
        
        all_steps = []
        for step in initial_steps:
            all_steps.append(step)
        for i in range(n):
            for j in range(n):
                if i != j:
                    all_steps.append(step_matrix[i][j])
        
        all_steps.sort(reverse=True)
        
        total = 0
        for i in range(len(all_steps)):
            if i % 2 == 0:
                total += all_steps[i]
        
        return total
```",Y,
minimum-number-of-valid-strings-to-form-target-ii,Minimum Number of Valid Strings to Form Target II,"```python
class Solution:
    def minValidStrings(self, words: List[str], target: str) -> int:
        prefix_set = set()
        for word in words:
            for l in range(1, len(word)+1):
                prefix_set.add(word[:l])
        
        n = len(target)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        
        for i in range(1, n + 1):
            for l in range(1, min(i, 20) + 1):  # Assuming max prefix length is 20 for efficiency
                start = i - l
                if start >= 0:
                    substring = target[start:i]
                    if substring in prefix_set and dp[start] != float('inf'):
                        dp[i] = min(dp[i], dp[start] + 1)
        
        return dp[n] if dp[n] != float('inf') else -1
```",Y,
final-array-state-after-k-multiplication-operations-ii,Final Array State After K Multiplication Operations II,"```python
import heapq

class Solution:
    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:
        MOD = 10**9 + 7
        heap = []
        for idx, num in enumerate(nums):
            heapq.heappush(heap, (num, idx))
        
        for _ in range(k):
            if not heap:
                break
            current_val, current_idx = heapq.heappop(heap)
            new_val = current_val * multiplier
            nums[current_idx] = new_val
            heapq.heappush(heap, (new_val, current_idx))
        
        return [num % MOD for num in nums]
```",Y,
find-the-largest-palindrome-divisible-by-k,Find the Largest Palindrome Divisible by K,"```python
class Solution:
    def largestPalindrome(self, n: int, k: int) -> str:
        if n == 1:
            max_num = 9
            while max_num >= 0:
                if max_num % k == 0:
                    return str(max_num)
                max_num -= 1
            return """"
        
        half = (n + 1) // 2
        start = 10 ** half - 1
        end = 10 ** (half - 1) - 1
        
        for num in range(start, end, -1):
            s = str(num)
            if n % 2 == 0:
                palindrome_str = s + s[::-1]
            else:
                palindrome_str = s + s[:-1][::-1]
            palindrome = int(palindrome_str)
            if palindrome % k == 0:
                return palindrome_str
        
        return """"
```",Y,
maximum-xor-score-subarray-queries,Maximum XOR Score Subarray Queries,"```python
from typing import List

class Solution:
    def maximumSubarrayXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        n = len(nums)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] ^ nums[i]
        
        res = []
        for l, r in queries:
            max_xor = 0
            for i in range(l, r + 1):
                current_xor = 0
                for j in range(i, r + 1):
                    current_xor ^= nums[j]
                    if current_xor > max_xor:
                        max_xor = current_xor
            res.append(max_xor)
        return res
```",Y,
maximum-value-sum-by-placing-three-rooks-i,Maximum Value Sum by Placing Three Rooks I,"```python
from typing import List

class Solution:
    def maximumValueSum(self, board: List[List[int]]) -> int:
        m = len(board)
        n = len(board[0]) if m > 0 else 0
        max_sum = -float('inf')
        
        
        from itertools import combinations
        
        for rows in combinations(range(m), 3):
            for cols in combinations(range(n), 3):
                if len(set(cols)) == 3:
                    current_sum = board[rows[0]][cols[0]] + board[rows[1]][cols[1]] + board[rows[2]][cols[2]]
                    if current_sum > max_sum:
                        max_sum = current_sum
        
        for r1 in range(m):
            for r2 in range(m):
                if r1 == r2:
                    continue
                for c1 in range(n):
                    for c2 in range(n):
                        if c1 == c2:
                            continue
                        for c3 in range(n):
                            if c3 == c1 or c3 == c2:
                                continue
                            current_sum = board[r1][c1] + board[r1][c2] + board[r2][c3]
                            if current_sum > max_sum:
                                max_sum = current_sum
        
        for c1 in range(n):
            for c2 in range(n):
                if c1 == c2:
                    continue
                for r1 in range(m):
                    for r2 in range(m):
                        if r1 == r2:
                            continue
                        for r3 in range(m):
                            if r3 == r1 or r3 == r2:
                                continue
                            current_sum = board[r1][c1] + board[r2][c1] + board[r3][c2]
                            if current_sum > max_sum:
                                max_sum = current_sum
        
        return max_sum
```",Y,
find-the-count-of-good-integers,Find the Count of Good Integers,"```python
from math import comb

class Solution:
    def countGoodIntegers(self, n: int, k: int) -> int:
        if n == 1:
            return 9 // k
        
        total = 0
        half = (n + 1) // 2
        max_num = 10 ** half - 1
        min_num = 10 ** (half - 1)
        
        count = 0
        for num in range((min_num + k - 1) // k * k, max_num + 1, k):
            s = str(num)
            if s == s[::-1]:
                count += 1
        
        if n % 2 == 0:
            total = count * comb(9 + half - 1, half)
        else:
            first_digit_options = 9
            other_digits_options = comb(9 + half - 2, half - 1)
            total = count * first_digit_options * other_digits_options
        
        return total
```",Y,
count-substrings-that-satisfy-k-constraint-ii,Count Substrings That Satisfy K-Constraint II,"```python
class Solution:
    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:
        n = len(s)
        prefix0 = [0] * (n + 1)
        prefix1 = [0] * (n + 1)
        
        for i in range(n):
            prefix0[i+1] = prefix0[i] + (1 if s[i] == '0' else 0)
            prefix1[i+1] = prefix1[i] + (1 if s[i] == '1' else 0)
        
        res = []
        for l, r in queries:
            total = 0
            for i in range(l, r + 1):
                for j in range(i, r + 1):
                    cnt0 = prefix0[j+1] - prefix0[i]
                    cnt1 = prefix1[j+1] - prefix1[i]
                    if cnt0 <= k or cnt1 <= k:
                        total += 1
            res.append(total)
        return res
```",Y,
count-almost-equal-pairs-ii,Count Almost Equal Pairs II,"```python
from collections import defaultdict
from typing import List

class Solution:
    def countPairs(self, nums: List[int]) -> int:
        def get_key(num):
            s = str(num)
            freq = [0] * 10
            for c in s:
                freq[int(c)] += 1
            return tuple(freq)
        
        freq_map = defaultdict(int)
        res = 0
        for num in nums:
            key = get_key(num)
            res += freq_map[key]
            freq_map[key] += 1
        return res
```",Y,
maximum-value-sum-by-placing-three-rooks-ii,Maximum Value Sum by Placing Three Rooks II,"```python
from typing import List

class Solution:
    def maximumValueSum(self, board: List[List[int]]) -> int:
        m = len(board)
        n = len(board[0]) if m > 0 else 0
        
        row_max = [sorted([(val, j) for j, val in enumerate(row)], reverse=True) for row in board]
        col_max = []
        for j in range(n):
            column = [board[i][j] for i in range(m)]
            col_max.append(sorted([(val, i) for i, val in enumerate(column)], reverse=True))
        
        max_sum = -float('inf')
        
        for i1 in range(m):
            for j1 in range(n):
                val1 = board[i1][j1]
                for i2 in range(m):
                    if i2 == i1:
                        continue
                    for j2 in range(n):
                        if j2 == j1:
                            continue
                        val2 = board[i2][j2]
                        for i3 in range(m):
                            if i3 == i1 or i3 == i2:
                                continue
                            for j3 in range(n):
                                if j3 == j1 or j3 == j2:
                                    continue
                                val3 = board[i3][j3]
                                current_sum = val1 + val2 + val3
                                if current_sum > max_sum:
                                    max_sum = current_sum
        
        for i in range(m):
            for k1 in range(min(5, n)):
                j1 = row_max[i][k1][1]
                val1 = row_max[i][k1][0]
                for k2 in range(k1 + 1, min(5, n)):
                    j2 = row_max[i][k2][1]
                    val2 = row_max[i][k2][0]
                    for other_i in range(m):
                        if other_i == i:
                            continue
                        for other_j in range(n):
                            if other_j == j1 or other_j == j2:
                                continue
                            val3 = board[other_i][other_j]
                            current_sum = val1 + val2 + val3
                            if current_sum > max_sum:
                                max_sum = current_sum
        
        for j in range(n):
            for k1 in range(min(5, m)):
                i1 = col_max[j][k1][1]
                val1 = col_max[j][k1][0]
                for k2 in range(k1 + 1, min(5, m)):
                    i2 = col_max[j][k2][1]
                    val2 = col_max[j][k2][0]
                    for other_i in range(m):
                        if other_i == i1 or other_i == i2:
                            continue
                        for other_j in range(n):
                            if other_j == j:
                                continue
                            val3 = board[other_i][other_j]
                            current_sum = val1 + val2 + val3
                            if current_sum > max_sum:
                                max_sum = current_sum
        
        return max_sum
```",Y,
find-the-count-of-monotonic-pairs-ii,Find the Count of Monotonic Pairs II,"```python
class Solution:
    def countOfPairs(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        if n == 0:
            return 0
        
        
        min_arr1 = [0] * n
        max_arr1 = [0] * n
        
        min_arr1[0] = 0
        max_arr1[0] = nums[0]
        for i in range(1, n):
            min_arr1[i] = min_arr1[i-1]
            max_arr1[i] = min(max_arr1[i-1], nums[i])
        
        for i in range(n-2, -1, -1):
            new_min = max(min_arr1[i], min_arr1[i+1] + nums[i] - nums[i+1])
            new_max = min(max_arr1[i], max_arr1[i+1])
            if new_min > new_max:
                return 0
            min_arr1[i] = new_min
            max_arr1[i] = new_max
        
        total = 1
        for i in range(n):
            choices = max_arr1[i] - min_arr1[i] + 1
            if choices <= 0:
                return 0
            total = (total * choices) % MOD
        
        return total
```",Y,
find-the-count-of-monotonic-pairs-i,Find the Count of Monotonic Pairs I,"```python
class Solution:
    def countOfPairs(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        if n == 0:
            return 0
        
        
        min_arr1 = [0] * n
        max_arr1 = [0] * n
        
        min_arr1[0] = 0
        max_arr1[0] = nums[0]
        
        for i in range(1, n):
            max_arr1[i] = min(max_arr1[i-1], nums[i])
        
        for i in range(n-2, -1, -1):
            min_arr1[i] = max(min_arr1[i+1] - (nums[i+1] - nums[i]), 0)
        
        result = 1
        for i in range(n):
            if max_arr1[i] < min_arr1[i]:
                return 0
            cnt = max_arr1[i] - min_arr1[i] + 1
            result = (result * cnt) % MOD
        
        return result
```",Y,
time-taken-to-mark-all-nodes,Time Taken to Mark All Nodes,"```python
from collections import deque
from typing import List

class Solution:
    def timeTaken(self, edges: List[List[int]]) -> List[int]:
        n = len(edges) + 1
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        
        times = [0] * n
        
        for i in range(n):
            visited = [False] * n
            time = [0] * n
            q = deque()
            q.append(i)
            visited[i] = True
            time[i] = 0
            max_time = 0
            
            while q:
                node = q.popleft()
                for neighbor in adj[node]:
                    if not visited[neighbor]:
                        if neighbor % 2 == 1:
                            if time[node] + 1 >= time[neighbor]:
                                time[neighbor] = time[node] + 1
                                visited[neighbor] = True
                                q.append(neighbor)
                        else:
                            if time[node] + 2 >= time[neighbor]:
                                time[neighbor] = time[node] + 2
                                visited[neighbor] = True
                                q.append(neighbor)
                max_time = max(max_time, time[node])
            
            times[i] = max(time)
        
        return times
```",Y,
minimum-amount-of-damage-dealt-to-bob,Minimum Amount of Damage Dealt to Bob,"```python
from typing import List
import heapq

class Solution:
    def minDamage(self, power: int, damage: List[int], health: List[int]) -> int:
        enemies = []
        for d, h in zip(damage, health):
            heapq.heappush(enemies, (-d, h))
        
        total_damage = 0
        current_damage = 0
        
        while enemies:
            neg_d, h = heapq.heappop(enemies)
            d = -neg_d
            current_damage += d
            
            turns = (h + power - 1) // power
            total_damage += current_damage * turns
            
        return total_damage
```",Y,
alternating-groups-iii,Alternating Groups III,"```python
from typing import List

class Solution:
    def numberOfAlternatingGroups(self, colors: List[int], queries: List[List[int]]) -> List[int]:
        n = len(colors)
        if n == 0:
            return []
        
        segments = []
        start = 0
        for i in range(1, n + 1):
            if i == n:
                if colors[i-1] != colors[0]:
                    continue
                else:
                    segments.append((start, i-1))
                    start = i
            elif colors[i] == colors[i-1]:
                segments.append((start, i-1))
                start = i
        if start < n:
            segments.append((start, n-1))
        
        if len(segments) > 1 and colors[segments[0][0]] == colors[segments[-1][1]]:
            first_start, first_end = segments[0]
            last_start, last_end = segments[-1]
            merged_segment = (last_start, first_end)
            segments = [merged_segment] + segments[1:-1]
        
        from collections import defaultdict
        count_dict = defaultdict(int)
        for start, end in segments:
            length = end - start + 1
            count_dict[length] += 1
        
        result = []
        for query in queries:
            if query[0] == 1:
                size = query[1]
                res = 0
                for seg_len in count_dict:
                    if seg_len >= size:
                        res += (seg_len - size + 1) * count_dict[seg_len]
                result.append(res)
            elif query[0] == 2:
                index, color = query[1], query[2]
                if colors[index] == color:
                    continue
                colors[index] = color
                segments = []
                start = 0
                for i in range(1, n + 1):
                    if i == n:
                        if colors[i-1] != colors[0]:
                            continue
                        else:
                            segments.append((start, i-1))
                            start = i
                    elif colors[i] == colors[i-1]:
                        segments.append((start, i-1))
                        start = i
                if start < n:
                    segments.append((start, n-1))
                if len(segments) > 1 and colors[segments[0][0]] == colors[segments[-1][1]]:
                    first_start, first_end = segments[0]
                    last_start, last_end = segments[-1]
                    merged_segment = (last_start, first_end)
                    segments = [merged_segment] + segments[1:-1]
                count_dict = defaultdict(int)
                for start, end in segments:
                    length = end - start + 1
                    count_dict[length] += 1
        return result
```",Y,
shortest-distance-after-road-addition-queries-ii,Shortest Distance After Road Addition Queries II,"```python
import bisect

class Solution:
    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        intervals = []
        res = []
        current_min = n - 1
        
        for u, v in queries:
            new_start, new_end = u, v
            
            pos = bisect.bisect_left(intervals, (new_start, new_end))
            
            if pos > 0 and intervals[pos-1][1] >= new_start:
                prev_start, prev_end = intervals[pos-1]
                new_start = min(prev_start, new_start)
                new_end = max(prev_end, new_end)
                pos -= 1
                intervals.pop(pos)
            
            while pos < len(intervals) and intervals[pos][0] <= new_end:
                next_start, next_end = intervals[pos]
                new_start = min(new_start, next_start)
                new_end = max(new_end, next_end)
                intervals.pop(pos)
            
            bisect.insort(intervals, (new_start, new_end))
            
            if new_start == 0:
                current_min = min(current_min, new_end)
            
            res.append(current_min)
        
        return res
```",Y,
minimum-cost-for-cutting-cake-ii,Minimum Cost for Cutting Cake II,"```python
from typing import List

class Solution:
    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:
        horizontalCut.sort(reverse=True)
        verticalCut.sort(reverse=True)
        
        h_pieces = 1
        v_pieces = 1
        total_cost = 0
        i = j = 0
        
        while i < len(horizontalCut) and j < len(verticalCut):
            if horizontalCut[i] > verticalCut[j]:
                total_cost += horizontalCut[i] * v_pieces
                h_pieces += 1
                i += 1
            else:
                total_cost += verticalCut[j] * h_pieces
                v_pieces += 1
                j += 1
        
        while i < len(horizontalCut):
            total_cost += horizontalCut[i] * v_pieces
            h_pieces += 1
            i += 1
        
        while j < len(verticalCut):
            total_cost += verticalCut[j] * h_pieces
            v_pieces += 1
            j += 1
        
        return total_cost
```",Y,
construct-string-with-minimum-cost,Construct String with Minimum Cost,"```python
from typing import List

class Solution:
    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:
        n = len(target)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        
        for i in range(n + 1):
            if dp[i] == float('inf'):
                continue
            for idx, word in enumerate(words):
                cost = costs[idx]
                if target.startswith(word, i):
                    next_pos = i + len(word)
                    if dp[next_pos] > dp[i] + cost:
                        dp[next_pos] = dp[i] + cost
        
        return dp[n] if dp[n] != float('inf') else -1
```",Y,
check-if-the-rectangle-corner-is-reachable,Check if the Rectangle Corner Is Reachable,"```python
from typing import List

class Solution:
    def canReachCorner(self, xCorner: int, yCorner: int, circles: List[List[int]]) -> bool:
        for x, y, r in circles:
            if (x * x + y * y) <= r * r:
                return False
            if ((x - xCorner) ** 2 + (y - yCorner) ** 2) <= r * r:
                return False
            numerator = abs(yCorner * x - xCorner * y)
            denominator = (yCorner ** 2 + xCorner ** 2) ** 0.5
            if numerator <= r * denominator:
                return False
        return True
```",Y,
maximum-score-from-grid-operations,Maximum Score From Grid Operations,"```python
from typing import List

class Solution:
    def maximumScore(self, grid: List[List[int]]) -> int:
        n = len(grid)
        col_black = [-1] * n  # tracks the last black row for each column
        total = 0
        
        for i in range(n):
            for j in range(n):
                if col_black[j] < i:
                    left_black = (j > 0 and col_black[j-1] >= i)
                    right_black = (j < n-1 and col_black[j+1] >= i)
                    if left_black or right_black:
                        total += grid[i][j]
        
        max_total = total
        
        
        for j in range(n):
            original_col_black = col_black[j]
            for i in range(n):
                if col_black[j] >= i:
                    continue  # already black up to this row
                col_black[j] = i
                current_total = 0
                for x in range(n):
                    for y in range(n):
                        if col_black[y] < x:
                            left_black = (y > 0 and col_black[y-1] >= x)
                            right_black = (y < n-1 and col_black[y+1] >= x)
                            if left_black or right_black:
                                current_total += grid[x][y]
                if current_total > max_total:
                    max_total = current_total
            col_black[j] = original_col_black
        
        return max_total
```",Y,
number-of-subarrays-with-and-value-of-k,Number of Subarrays With AND Value of K,"```python
from typing import List

class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        count = 0
        n = len(nums)
        for i in range(n):
            current_and = nums[i]
            if current_and == k:
                count += 1
            for j in range(i + 1, n):
                current_and &= nums[j]
                if current_and == k:
                    count += 1
                elif current_and < k:
                    break
        return count
```",Y,
count-the-number-of-inversions,Count the Number of Inversions,"```python
class Solution:
    def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:
        MOD = 10**9 + 7
        req = {endi: cnti for endi, cnti in requirements}
        max_inv = max(req.values()) if req else 0
        
        dp = [[0] * (max_inv + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for i in range(1, n + 1):
            max_possible_inv = i * (i - 1) // 2
            for j in range(0, min(max_possible_inv, max_inv) + 1):
                for k in range(0, min(i, j + 1)):
                    if j - k >= 0:
                        dp[i][j] = (dp[i][j] + dp[i-1][j - k]) % MOD
        
        result = 1
        for endi in sorted(req.keys()):
            cnti = req[endi]
            if cnti > endi * (endi + 1) // 2:
                return 0
            result = (result * dp[endi + 1][cnti]) % MOD
        
        return result
```",Y,
find-the-minimum-area-to-cover-all-ones-ii,Find the Minimum Area to Cover All Ones II,"```python
from typing import List

class Solution:
    def minimumSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ones = []
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    ones.append((i, j))
        
        if not ones:
            return 0
        
        def get_area(points):
            if not points:
                return 0
            min_row = min(p[0] for p in points)
            max_row = max(p[0] for p in points)
            min_col = min(p[1] for p in points)
            max_col = max(p[1] for p in points)
            return (max_row - min_row + 1) * (max_col - min_col + 1)
        
        min_total = float('inf')
        ones_sorted_row = sorted(ones, key=lambda x: x[0])
        for i in range(1, len(ones)):
            for j in range(i+1, len(ones)):
                group1 = ones_sorted_row[:i]
                group2 = ones_sorted_row[i:j]
                group3 = ones_sorted_row[j:]
                total = get_area(group1) + get_area(group2) + get_area(group3)
                if total < min_total:
                    min_total = total
        
        ones_sorted_col = sorted(ones, key=lambda x: x[1])
        for i in range(1, len(ones)):
            for j in range(i+1, len(ones)):
                group1 = ones_sorted_col[:i]
                group2 = ones_sorted_col[i:j]
                group3 = ones_sorted_col[j:]
                total = get_area(group1) + get_area(group2) + get_area(group3)
                if total < min_total:
                    min_total = total
        
        min_col = min(p[1] for p in ones)
        max_col = max(p[1] for p in ones)
        for split1 in range(min_col + 1, max_col + 1):
            for split2 in range(split1, max_col + 1):
                group1 = [p for p in ones if p[1] < split1]
                group2 = [p for p in ones if split1 <= p[1] < split2]
                group3 = [p for p in ones if p[1] >= split2]
                if group1 and group2 and group3:
                    total = get_area(group1) + get_area(group2) + get_area(group3)
                    if total < min_total:
                        min_total = total
        
        min_row = min(p[0] for p in ones)
        max_row = max(p[0] for p in ones)
        for split1 in range(min_row + 1, max_row + 1):
            for split2 in range(split1, max_row + 1):
                group1 = [p for p in ones if p[0] < split1]
                group2 = [p for p in ones if split1 <= p[0] < split2]
                group3 = [p for p in ones if p[0] >= split2]
                if group1 and group2 and group3:
                    total = get_area(group1) + get_area(group2) + get_area(group3)
                    if total < min_total:
                        min_total = total
        
        return min_total
```",Y,
minimum-operations-to-make-array-equal-to-target,Minimum Operations to Make Array Equal to Target,"```python
from typing import List

class Solution:
    def minimumOperations(self, nums: List[int], target: List[int]) -> int:
        n = len(nums)
        diff = [target[i] - nums[i] for i in range(n)]
        res = 0
        current = 0
        for d in diff:
            if d != current:
                res += abs(d - current)
                current = d
        return res
```",Y,
find-the-maximum-length-of-a-good-subsequence-ii,Find the Maximum Length of a Good Subsequence II,"```python
from typing import List

class Solution:
    def maximumLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if k == 0:
            max_len = 0
            from collections import defaultdict
            freq = defaultdict(int)
            for num in nums:
                freq[num] += 1
                if freq[num] > max_len:
                    max_len = freq[num]
            return max_len
        
        dp = [[0] * (k + 1) for _ in range(n)]
        best = [[0] * (k + 1) for _ in range(n)]
        res = 0
        
        for i in range(n):
            for j in range(k + 1):
                dp[i][j] = 1
                if j > 0:
                    if i > 0:
                        dp[i][j] = max(dp[i][j], best[i-1][j-1] + 1)
                if i > 0:
                    if nums[i] == nums[i-1]:
                        dp[i][j] = max(dp[i][j], dp[i-1][j] + 1)
                
                if i == 0:
                    best[i][j] = dp[i][j]
                else:
                    best[i][j] = max(best[i-1][j], dp[i][j])
                
                if dp[i][j] > res:
                    res = dp[i][j]
        return res
```",Y,
maximum-total-reward-using-operations-ii,Maximum Total Reward Using Operations II,"```python
class Solution:
    def maxTotalReward(self, rewardValues: List[int]) -> int:
        rewardValues = sorted(set(rewardValues))
        max_reach = 0
        dp = {0}
        for num in rewardValues:
            new_dp = set()
            for x in dp:
                if num > x:
                    new_x = x + num
                    if new_x > max_reach:
                        max_reach = new_x
                    new_dp.add(new_x)
            dp.update(new_dp)
        return max_reach
```",Y,
find-minimum-diameter-after-merging-two-trees,Find Minimum Diameter After Merging Two Trees,"```python
from collections import deque
from typing import List

class Solution:
    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:
        def build_tree(edges):
            tree = {}
            for u, v in edges:
                if u not in tree:
                    tree[u] = []
                if v not in tree:
                    tree[v] = []
                tree[u].append(v)
                tree[v].append(u)
            return tree
        
        def get_tree_properties(tree):
            if not tree:
                return (0, 0, [])
            
            def bfs(start):
                visited = {}
                q = deque()
                q.append((start, 0))
                visited[start] = True
                farthest_node = start
                max_dist = 0
                while q:
                    node, dist = q.popleft()
                    if dist > max_dist:
                        max_dist = dist
                        farthest_node = node
                    for neighbor in tree.get(node, []):
                        if neighbor not in visited:
                            visited[neighbor] = True
                            q.append((neighbor, dist + 1))
                return farthest_node, max_dist
            
            node, _ = bfs(next(iter(tree.keys())))
            node, diameter = bfs(node)
            center_nodes = []
            
            def find_centers():
                leaves = deque()
                degree = {}
                for node in tree:
                    degree[node] = len(tree[node])
                    if degree[node] == 1:
                        leaves.append(node)
                total_nodes = len(tree)
                while total_nodes > 2:
                    for _ in range(len(leaves)):
                        leaf = leaves.popleft()
                        for neighbor in tree[leaf]:
                            degree[neighbor] -= 1
                            if degree[neighbor] == 1:
                                leaves.append(neighbor)
                        total_nodes -= 1
                return list(leaves)
            
            center_nodes = find_centers()
            radius = (diameter + 1) // 2
            return (diameter, radius, center_nodes)
        
        tree1 = build_tree(edges1)
        tree2 = build_tree(edges2)
        
        d1, r1, centers1 = get_tree_properties(tree1)
        d2, r2, centers2 = get_tree_properties(tree2)
        
        min_diameter = max(d1, d2, r1 + r2 + 1)
        return min_diameter
```",Y,
peaks-in-array,Peaks in Array,"```python
class Solution:
    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        n = len(nums)
        peaks = [0] * n
        for i in range(1, n-1):
            if nums[i-1] < nums[i] > nums[i+1]:
                peaks[i] = 1
        
        class FenwickTree:
            def __init__(self, size):
                self.size = size
                self.tree = [0] * (self.size + 1)
            
            def update(self, index, delta):
                while index <= self.size:
                    self.tree[index] += delta
                    index += index & -index
            
            def query(self, index):
                res = 0
                while index > 0:
                    res += self.tree[index]
                    index -= index & -index
                return res
        
        ft = FenwickTree(n)
        for i in range(1, n+1):
            if peaks[i-1]:
                ft.update(i, 1)
        
        res = []
        for query in queries:
            if query[0] == 1:
                l, r = query[1], query[2]
                if r - l + 1 < 3:
                    res.append(0)
                    continue
                total = ft.query(r) - ft.query(l + 1)
                res.append(total)
            else:
                index, val = query[1], query[2]
                original_val = nums[index]
                if original_val == val:
                    continue
                nums[index] = val
                affected = []
                if index > 0:
                    affected.append(index - 1)
                affected.append(index)
                if index < n - 1:
                    affected.append(index + 1)
                
                for i in affected:
                    if i == 0 or i == n - 1:
                        continue
                    old_peak = peaks[i]
                    new_peak = 1 if nums[i-1] < nums[i] > nums[i+1] else 0
                    if old_peak != new_peak:
                        delta = new_peak - old_peak
                        peaks[i] = new_peak
                        ft.update(i + 1, delta)
        return res
```",Y,
find-subarray-with-bitwise-or-closest-to-k,Find Subarray With Bitwise OR Closest to K,"```python
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        min_diff = float('inf')
        current_or_sets = set()
        
        for num in nums:
            new_or_sets = {num}
            for val in current_or_sets:
                new_or = val | num
                new_or_sets.add(new_or)
            current_or_sets = new_or_sets
            
            for val in current_or_sets:
                diff = abs(val - k)
                if diff < min_diff:
                    min_diff = diff
                    if min_diff == 0:
                        return 0
        
        return min_diff
```",Y,
block-placement-queries,Block Placement Queries,"```python
import bisect

class Solution:
    def getResults(self, queries: List[List[int]]) -> List[bool]:
        obstacles = []
        results = []
        for query in queries:
            if query[0] == 1:
                x = query[1]
                bisect.insort(obstacles, x)
            else:
                x, sz = query[1], query[2]
                if not obstacles:
                    results.append(x >= sz)
                    continue
                idx = bisect.bisect_left(obstacles, x)
                if idx == 0:
                    prev_obstacle = 0
                else:
                    prev_obstacle = obstacles[idx - 1]
                if x - prev_obstacle >= sz:
                    results.append(True)
                    continue
                possible = False
                if idx < len(obstacles):
                    next_obstacle = obstacles[idx]
                    if next_obstacle - sz >= 0 and next_obstacle - sz <= x - sz:
                        possible = True
                else:
                    if x >= sz:
                        possible = True
                results.append(possible)
        return results
```",Y,
find-the-minimum-cost-array-permutation,Find the Minimum Cost Array Permutation,"```python
from typing import List

class Solution:
    def findPermutation(self, nums: List[int]) -> List[int]:
        n = len(nums)
        min_score = float('inf')
        best_perm = None
        
        from itertools import permutations
        
        for perm in permutations(range(n)):
            score = 0
            for i in range(n):
                next_i = (i + 1) % n
                score += abs(perm[i] - nums[perm[next_i]])
                if score > min_score:
                    break
            if score < min_score or (score == min_score and (best_perm is None or perm < best_perm)):
                min_score = score
                best_perm = perm
        
        return list(best_perm)
```",Y,
maximum-sum-of-subsequence-with-non-adjacent-elements,Maximum Sum of Subsequence With Non-adjacent Elements,"```python
class Solution:
    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:
        MOD = 10**9 + 7
        total = 0
        
        for pos, x in queries:
            nums[pos] = x
            n = len(nums)
            if n == 0:
                total = (total + 0) % MOD
                continue
            prev_max = 0
            curr_max = max(0, nums[0])
            for i in range(1, n):
                new_max = max(curr_max, prev_max + nums[i])
                prev_max = curr_max
                curr_max = new_max
            total = (total + max(prev_max, curr_max)) % MOD
        
        return total
```",Y,
find-number-of-ways-to-reach-the-k-th-stair,Find Number of Ways to Reach the K-th Stair,"```python
class Solution:
    def waysToReachStair(self, k: int) -> int:
        from functools import lru_cache
        
        @lru_cache(maxsize=None)
        def dfs(pos, jump, can_down):
            if pos == k:
                res = 1
            else:
                res = 0
            
            if can_down and pos - 1 >= 0:
                res += dfs(pos - 1, jump, False)
            
            new_pos = pos + (1 << jump)
            if new_pos <= k + 1:  # To prevent infinite recursion, limit the upper bound
                res += dfs(new_pos, jump + 1, True)
            
            return res
        
        return dfs(1, 0, True)
```",Y,
find-products-of-elements-of-big-array,Find Products of Elements of Big Array,"```python
class Solution:
    def findProductsOfElements(self, queries: List[List[int]]) -> List[int]:
        def get_powers(x):
            powers = []
            power = 1
            while x > 0:
                if x & 1:
                    powers.append(power)
                power <<= 1
                x >>= 1
            return powers
        
        def find_kth_element(k):
            low, high = 1, k
            while low < high:
                mid = (low + high) // 2
                total = 0
                power = 1
                count = 0
                while power <= mid:
                    count += (mid // power + 1) // 2
                    power <<= 1
                if count < k:
                    low = mid + 1
                else:
                    high = mid
            x = low
            powers = get_powers(x)
            total_before = 0
            power = 1
            while power <= x - 1:
                total_before += ((x - 1) // power + 1) // 2
                power <<= 1
            pos_in_powers = k - total_before - 1
            return powers[pos_in_powers]
        
        def product_range(l, r, mod):
            if l > r:
                return 0
            res = 1
            for k in range(l, r + 1):
                elem = find_kth_element(k)
                res = (res * elem) % mod
            return res
        
        answer = []
        for query in queries:
            from_i, to_i, mod_i = query
            res = 1
            for k in range(from_i, to_i + 1):
                elem = find_kth_element(k + 1)  # 1-based to 0-based?
                res = (res * elem) % mod_i
            answer.append(res)
        return answer
```",Y,
find-all-possible-stable-binary-arrays-ii,Find All Possible Stable Binary Arrays II,"```python
class Solution:
    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:
        MOD = 10**9 + 7
        dp = [[[0] * 2 for _ in range(one + 1)] for __ in range(zero + 1)]
        
        if zero > 0:
            dp[1][0][0] = 1
        if one > 0:
            dp[0][1][1] = 1
        
        for i in range(zero + 1):
            for j in range(one + 1):
                if i == 0 and j == 0:
                    continue
                for k in range(2):
                    if dp[i][j][k] == 0:
                        continue
                    if k == 0:
                        if i + 1 <= zero and (i + j + 1 <= limit or (j > 0)):
                            dp[i+1][j][0] = (dp[i+1][j][0] + dp[i][j][k]) % MOD
                    else:
                        if i + 1 <= zero and (i + j + 1 <= limit or (j > 0 and (i + 1 <= limit or j <= limit))):
                            dp[i+1][j][0] = (dp[i+1][j][0] + dp[i][j][k]) % MOD
                    if k == 1:
                        if j + 1 <= one and (i + j + 1 <= limit or (i > 0)):
                            dp[i][j+1][1] = (dp[i][j+1][1] + dp[i][j][k]) % MOD
                    else:
                        if j + 1 <= one and (i + j + 1 <= limit or (i > 0 and (j + 1 <= limit or i <= limit))):
                            dp[i][j+1][1] = (dp[i][j+1][1] + dp[i][j][k]) % MOD
        
        return (dp[zero][one][0] + dp[zero][one][1]) % MOD
```",Y,
minimum-cost-to-equalize-array,Minimum Cost to Equalize Array,"```python
class Solution:
    def minCostToEqualizeArray(self, nums: List[int], cost1: int, cost2: int) -> int:
        MOD = 10**9 + 7
        max_num = max(nums)
        total_deficit = sum(max_num - x for x in nums)
        
        if cost1 * 2 <= cost2:
            return (total_deficit * cost1) % MOD
        
        n = len(nums)
        min_cost = float('inf')
        
        for target in [max_num, max_num + 1]:
            deficits = [target - x for x in nums]
            total = sum(deficits)
            max_deficit = max(deficits)
            pair_ops = (total - max_deficit)
            if max_deficit <= pair_ops:
                cost = (total // 2) * cost2
                if total % 2 != 0:
                    cost += cost1
            else:
                cost = pair_ops * cost2 + (max_deficit - pair_ops) * cost1
            if cost < min_cost:
                min_cost = cost
        
        return min_cost % MOD
```",Y,
find-edges-in-shortest-paths,Find Edges in Shortest Paths,"```python
import heapq
from typing import List

class Solution:
    def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:
        adj = [[] for _ in range(n)]
        for i, (u, v, w) in enumerate(edges):
            adj[u].append((v, w, i))
            adj[v].append((u, w, i))
        
        dist0 = [float('inf')] * n
        dist0[0] = 0
        heap = [(0, 0)]
        while heap:
            current_dist, u = heapq.heappop(heap)
            if current_dist > dist0[u]:
                continue
            for (v, w, _) in adj[u]:
                if dist0[v] > dist0[u] + w:
                    dist0[v] = dist0[u] + w
                    heapq.heappush(heap, (dist0[v], v))
        
        dist1 = [float('inf')] * n
        dist1[n-1] = 0
        heap = [(0, n-1)]
        while heap:
            current_dist, u = heapq.heappop(heap)
            if current_dist > dist1[u]:
                continue
            for (v, w, _) in adj[u]:
                if dist1[v] > dist1[u] + w:
                    dist1[v] = dist1[u] + w
                    heapq.heappush(heap, (dist1[v], v))
        
        answer = [False] * len(edges)
        total_shortest = dist0[n-1]
        if total_shortest == float('inf'):
            return answer
        
        for i, (u, v, w) in enumerate(edges):
            if dist0[u] + w + dist1[v] == total_shortest or dist0[v] + w + dist1[u] == total_shortest:
                answer[i] = True
        
        return answer
```",Y,
find-the-number-of-subarrays-where-boundary-elements-are-maximum,Find the Number of Subarrays Where Boundary Elements Are Maximum,"```python
from typing import List

class Solution:
    def numberOfSubarrays(self, nums: List[int]) -> int:
        stack = []
        res = 0
        for num in nums:
            while stack and stack[-1] < num:
                stack.pop()
            if not stack or stack[-1] > num:
                stack.append(num)
            res += len(stack)
        return res
```",Y,
longest-common-suffix-queries,Longest Common Suffix Queries,"```python
from typing import List

class Solution:
    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:
        suffix_map = {}
        for idx, word in enumerate(wordsContainer):
            n = len(word)
            for l in range(n + 1):
                suffix = word[n - l:] if l > 0 else """"
                if l not in suffix_map:
                    suffix_map[l] = {}
                if suffix not in suffix_map[l]:
                    suffix_map[l][suffix] = (n, idx)
                else:
                    current_len, current_idx = suffix_map[l][suffix]
                    if n < current_len or (n == current_len and idx < current_idx):
                        suffix_map[l][suffix] = (n, idx)
        
        ans = []
        for query in wordsQuery:
            query_len = len(query)
            best_len = -1
            best_candidate = (float('inf'), 0)  # (length, index)
            max_possible = min(query_len, max(suffix_map.keys()) if suffix_map else 0)
            for l in range(max_possible, -1, -1):
                suffix = query[query_len - l:] if l > 0 else """"
                if l in suffix_map and suffix in suffix_map[l]:
                    current_len, current_idx = suffix_map[l][suffix]
                    if l > best_len or (l == best_len and (current_len < best_candidate[0] or 
                                                          (current_len == best_candidate[0] and current_idx < best_candidate[1]))):
                        best_len = l
                        best_candidate = (current_len, current_idx)
            ans.append(best_candidate[1])
        return ans
```",Y,
kth-smallest-amount-with-single-denomination-combination,Kth Smallest Amount With Single Denomination Combination,"```python
import heapq

class Solution:
    def findKthSmallest(self, coins: List[int], k: int) -> int:
        coins = sorted(coins)
        heap = []
        seen = set()
        
        for coin in coins:
            heapq.heappush(heap, (coin, coin))
            seen.add(coin)
        
        result = 0
        for _ in range(k):
            result, coin = heapq.heappop(heap)
            next_val = result + coin
            if next_val not in seen:
                seen.add(next_val)
                heapq.heappush(heap, (next_val, coin))
        
        return result
```",Y,
minimum-sum-of-values-by-dividing-array,Minimum Sum of Values by Dividing Array,"```python
from typing import List

class Solution:
    def minimumValueSum(self, nums: List[int], andValues: List[int]) -> int:
        n = len(nums)
        m = len(andValues)
        if m > n:
            return -1
        
        dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        
        for j in range(1, m + 1):
            for i in range(j, n + 1):
                current_and = (1 << 30) - 1  # Initialize with all bits set
                for k in range(i, j - 1, -1):
                    current_and &= nums[k - 1]
                    if current_and == andValues[j - 1]:
                        if dp[k - 1][j - 1] + nums[i - 1] < dp[i][j]:
                            dp[i][j] = dp[k - 1][j - 1] + nums[i - 1]
                    elif current_and < andValues[j - 1]:
                        break  # further k will only decrease current_and
        
        return dp[n][m] if dp[n][m] != float('inf') else -1
```",Y,
find-the-median-of-the-uniqueness-array,Find the Median of the Uniqueness Array,"```python
from typing import List

class Solution:
    def medianOfUniquenessArray(self, nums: List[int]) -> int:
        n = len(nums)
        total_subarrays = n * (n + 1) // 2
        median_pos = (total_subarrays + 1) // 2 - 1  # 0-based index for the median
        
        def count_subarrays_with_at_most_k_distinct(k):
            if k == 0:
                return 0
            freq = {}
            left = 0
            count = 0
            res = 0
            for right in range(n):
                num = nums[right]
                if num not in freq or freq[num] == 0:
                    count += 1
                    freq[num] = 0
                freq[num] += 1
                
                while count > k:
                    left_num = nums[left]
                    freq[left_num] -= 1
                    if freq[left_num] == 0:
                        count -= 1
                    left += 1
                res += right - left + 1
            return res
        
        low = 1
        high = len(set(nums))
        answer = high
        while low <= high:
            mid = (low + high) // 2
            if count_subarrays_with_at_most_k_distinct(mid) >= median_pos + 1:
                answer = mid
                high = mid - 1
            else:
                low = mid + 1
        return answer
```",Y,
distribute-elements-into-two-arrays-ii,Distribute Elements Into Two Arrays II,"```python
import bisect

class Solution:
    def resultArray(self, nums: List[int]) -> List[int]:
        arr1 = [nums[0]]
        arr1_sorted = [nums[0]]
        arr2 = [nums[1]]
        arr2_sorted = [nums[1]]
        
        for num in nums[2:]:
            cnt1 = len(arr1_sorted) - bisect.bisect_right(arr1_sorted, num)
            cnt2 = len(arr2_sorted) - bisect.bisect_right(arr2_sorted, num)
            
            if cnt1 > cnt2:
                bisect.insort(arr1_sorted, num)
                arr1.append(num)
            elif cnt1 < cnt2:
                bisect.insort(arr2_sorted, num)
                arr2.append(num)
            else:
                if len(arr1) <= len(arr2):
                    bisect.insort(arr1_sorted, num)
                    arr1.append(num)
                else:
                    bisect.insort(arr2_sorted, num)
                    arr2.append(num)
        
        return arr1 + arr2
```",Y,
minimum-cost-walk-in-weighted-graph,Minimum Cost Walk in Weighted Graph,"```python
from typing import List

class Solution:
    def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:
        parent = list(range(n))
        and_cost = [ (1 << 31) - 1 ] * n  # Initialize with all bits set (for AND operation)

        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u

        for u, v, w in edges:
            root_u = find(u)
            root_v = find(v)
            if root_u != root_v:
                parent[root_v] = root_u
                and_cost[root_u] &= and_cost[root_v]
            and_cost[root_u] &= w

        res = []
        for s, t in query:
            if s == t:
                res.append(0)
                continue
            root_s = find(s)
            root_t = find(t)
            if root_s != root_t:
                res.append(-1)
            else:
                res.append(and_cost[root_s])
        return res
```",Y,
find-the-sum-of-the-power-of-all-subsequences,Find the Sum of the Power of All Subsequences,"```python
class Solution:
    def sumOfPower(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        dp = [[0] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for num in nums:
            for i in range(n, -1, -1):
                for j in range(k, -1, -1):
                    if dp[i][j]:
                        if i + 1 <= n and j + num <= k:
                            dp[i + 1][j + num] = (dp[i + 1][j + num] + dp[i][j]) % MOD
        
        total = 0
        for i in range(1, n + 1):
            if dp[i][k] != 0:
                total = (total + dp[i][k] * pow(2, (n - i), MOD)) % MOD
        return total
```",Y,
minimize-manhattan-distances,Minimize Manhattan Distances,"```python
class Solution:
    def minimumDistance(self, points: List[List[int]]) -> int:
        def max_manhattan(points):
            if not points:
                return 0
            sum_ = [x + y for x, y in points]
            diff = [x - y for x, y in points]
            max_sum, min_sum = max(sum_), min(sum_)
            max_diff, min_diff = max(diff), min(diff)
            return max(max_sum - min_sum, max_diff - min_diff)
        
        sum_ = [x + y for x, y in points]
        diff = [x - y for x, y in points]
        
        max_sum_indices = [i for i, val in enumerate(sum_) if val == max(sum_)]
        min_sum_indices = [i for i, val in enumerate(sum_) if val == min(sum_)]
        max_diff_indices = [i for i, val in enumerate(diff) if val == max(diff)]
        min_diff_indices = [i for i, val in enumerate(diff) if val == min(diff)]
        
        candidates = set(max_sum_indices + min_sum_indices + max_diff_indices + min_diff_indices)
        
        min_max_distance = float('inf')
        
        for candidate in candidates:
            temp_points = points[:candidate] + points[candidate+1:]
            current_max = max_manhattan(temp_points)
            if current_max < min_max_distance:
                min_max_distance = current_max
        
        return min_max_distance
```",Y,
minimum-moves-to-pick-k-ones,Minimum Moves to Pick K Ones,"```python
from typing import List

class Solution:
    def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:
        ones_pos = [i for i, num in enumerate(nums) if num == 1]
        m = len(ones_pos)
        if m == 0:
            return k * 2  # need to create and move all k ones
        
        prefix = [0] * (m + 1)
        for i in range(m):
            prefix[i+1] = prefix[i] + ones_pos[i]
        
        min_moves = float('inf')
        
        max_window = min(k, m + maxChanges)
        
        for window_size in range(max(1, k - maxChanges), min(k, m) + 1):
            changes_needed = k - window_size
            if changes_needed < 0 or changes_needed > maxChanges:
                continue
            
            for i in range(m - window_size + 1):
                j = i + window_size
                median_pos = ones_pos[(i + j) // 2]
                
                left = (i + j) // 2
                right = (i + j) // 2
                if window_size % 2 == 0:
                    right = (i + j) // 2
                else:
                    right = (i + j) // 2
                
                sum_dist = 0
                sum_dist += median_pos * (left - i) - (prefix[left] - prefix[i])
                sum_dist += (prefix[j] - prefix[right]) - median_pos * (j - right)
                
                total_moves = sum_dist + 2 * changes_needed
                if total_moves < min_moves:
                    min_moves = total_moves
        
        return min_moves
```",Y,
find-the-sum-of-subsequence-powers,Find the Sum of Subsequence Powers,"```python
import itertools

class Solution:
    def sumOfPowers(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        total = 0
        for subsequence in itertools.combinations(nums, k):
            min_diff = float('inf')
            sorted_sub = sorted(subsequence)
            for i in range(1, len(sorted_sub)):
                diff = abs(sorted_sub[i] - sorted_sub[i-1])
                if diff < min_diff:
                    min_diff = diff
            if min_diff != float('inf'):
                total += min_diff
        return total % MOD
```",Y,
maximum-strength-of-k-disjoint-subarrays,Maximum Strength of K Disjoint Subarrays,"```python
from typing import List

class Solution:
    def maximumStrength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [[[-10**18, -10**18] for _ in range(k+1)] for __ in range(n+1)]
        dp[0][0][0] = 0
        
        for i in range(1, n+1):
            num = nums[i-1]
            for j in range(k+1):
                if dp[i-1][j][0] > dp[i-1][j][1]:
                    dp[i][j][0] = dp[i-1][j][0]
                else:
                    dp[i][j][0] = dp[i-1][j][1]
                
                if j > 0:
                    coeff = k - j + 1
                    if j % 2 == 0:
                        coeff = -coeff
                    prev_max = max(dp[i-1][j-1][0], dp[i-1][j-1][1])
                    new_val = prev_max + coeff * num
                    cont_val = dp[i-1][j][1] + coeff * num
                    dp[i][j][1] = max(new_val, cont_val)
        
        return max(dp[n][k][0], dp[n][k][1])
```",Y,
count-the-number-of-houses-at-a-certain-distance-ii,Count the Number of Houses at a Certain Distance II,"```python
from typing import List

class Solution:
    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:
        if x > y:
            x, y = y, x
        res = [0] * n
        for i in range(1, n + 1):
            for j in range(i + 1, n + 1):
                d = j - i
                d = min(d, abs(x - i) + 1 + abs(y - j))
                if d <= n:
                    res[d - 1] += 2
        return res
```",Y,
find-the-maximum-sum-of-node-values,Find the Maximum Sum of Node Values,"```python
from typing import List

class Solution:
    def maximumValueSum(self, nums: List[int], k: int, edges: List[List[int]]) -> int:
        total_sum = sum(nums)
        xor_diff = []
        
        for num in nums:
            xor = num ^ k
            xor_diff.append(xor - num)
        
        xor_diff.sort(reverse=True)
        
        for i in range(0, len(xor_diff), 2):
            if i + 1 >= len(xor_diff):
                break
            pair_sum = xor_diff[i] + xor_diff[i + 1]
            if pair_sum > 0:
                total_sum += pair_sum
            else:
                break
        
        return total_sum
```",Y,
count-prefix-and-suffix-pairs-ii,Count Prefix and Suffix Pairs II,"```python
class Solution:
    def countPrefixSuffixPairs(self, words: List[str]) -> int:
        count = 0
        n = len(words)
        for i in range(n):
            s = words[i]
            len_s = len(s)
            for j in range(i + 1, n):
                t = words[j]
                if len(t) >= len_s and t.startswith(s) and t.endswith(s):
                    count += 1
        return count
```",Y,
find-beautiful-indices-in-the-given-array-ii,Find Beautiful Indices in the Given Array II,"```python
class Solution:
    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:
        len_a = len(a)
        len_b = len(b)
        len_s = len(s)
        
        a_indices = []
        for i in range(len_s - len_a + 1):
            if s[i:i+len_a] == a:
                a_indices.append(i)
        
        b_indices = []
        for j in range(len_s - len_b + 1):
            if s[j:j+len_b] == b:
                b_indices.append(j)
        
        if not b_indices:
            return []
        
        res = []
        b_ptr = 0
        len_b_indices = len(b_indices)
        
        for i in a_indices:
            left = 0
            right = len_b_indices
            while left < right:
                mid = (left + right) // 2
                if b_indices[mid] < i - k:
                    left = mid + 1
                else:
                    right = mid
            
            if left < len_b_indices and b_indices[left] <= i + k:
                res.append(i)
        
        return res
```",Y,
maximize-consecutive-elements-in-an-array-after-modification,Maximize Consecutive Elements in an Array After Modification,"```python
from typing import List

class Solution:
    def maxSelectedElements(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        dp = {}
        max_len = 1
        
        for num in nums:
            if num - 1 in dp:
                dp[num] = dp[num - 1] + 1
            else:
                dp[num] = 1
            if num + 1 in dp:
                dp[num + 1] = dp[num] + 1
            if num in dp:
                max_len = max(max_len, dp[num])
            if num + 1 in dp:
                max_len = max(max_len, dp[num + 1])
        
        return max_len
```",Y,
minimum-time-to-revert-word-to-initial-state-ii,Minimum Time to Revert Word to Initial State II,"```python
class Solution:
    def minimumTimeToInitialState(self, word: str, k: int) -> int:
        n = len(word)
        max_possible = (n + k - 1) // k  # Equivalent to ceiling(n / k)
        for t in range(1, max_possible + 1):
            remaining_length = t * k
            if remaining_length >= n:
                return t
            if word[:n - remaining_length] == word[remaining_length:]:
                return t
        return max_possible
```",Y,
number-of-subarrays-that-match-a-pattern-ii,Number of Subarrays That Match a Pattern II,"```python
class Solution:
    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:
        n = len(nums)
        m = len(pattern)
        count = 0
        
        for i in range(n - m):
            match = True
            for k in range(m):
                if pattern[k] == 1:
                    if not (nums[i + k + 1] > nums[i + k]):
                        match = False
                        break
                elif pattern[k] == 0:
                    if not (nums[i + k + 1] == nums[i + k]):
                        match = False
                        break
                elif pattern[k] == -1:
                    if not (nums[i + k + 1] < nums[i + k]):
                        match = False
                        break
            if match:
                count += 1
        return count
```",Y,
earliest-second-to-mark-indices-ii,Earliest Second to Mark Indices II,"```python
from typing import List

class Solution:
    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:
        n = len(nums)
        m = len(changeIndices)
        
        left = 1
        right = m
        answer = -1
        
        while left <= right:
            mid = (left + right) // 2
            last_occurrence = {}
            for s in range(mid):
                i = changeIndices[s] - 1
                last_occurrence[i] = s
            
            if len(last_occurrence) != n:
                left = mid + 1
                continue
            
            total_ops = 0
            possible = True
            for s in range(mid):
                i = changeIndices[s] - 1
                if last_occurrence[i] == s:
                    if nums[i] > total_ops:
                        possible = False
                        break
                    total_ops -= nums[i]
                else:
                    total_ops += 1
            
            if possible:
                answer = mid
                right = mid - 1
            else:
                left = mid + 1
        
        return answer
```",Y,
find-the-number-of-ways-to-place-people-ii,Find the Number of Ways to Place People II,"```python
from typing import List

class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        points.sort()
        count = 0
        n = len(points)
        for i in range(n):
            x1, y1 = points[i]
            for j in range(n):
                if i == j:
                    continue
                x2, y2 = points[j]
                if x2 >= x1 and y2 <= y1:
                    valid = True
                    for k in range(n):
                        if k == i or k == j:
                            continue
                        x, y = points[k]
                        if x >= x1 and x <= x2 and y <= y1 and y >= y2:
                            valid = False
                            break
                    if valid:
                        count += 1
        return count
```",Y,
minimize-or-of-remaining-elements-using-operations,Minimize OR of Remaining Elements Using Operations,"```python
from typing import List

class Solution:
    def minOrAfterOperations(self, nums: List[int], k: int) -> int:
        res = 0
        for bit in range(29, -1, -1):
            mask = 1 << bit
            res_mask = res | mask
            cnt = 0
            current_and = (1 << 30) - 1  # Initialize to all ones
            for num in nums:
                current_and &= num
                if (current_and & res_mask) == 0:
                    cnt += 1
                    current_and = (1 << 30) - 1  # Reset to all ones
            if cnt > k:
                res |= mask
        return res
```",Y,
divide-an-array-into-subarrays-with-minimum-cost-ii,Divide an Array Into Subarrays With Minimum Cost II,"```python
import heapq

class Solution:
    def minimumCost(self, nums: List[int], k: int, dist: int) -> int:
        n = len(nums)
        res = float('inf')
        
        
        
        
        
        
        
        
        if k == 1:
            return nums[0]
        
        
        
        
        
        
        
        
        
        
        min_heap = []
        max_heap = []
        sum_selected = 0
        left = 1  # the left boundary of the current window for i1 candidates
        
        
        
        
        
        
        
        from sortedcontainers import SortedList
        
        sl = SortedList()
        current_sum = 0
        res = float('inf')
        
        
        window_left = 2
        window_right = 1 + dist
        if window_right >= n:
            window_right = n - 1
        
        for i in range(window_left, window_right + 1):
            sl.add(nums[i])
        
        if len(sl) >= k-2:
            current_sum = sum(sl[:k-2])
        else:
            pass
        
        if len(sl) >= k-2:
            res = nums[0] + nums[1] + current_sum
        
        for i1 in range(2, (n-1) - (k-2) + 1):
            
            
            if i1 <= window_right:
                sl.remove(nums[i1])
            
            new_right = i1 + dist
            if new_right <= n-1:
                if new_right > window_right:
                    sl.add(nums[new_right])
                    window_right = new_right
            
            if len(sl) >= k-2:
                current_sum = sum(sl[:k-2])
                candidate = nums[0] + nums[i1] + current_sum
                if candidate < res:
                    res = candidate
            else:
                pass
        
        return res
```",Y,
count-the-number-of-incremovable-subarrays-ii,Count the Number of Incremovable Subarrays II,"```python
from typing import List

class Solution:
    def incremovableSubarrayCount(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return 1
        
        left = 0
        while left + 1 < n and nums[left] < nums[left + 1]:
            left += 1
        
        if left == n - 1:
            return n * (n + 1) // 2
        
        right = n - 1
        while right > 0 and nums[right - 1] < nums[right]:
            right -= 1
        
        res = left + 2  # subarrays ending at left + 1 (0...left + 1)
        res += n - right  # subarrays starting at right - 1 (right - 1...n - 1)
        
        i = 0
        j = right
        while i <= left and j < n:
            if nums[i] < nums[j]:
                res += n - j
                i += 1
            else:
                j += 1
        
        return res
```",Y,
count-the-number-of-powerful-integers,Count the Number of Powerful Integers,"```python
class Solution:
    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:
        s_len = len(s)
        s_num = int(s)
        
        def count_powerful_numbers(high):
            high_str = str(high)
            n = len(high_str)
            if n < s_len:
                return 0
            prefix_len = n - s_len
            prefix_high = int(high_str[:prefix_len]) if prefix_len > 0 else 0
            suffix = int(high_str[prefix_len:])
            
            dp = {}
            def dfs(pos, tight):
                if pos == prefix_len:
                    return 1
                key = (pos, tight)
                if key in dp:
                    return dp[key]
                limit_digit = int(high_str[pos]) if tight else 9
                res = 0
                for d in range(0, min(limit_digit, limit) + 1):
                    new_tight = tight and (d == limit_digit)
                    res += dfs(pos + 1, new_tight)
                dp[key] = res
                return res
            total_prefix = dfs(0, True)
            
            if suffix >= s_num and all(int(c) <= limit for c in high_str[prefix_len:]):
                return total_prefix
            else:
                return total_prefix - 1 if total_prefix > 0 else 0
        
        def count_powerful_numbers_simple(high):
            count = 0
            s_num = int(s)
            if s_num > high:
                return 0
            max_prefix = high // (10 ** s_len)
            for prefix in range(0, max_prefix + 1):
                num = prefix * (10 ** s_len) + s_num
                if num > high:
                    continue
                valid = True
                temp = prefix
                while temp > 0:
                    digit = temp % 10
                    if digit > limit:
                        valid = False
                        break
                    temp = temp // 10
                if valid:
                    count += 1
            return count
        
        if finish < 10**6:
            return count_powerful_numbers_simple(finish) - count_powerful_numbers_simple(start - 1)
        else:
            return count_powerful_numbers(finish) - count_powerful_numbers(start - 1)
```",Y,
minimum-cost-to-convert-string-ii,Minimum Cost to Convert String II,"```python
import heapq
from typing import List

class Solution:
    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        graph = {}
        nodes = set()
        for o, c, co in zip(original, changed, cost):
            nodes.add(o)
            nodes.add(c)
            if o not in graph:
                graph[o] = {}
            if c not in graph[o] or graph[o][c] > co:
                graph[o][c] = co
        
        dist = {}
        for node in nodes:
            dist[node] = {}
            heap = []
            heapq.heappush(heap, (0, node))
            dist[node][node] = 0
            while heap:
                current_dist, u = heapq.heappop(heap)
                if u not in graph:
                    continue
                for v in graph[u]:
                    if v not in dist[node] or dist[node][v] > current_dist + graph[u][v]:
                        dist[node][v] = current_dist + graph[u][v]
                        heapq.heappush(heap, (dist[node][v], v))
        
        n = len(source)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        
        for i in range(n + 1):
            if dp[i] == float('inf'):
                continue
            if i == n:
                break
            if source[i] == target[i]:
                dp[i+1] = min(dp[i+1], dp[i])
            for l in range(1, n - i + 1):
                s_sub = source[i:i+l]
                t_sub = target[i:i+l]
                if s_sub == t_sub:
                    if dp[i + l] > dp[i]:
                        dp[i + l] = dp[i]
                    continue
                if s_sub in dist and t_sub in dist[s_sub]:
                    if dp[i + l] > dp[i] + dist[s_sub][t_sub]:
                        dp[i + l] = dp[i] + dist[s_sub][t_sub]
        
        return dp[n] if dp[n] != float('inf') else -1
```",Y,
maximize-the-number-of-partitions-after-operations,Maximize the Number of Partitions After Operations,"```python
class Solution:
    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:
        n = len(s)
        if k == 26:
            return n
        
        def calculate(s):
            res = 0
            left = 0
            while left < n:
                res += 1
                distinct = set()
                right = left
                while right < n:
                    distinct.add(s[right])
                    if len(distinct) > k:
                        break
                    right += 1
                left = right
            return res
        
        max_partitions = calculate(s)
        if max_partitions == n:
            return n
        
        for i in range(n):
            original_char = s[i]
            for c in 'abcdefghijklmnopqrstuvwxyz':
                if c == original_char:
                    continue
                modified_s = s[:i] + c + s[i+1:]
                current_partitions = calculate(modified_s)
                if current_partitions > max_partitions:
                    max_partitions = current_partitions
                    if max_partitions == n:
                        return n
        return max_partitions
```",Y,
count-the-number-of-infection-sequences,Count the Number of Infection Sequences,"```python
import math
from typing import List

class Solution:
    def numberOfSequence(self, n: int, sick: List[int]) -> int:
        MOD = 10**9 + 7
        gaps = []
        prev = -1
        for pos in sick:
            if prev + 1 < pos:
                gaps.append(pos - prev - 1)
            prev = pos
        if sick[-1] != n - 1:
            gaps.append(n - 1 - sick[-1])
        
        total = 0
        res = 1
        for g in gaps:
            total += g
            res = res * math.comb(total, g) % MOD
        
        sick_prev = -1
        for i in range(len(sick)):
            if i == 0:
                left = sick[i] - 0
                if left > 0:
                    res = res * pow(2, left - 1, MOD) % MOD
            else:
                between = sick[i] - sick[i-1] - 1
                if between > 0:
                    res = res * pow(2, between - 1, MOD) % MOD
        return res
```",Y,
count-complete-substrings,Count Complete Substrings,"```python
class Solution:
    def countCompleteSubstrings(self, word: str, k: int) -> int:
        n = len(word)
        res = 0
        
        for i in range(n):
            freq = [0] * 26
            unique = 0
            valid = True
            
            for j in range(i, n):
                c = ord(word[j]) - ord('a')
                if freq[c] == 0:
                    unique += 1
                freq[c] += 1
                
                if j > i and abs(ord(word[j]) - ord(word[j-1])) > 2:
                    valid = False
                
                if not valid:
                    break
                
                if freq[c] > k:
                    break
                
                if (j - i + 1) == unique * k:
                    res += 1
        
        return res
```",Y,
find-number-of-coins-to-place-in-tree-nodes,Find Number of Coins to Place in Tree Nodes,"```python
from typing import List

class Solution:
    def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:
        n = len(cost)
        tree = [[] for _ in range(n)]
        for a, b in edges:
            tree[a].append(b)
            tree[b].append(a)
        
        res = [1] * n
        
        def dfs(u, parent):
            subtree = [cost[u]]
            for v in tree[u]:
                if v != parent:
                    subtree.extend(dfs(v, u))
            if len(subtree) < 3:
                res[u] = 1
            else:
                subtree_sorted = sorted(subtree)
                max1 = subtree_sorted[-1] * subtree_sorted[-2] * subtree_sorted[-3]
                max2 = subtree_sorted[0] * subtree_sorted[1] * subtree_sorted[-1]
                max_product = max(max1, max2)
                res[u] = max_product if max_product > 0 else 0
            return subtree
        
        dfs(0, -1)
        return res
```",Y,
number-of-possible-sets-of-closing-branches,Number of Possible Sets of Closing Branches,"```python
from typing import List

class Solution:
    def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:
        res = 0
        for mask in range(1 << n):
            active = [i for i in range(n) if (mask & (1 << i))]
            m = len(active)
            if m == 0:
                res += 1
                continue
            
            dist = [[float('inf')] * m for _ in range(m)]
            for i in range(m):
                dist[i][i] = 0
            
            node_to_idx = {node: idx for idx, node in enumerate(active)}
            
            for u, v, w in roads:
                if u in node_to_idx and v in node_to_idx:
                    i = node_to_idx[u]
                    j = node_to_idx[v]
                    if w < dist[i][j]:
                        dist[i][j] = w
                        dist[j][i] = w
            
            for k in range(m):
                for i in range(m):
                    for j in range(m):
                        if dist[i][k] + dist[k][j] < dist[i][j]:
                            dist[i][j] = dist[i][k] + dist[k][j]
            
            valid = True
            for i in range(m):
                for j in range(i + 1, m):
                    if dist[i][j] > maxDistance:
                        valid = False
                        break
                if not valid:
                    break
            if valid:
                res += 1
        return res
```",Y,
count-the-number-of-good-partitions,Count the Number of Good Partitions,"```python
class Solution:
    def numberOfGoodPartitions(self, nums: List[int]) -> int:
        last_occurrence = {}
        for idx, num in enumerate(nums):
            last_occurrence[num] = idx
        
        MOD = 10**9 + 7
        result = 1
        max_last = 0
        
        for i in range(len(nums)):
            max_last = max(max_last, last_occurrence[nums[i]])
            if i == max_last:
                result = (result * 2) % MOD
        
        return result // 2
```",Y,
find-maximum-non-decreasing-array-length,Find Maximum Non-decreasing Array Length,"```python
class Solution:
    def findMaximumLength(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1] * n
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + nums[i]
        
        last_val = [0] * (n + 2)
        dp_val = [0] * (n + 2)
        left = [0] * (n + 2)
        
        for i in range(1, n+1):
            left[i] = left[i-1] + 1
            while left[i] <= i:
                s = prefix[i] - prefix[left[i]-1]
                if s >= last_val[left[i]-1]:
                    break
                left[i] += 1
            
            if left[i] <= i:
                dp[i-1] = dp[left[i]-2] + 1 if left[i] >= 2 else 1
                last_val[i] = prefix[i] - prefix[left[i]-1]
            else:
                dp[i-1] = 1
                last_val[i] = nums[i-1]
        
        return max(dp)
```",Y,
count-beautiful-substrings-ii,Count Beautiful Substrings II,"```python
class Solution:
    def beautifulSubstrings(self, s: str, k: int) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        n = len(s)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + (1 if s[i] in vowels else -1)
        
        from collections import defaultdict
        mod_groups = defaultdict(dict)
        mod_groups[0][0] = 1
        res = 0
        
        for i in range(1, n+1):
            current = prefix[i]
            mod = (current % k + k) % k
            for m in mod_groups.get(mod, {}):
                if (current - m) % 2 == 0:
                    res += mod_groups[mod].get(m, 0)
            mod_groups[prefix[i] % (2 * k)][current] = mod_groups[prefix[i] % (2 * k)].get(current, 0) + 1
        
        return res
```",Y,
palindrome-rearrangement-queries,Palindrome Rearrangement Queries,"```python
class Solution:
    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        n = len(s)
        half = n // 2
        s1 = s[:half]
        s2 = s[half:][::-1]
        
        diff = [0] * (half + 1)
        for i in range(half):
            diff[i+1] = diff[i] + (1 if s1[i] != s2[i] else 0)
        
        freq1 = [[0]*26 for _ in range(half+1)]
        freq2 = [[0]*26 for _ in range(half+1)]
        
        for i in range(half):
            for c in range(26):
                freq1[i+1][c] = freq1[i][c]
                freq2[i+1][c] = freq2[i][c]
            freq1[i+1][ord(s1[i]) - ord('a')] += 1
            freq2[i+1][ord(s2[i]) - ord('a')] += 1
        
        res = []
        for a, b, c, d in queries:
            c_prime = half - 1 - (d - half)
            d_prime = half - 1 - (c - half)
            left_start = min(a, c_prime)
            left_end = max(b, d_prime)
            
            ok = True
            if left_start > 0 and diff[left_start] != 0:
                ok = False
            if left_end + 1 < half and diff[half] - diff[left_end + 1] != 0:
                ok = False
            
            if not ok:
                res.append(False)
                continue
            
            
            s1_freq = [0]*26
            s2_freq = [0]*26
            for i in range(26):
                s1_freq[i] = freq1[b+1][i] - freq1[a][i]
                s2_freq[i] = freq2[d_prime+1][i] - freq2[c_prime][i]
            
            if s1_freq != s2_freq:
                res.append(False)
                continue
            
            res.append(True)
        
        return res
```",Y,
maximum-strong-pair-xor-ii,Maximum Strong Pair XOR II,"```python
from typing import List

class Solution:
    def maximumStrongPairXor(self, nums: List[int]) -> int:
        max_xor = 0
        nums_sorted = sorted(nums)
        n = len(nums_sorted)
        
        for i in range(n):
            x = nums_sorted[i]
            left = i
            right = n - 1
            target = 2 * x
            low, high = i, n - 1
            best = i
            while low <= high:
                mid = (low + high) // 2
                if nums_sorted[mid] <= target:
                    best = mid
                    low = mid + 1
                else:
                    high = mid - 1
            for j in range(i, best + 1):
                y = nums_sorted[j]
                current_xor = x ^ y
                if current_xor > max_xor:
                    max_xor = current_xor
        return max_xor
```",Y,
apply-operations-to-maximize-frequency-score,Apply Operations to Maximize Frequency Score,"```python
class Solution:
    def maxFrequencyScore(self, nums: List[int], k: int) -> int:
        nums.sort()
        left = 0
        total = 0
        max_freq = 1
        
        for right in range(len(nums)):
            total += nums[right]
            
            while nums[right] * (right - left + 1) > total + k:
                total -= nums[left]
                left += 1
            
            max_freq = max(max_freq, right - left + 1)
        
        return max_freq
```",Y,
maximum-balanced-subsequence-sum,Maximum Balanced Subsequence Sum,"```python
import bisect

class Solution:
    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:
        transformed = [nums[i] - i for i in range(len(nums))]
        
        
        sorted_vals = []
        max_sums = []
        
        max_total = -float('inf')
        
        for i in range(len(nums)):
            val = transformed[i]
            current_num = nums[i]
            
            pos = bisect.bisect_right(sorted_vals, val)
            
            current_max = current_num
            if pos > 0:
                current_max += max_sums[pos - 1]
            
            if current_max > max_total:
                max_total = current_max
            
            
            insert_pos = bisect.bisect_left(sorted_vals, val)
            
            while insert_pos < len(sorted_vals) and sorted_vals[insert_pos] == val and max_sums[insert_pos] <= current_max:
                del sorted_vals[insert_pos]
                del max_sums[insert_pos]
            
            if insert_pos == len(sorted_vals) or max_sums[insert_pos] < current_max:
                sorted_vals.insert(insert_pos, val)
                max_sums.insert(insert_pos, current_max)
                
                j = insert_pos + 1
                while j < len(max_sums):
                    if max_sums[j] <= current_max:
                        del sorted_vals[j]
                        del max_sums[j]
                    else:
                        break
        
        return max_total
```",Y,
find-building-where-alice-and-bob-can-meet,Find Building Where Alice and Bob Can Meet,"```python
import bisect
from typing import List

class Solution:
    def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:
        n = len(heights)
        res = [-1] * len(queries)
        processed_queries = []
        for idx, (a, b) in enumerate(queries):
            if a == b:
                res[idx] = a
                continue
            if a > b:
                a, b = b, a
            if heights[a] < heights[b]:
                res[idx] = b
                continue
            processed_queries.append((b, heights[a], idx))
        
        stack = []
        queries_sorted = sorted(processed_queries, key=lambda x: -x[0])
        ptr = len(queries_sorted) - 1
        
        for i in range(n - 1, -1, -1):
            h = heights[i]
            while ptr >= 0 and queries_sorted[ptr][0] == i:
                target_h, min_h, idx = queries_sorted[ptr]
                ptr -= 1
                left = bisect.bisect_right(stack, (-min_h, -1)) 
                if left < len(stack):
                    res[idx] = -stack[left][1]
                else:
                    res[idx] = -1
            
            while stack and stack[-1][0] >= -h:
                stack.pop()
            stack.append((-h, -i))
        
        return res
```",Y,
maximum-points-after-collecting-coins-from-all-nodes,Maximum Points After Collecting Coins From All Nodes,"```python
from typing import List
from collections import deque

class Solution:
    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:
        n = len(coins)
        graph = [[] for _ in range(n)]
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)
        
        parent = [ -1 ] * n
        children = [[] for _ in range(n)]
        q = deque([0])
        parent[0] = -2  # mark as visited
        
        while q:
            u = q.popleft()
            for v in graph[u]:
                if parent[v] == -1:
                    parent[v] = u
                    children[u].append(v)
                    q.append(v)
        
        max_halves = 14
        dp = [[0] * (max_halves + 1) for _ in range(n)]
        
        stack = [(0, False)]
        
        while stack:
            u, processed = stack.pop()
            if not processed:
                stack.append((u, True))
                for v in reversed(children[u]):
                    stack.append((v, False))
            else:
                for h in range(max_halves + 1):
                    current_coin = coins[u] >> h
                    option1 = (current_coin - k) if (current_coin - k) > 0 else 0
                    for v in children[u]:
                        option1 += dp[v][h]
                    
                    option2 = current_coin // 2
                    for v in children[u]:
                        option2 += dp[v][h + 1] if (h + 1) <= max_halves else 0
                    
                    dp[u][h] = max(option1, option2)
        
        return dp[0][0]
```",Y,
apply-operations-on-array-to-maximize-sum-of-squares,Apply Operations on Array to Maximize Sum of Squares,"```python
class Solution:
    def maxSum(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        bits = [0] * 30
        
        for num in nums:
            for i in range(30):
                if num & (1 << i):
                    bits[i] += 1
        
        res = 0
        for _ in range(k):
            current = 0
            for i in range(30):
                if bits[i] > 0:
                    current += (1 << i)
                    bits[i] -= 1
            res = (res + current * current) % MOD
        
        return res
```",Y,
count-visited-nodes-in-a-directed-graph,Count Visited Nodes in a Directed Graph,"```python
class Solution:
    def countVisitedNodes(self, edges: List[int]) -> List[int]:
        n = len(edges)
        res = [0] * n
        visited = [False] * n
        
        for i in range(n):
            if not visited[i]:
                path = []
                current = i
                while True:
                    if visited[current]:
                        if current in path:
                            idx = path.index(current)
                            cycle_length = len(path) - idx
                            for node in path[idx:]:
                                res[node] = cycle_length
                            for j in range(idx):
                                res[path[j]] = cycle_length + idx - j
                        else:
                            for j in range(len(path)):
                                res[path[j]] = res[current] + len(path) - j
                        break
                    visited[current] = True
                    path.append(current)
                    current = edges[current]
        return res
```",Y,
subarrays-distinct-element-sum-of-squares-ii,Subarrays Distinct Element Sum of Squares II,"```python
class Solution:
    def sumCounts(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        total = 0
        n = len(nums)
        for i in range(n):
            distinct = set()
            for j in range(i, n):
                distinct.add(nums[j])
                total = (total + len(distinct) * len(distinct)) % MOD
        return total
```",Y,
count-valid-paths-in-a-tree,Count Valid Paths in a Tree,"```python
import math
from collections import defaultdict
from typing import List

class Solution:
    def countPaths(self, n: int, edges: List[List[int]]) -> int:
        is_prime = [True] * (n + 1)
        is_prime[0] = is_prime[1] = False
        for i in range(2, int(math.sqrt(n)) + 1):
            if is_prime[i]:
                for j in range(i * i, n + 1, i):
                    is_prime[j] = False
        
        adj = defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        
        res = 0
        
        count = defaultdict(lambda: [0, 0])
        
        stack = [(1, None, False)]
        
        while stack:
            node, parent, processed = stack.pop()
            if not processed:
                stack.append((node, parent, True))
                for neighbor in reversed(adj[node]):
                    if neighbor != parent:
                        stack.append((neighbor, node, False))
            else:
                cnt0, cnt1 = 0, 0
                if is_prime[node]:
                    cnt1 = 1
                else:
                    cnt0 = 1
                
                for neighbor in adj[node]:
                    if neighbor == parent:
                        continue
                    child_cnt0, child_cnt1 = count[neighbor]
                    if is_prime[node]:
                        res += child_cnt0
                    else:
                        res += child_cnt1
                    if is_prime[node]:
                        res += cnt0 * child_cnt0
                    else:
                        res += cnt0 * child_cnt1 + cnt1 * child_cnt0
                    if is_prime[node]:
                        cnt1 += child_cnt0
                    else:
                        cnt0 += child_cnt0
                        cnt1 += child_cnt1
                count[node] = [cnt0, cnt1]
        
        return res
```",Y,
maximum-spending-after-buying-items,Maximum Spending After Buying Items,"```python
import heapq
from typing import List

class Solution:
    def maxSpending(self, values: List[List[int]]) -> int:
        m = len(values)
        n = len(values[0]) if m > 0 else 0
        
        max_heap = []
        for i in range(m):
            if n > 0:
                heapq.heappush(max_heap, (-values[i][-1], i, n - 1))
        
        total = 0
        day = 1
        
        while max_heap:
            val_neg, i, j = heapq.heappop(max_heap)
            val = -val_neg
            total += val * day
            day += 1
            if j > 0:
                heapq.heappush(max_heap, (-values[i][j - 1], i, j - 1))
        
        return total
```",Y,
minimum-edge-reversals-so-every-node-is-reachable,Minimum Edge Reversals So Every Node Is Reachable,"```python
from typing import List
from collections import defaultdict, deque

class Solution:
    def minEdgeReversals(self, n: int, edges: List[List[int]]) -> List[int]:
        graph = defaultdict(list)
        reverse_graph = defaultdict(list)
        for u, v in edges:
            graph[u].append((v, 0))  # 0 indicates no reversal needed
            reverse_graph[v].append((u, 1))  # 1 indicates reversal needed
        
        root = 0
        res = [0] * n
        q = deque([root])
        visited = [False] * n
        visited[root] = True
        count = 0
        
        parent = [-1] * n
        children = defaultdict(list)
        stack = [root]
        visited_tree = [False] * n
        visited_tree[root] = True
        while stack:
            u = stack.pop()
            for v, cost in graph[u]:
                if not visited_tree[v]:
                    parent[v] = u
                    children[u].append((v, cost))
                    visited_tree[v] = True
                    stack.append(v)
            for v, cost in reverse_graph[u]:
                if not visited_tree[v]:
                    parent[v] = u
                    children[u].append((v, cost))
                    visited_tree[v] = True
                    stack.append(v)
        
        stack = [(root, 0)]
        total = 0
        while stack:
            u, cost = stack.pop()
            total += cost
            for v, c in children[u]:
                stack.append((v, c))
        res[root] = total
        
        stack = [(root, children[root])]
        while stack:
            u, child_list = stack[-1]
            if not child_list:
                stack.pop()
                continue
            v, cost = child_list.pop()
            res[v] = res[u] + (1 - cost) - cost
            stack.append((v, children[v]))
        
        return res
```",Y,
count-of-sub-multisets-with-bounded-sum,Count of Sub-Multisets With Bounded Sum,"```python
from collections import defaultdict
from typing import List

class Solution:
    def countSubMultisets(self, nums: List[int], l: int, r: int) -> int:
        MOD = 10**9 + 7
        freq = defaultdict(int)
        for num in nums:
            freq[num] += 1
        
        max_sum = r
        dp = [0] * (max_sum + 1)
        dp[0] = 1  # empty multiset
        
        for num, cnt in freq.items():
            if num == 0:
                continue
            for s in range(max_sum, -1, -1):
                if dp[s]:
                    for k in range(1, cnt + 1):
                        if s + k * num <= max_sum:
                            dp[s + k * num] = (dp[s + k * num] + dp[s]) % MOD
                        else:
                            break
        
        total = 0
        for s in range(l, r + 1):
            if s <= max_sum:
                total = (total + dp[s]) % MOD
        
        return total
```",Y,
minimum-edge-weight-equilibrium-queries-in-a-tree,Minimum Edge Weight Equilibrium Queries in a Tree,"```python
from typing import List
from collections import deque

class Solution:
    def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:
        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        
        parent = [0] * n
        depth = [0] * n
        q = deque([0])
        visited = [False] * n
        visited[0] = True
        while q:
            u = q.popleft()
            for v, w in adj[u]:
                if not visited[v] and v != parent[u]:
                    parent[v] = u
                    depth[v] = depth[u] + 1
                    visited[v] = True
                    q.append(v)
        
        LOG = 20
        up = [[-1]*n for _ in range(LOG)]
        up[0] = parent[:]
        for k in range(1, LOG):
            for v in range(n):
                if up[k-1][v] != -1:
                    up[k][v] = up[k-1][up[k-1][v]]
        
        def get_lca(u, v):
            if depth[u] < depth[v]:
                u, v = v, u
            for k in range(LOG-1, -1, -1):
                if depth[u] - (1 << k) >= depth[v]:
                    u = up[k][u]
            if u == v:
                return u
            for k in range(LOG-1, -1, -1):
                if up[k][u] != -1 and up[k][u] != up[k][v]:
                    u = up[k][u]
                    v = up[k][v]
            return parent[u]
        
        res = []
        for a, b in queries:
            lca = get_lca(a, b)
            freq = {}
            u = a
            while u != lca:
                for v, w in adj[u]:
                    if v == parent[u]:
                        freq[w] = freq.get(w, 0) + 1
                        break
                u = parent[u]
            u = b
            while u != lca:
                for v, w in adj[u]:
                    if v == parent[u]:
                        freq[w] = freq.get(w, 0) + 1
                        break
                u = parent[u]
            if not freq:
                res.append(0)
                continue
            max_freq = max(freq.values())
            total = sum(freq.values())
            res.append(total - max_freq)
        return res
```",Y,
maximum-number-of-k-divisible-components,Maximum Number of K-Divisible Components,"```python
from typing import List

class Solution:
    def maxKDivisibleComponents(self, n: int, edges: List[List[int]], values: List[int], k: int) -> int:
        from collections import defaultdict
        
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        res = 0
        
        def dfs(node, parent):
            nonlocal res
            total = values[node]
            for neighbor in graph[node]:
                if neighbor != parent:
                    total += dfs(neighbor, node)
            if total % k == 0:
                res += 1
                return 0
            return total
        
        dfs(0, -1)
        return res
```",Y,
count-k-subsequences-of-a-string-with-maximum-beauty,Count K-Subsequences of a String With Maximum Beauty,"```python
class Solution:
    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:
        from collections import defaultdict
        from math import comb
        
        MOD = 10**9 + 7
        
        freq = defaultdict(int)
        for c in s:
            freq[c] += 1
        
        if k > len(freq):
            return 0
        
        freq_list = sorted(freq.values(), reverse=True)
        max_sum = sum(freq_list[:k])
        
        
        m = freq_list[k-1]
        total = 0  # total number of elements with frequency >= m in the entire list
        cnt_in_top_k = 0  # number of elements with frequency == m in the top k
        
        for f in freq_list:
            if f > m:
                total += 1
            elif f == m:
                cnt_in_top_k += 1
        total += cnt_in_top_k
        
        
        x = k - (total - cnt_in_top_k)
        if x < 0:
            return 0
        
        ways = comb(cnt_in_top_k, x)
        
        res = 1
        for f in freq_list:
            if f > m:
                res = (res * f) % MOD
            elif f == m:
                if x > 0:
                    res = (res * f) % MOD
                    x -= 1
            else:
                break
        
        res = (res * ways) % MOD
        return res
```",Y,
maximum-element-sum-of-a-complete-subset-of-indices,Maximum Element-Sum of a Complete Subset of Indices,"```python
import math
from collections import defaultdict
from typing import List

class Solution:
    def maximumSum(self, nums: List[int]) -> int:
        def get_square_free(x):
            res = 1
            for i in range(2, int(math.isqrt(x)) + 1):
                if x % i == 0:
                    cnt = 0
                    while x % i == 0:
                        x //= i
                        cnt += 1
                    if cnt % 2 == 1:
                        res *= i
            if x > 1:
                res *= x
            return res
        
        groups = defaultdict(int)
        for i in range(1, len(nums) + 1):
            sf = get_square_free(i)
            groups[sf] += nums[i - 1]
        
        return max(groups.values()) if groups else 0
```",Y,
maximize-value-of-function-in-a-ball-passing-game,Maximize Value of Function in a Ball Passing Game,"```python
class Solution:
    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:
        n = len(receiver)
        max_level = k.bit_length()
        parent = [[-1] * n for _ in range(max_level)]
        sum_path = [[0] * n for _ in range(max_level)]
        
        for i in range(n):
            parent[0][i] = receiver[i]
            sum_path[0][i] = i
        
        for level in range(1, max_level):
            for i in range(n):
                parent_prev = parent[level - 1][i]
                parent[level][i] = parent[level - 1][parent_prev]
                sum_path[level][i] = sum_path[level - 1][i] + sum_path[level - 1][parent_prev]
        
        max_score = 0
        for i in range(n):
            current = i
            total = 0
            remaining = k
            for level in range(max_level):
                if (remaining >> level) & 1:
                    total += sum_path[level][current]
                    current = parent[level][current]
            total += current
            if total > max_score:
                max_score = total
        return max_score
```",Y,
minimum-operations-to-form-subsequence-with-target-sum,Minimum Operations to Form Subsequence With Target Sum,"```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int], target: int) -> int:
        total = sum(nums)
        if total < target:
            return -1
        
        freq = [0] * 32
        for num in nums:
            power = num.bit_length() - 1
            freq[power] += 1
        
        operations = 0
        for i in range(31):
            if (target >> i) & 1:
                if freq[i] > 0:
                    freq[i] -= 1
                else:
                    j = i + 1
                    while j < 31 and freq[j] == 0:
                        j += 1
                    if j == 31:
                        return -1
                    freq[j] -= 1
                    operations += j - i
                    for k in range(i, j):
                        freq[k] += 1
            freq[i + 1] += freq[i] // 2
        
        return operations
```",Y,
string-transformation,String Transformation,"```python
MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, s: str, t: str, k: int) -> int:
        n = len(s)
        if n != len(t):
            return 0
        
        shifts = []
        doubled = s + s
        for i in range(1, n+1):
            if doubled[i:i+n] == t:
                shifts.append(i)
        if not shifts:
            return 0
        
        m = len(shifts)
        
        
        
        initial_shift_0 = 1 if 0 in shifts else 0
        f0 = 0
        g0 = initial_shift_0
        
        if k == 0:
            return g0 % MOD
        
        a = (n - m) % MOD
        b = (m - 1) % MOD
        c = (n - m - 1) % MOD
        d = m % MOD
        
        def matrix_mult(A, B):
            return [
                [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % MOD,
                 (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % MOD],
                [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % MOD,
                 (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % MOD]
            ]
        
        def matrix_pow(mat, power):
            result = [[1, 0], [0, 1]]  # Identity matrix
            while power > 0:
                if power % 2 == 1:
                    result = matrix_mult(result, mat)
                mat = matrix_mult(mat, mat)
                power //= 2
            return result
        
        mat = [[a, b], [c, d]]
        mat_k = matrix_pow(mat, k)
        
        
        
        if initial_shift_0:
            res = mat_k[0][1]
        else:
            res = mat_k[1][1] * m % MOD
        
        return res % MOD
```",Y,
number-of-beautiful-integers-in-the-range,Number of Beautiful Integers in the Range,"```python
class Solution:
    def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -> int:
        def countBeautifulNumbers(n):
            s = str(n)
            length = len(s)
            from functools import lru_cache
            
            @lru_cache(maxsize=None)
            def dp(pos, tight, even_odd_diff, mod, leading_zero):
                if pos == length:
                    return 1 if (even_odd_diff == 0 and mod == 0 and not leading_zero) else 0
                limit = int(s[pos]) if tight else 9
                total = 0
                for d in range(0, limit + 1):
                    new_tight = tight and (d == limit)
                    new_leading_zero = leading_zero and (d == 0)
                    new_mod = (mod * 10 + d) % k if not new_leading_zero else 0
                    if new_leading_zero:
                        new_even_odd_diff = even_odd_diff
                    else:
                        if d % 2 == 0:
                            new_even_odd_diff = even_odd_diff + 1
                        else:
                            new_even_odd_diff = even_odd_diff - 1
                    total += dp(pos + 1, new_tight, new_even_odd_diff, new_mod, new_leading_zero)
                return total
            return dp(0, True, 0, 0, True)
        
        return countBeautifulNumbers(high) - countBeautifulNumbers(low - 1)
```",Y,
apply-operations-to-maximize-score,Apply Operations to Maximize Score,"```python
import heapq

class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        
        def compute_prime_score(x):
            if x == 1:
                return 0
            factors = set()
            if x % 2 == 0:
                factors.add(2)
                while x % 2 == 0:
                    x //= 2
            i = 3
            while i * i <= x:
                if x % i == 0:
                    factors.add(i)
                    while x % i == 0:
                        x //= i
                i += 2
            if x > 1:
                factors.add(x)
            return len(factors)
        
        n = len(nums)
        prime_scores = [compute_prime_score(num) for num in nums]
        
        next_greater = [n] * n
        stack = []
        for i in range(n):
            while stack and prime_scores[stack[-1]] < prime_scores[i]:
                next_greater[stack.pop()] = i
            stack.append(i)
        
        prev_greater = [-1] * n
        stack = []
        for i in range(n-1, -1, -1):
            while stack and prime_scores[stack[-1]] <= prime_scores[i]:
                prev_greater[stack.pop()] = i
            stack.append(i)
        
        max_heap = []
        for i in range(n):
            left = prev_greater[i] + 1
            right = next_greater[i] - 1
            count = (i - left + 1) * (right - i + 1)
            heapq.heappush(max_heap, (-nums[i], count))
        
        res = 1
        remaining_k = k
        while remaining_k > 0 and max_heap:
            num, cnt = heapq.heappop(max_heap)
            num = -num
            use = min(remaining_k, cnt)
            res = (res * pow(num, use, MOD)) % MOD
            remaining_k -= use
        return res
```",Y,
minimum-time-to-make-array-sum-at-most-x,Minimum Time to Make Array Sum At Most x,"```python
from typing import List

class Solution:
    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:
        n = len(nums1)
        pairs = list(zip(nums2, nums1))
        pairs.sort()
        
        dp = [0] * (n + 1)
        
        for j in range(1, n + 1):
            b, a = pairs[j - 1]
            for i in range(j, 0, -1):
                dp[i] = max(dp[i], dp[i - 1] + a + b * i)
        
        total1 = sum(nums1)
        total2 = sum(nums2)
        
        for t in range(0, n + 1):
            if total1 + total2 * t - dp[t] <= x:
                return t
        
        return -1
```",Y,
count-stepping-numbers-in-range,Count Stepping Numbers in Range,"```python
class Solution:
    def countSteppingNumbers(self, low: str, high: str) -> int:
        MOD = 10**9 + 7
        
        def count_stepping_numbers_up_to(s):
            n = len(s)
            s = list(map(int, s))
            
            memo = {}
            
            def dp(pos, prev, tight, leading_zero):
                if pos == n:
                    return 0 if leading_zero else 1
                key = (pos, prev, tight, leading_zero)
                if key in memo:
                    return memo[key]
                
                limit = s[pos] if tight else 9
                total = 0
                
                for d in range(0, limit + 1):
                    new_tight = tight and (d == limit)
                    new_leading_zero = leading_zero and (d == 0)
                    
                    if new_leading_zero:
                        total += dp(pos + 1, prev, new_tight, new_leading_zero)
                    else:
                        if leading_zero or abs(d - prev) == 1:
                            total += dp(pos + 1, d, new_tight, False)
                
                memo[key] = total % MOD
                return memo[key]
            
            return dp(0, 0, True, True)
        
        def is_stepping_number(num_str):
            num = list(map(int, num_str))
            for i in range(1, len(num)):
                if abs(num[i] - num[i-1]) != 1:
                    return False
            return True
        
        low_num = int(low)
        high_num = int(high)
        
        count_high = count_stepping_numbers_up_to(high)
        count_low = count_stepping_numbers_up_to(str(low_num - 1)) if low_num > 1 else 0
        total = (count_high - count_low) % MOD
        
        if is_stepping_number(low):
            total = (total + 1) % MOD
        
        return total
```",Y,
maximum-number-of-groups-with-increasing-length,Maximum Number of Groups With Increasing Length,"```python
class Solution:
    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:
        usageLimits = sorted(usageLimits)
        total = 0
        res = 0
        for num in usageLimits:
            total += num
            if total >= (res + 1) * (res + 2) // 2:
                res += 1
        return res
```",Y,
count-paths-that-can-form-a-palindrome-in-a-tree,Count Paths That Can Form a Palindrome in a Tree,"```python
from collections import defaultdict
from typing import List

class Solution:
    def countPalindromePaths(self, parent: List[int], s: str) -> int:
        n = len(parent)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)
        
        mask_count = defaultdict(int)
        mask_count[0] = 1
        result = 0
        
        stack = [(0, 0)]
        while stack:
            node, mask = stack.pop()
            for child in children[node]:
                edge_char = s[child]
                new_mask = mask ^ (1 << (ord(edge_char) - ord('a')))
                result += mask_count[new_mask]
                for i in range(26):
                    result += mask_count[new_mask ^ (1 << i)]
                mask_count[new_mask] += 1
                stack.append((child, new_mask))
        
        return result
```",Y,
maximum-elegance-of-a-k-length-subsequence,Maximum Elegance of a K-Length Subsequence,"```python
class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items.sort(reverse=True)
        res = 0
        total_profit = 0
        category_set = set()
        duplicate = []
        
        for i in range(k):
            profit, category = items[i]
            total_profit += profit
            if category in category_set:
                duplicate.append(profit)
            else:
                category_set.add(category)
        res = total_profit + len(category_set) ** 2
        
        for i in range(k, len(items)):
            if not duplicate:
                break
            profit, category = items[i]
            if category not in category_set:
                replaced_profit = duplicate.pop()
                total_profit = total_profit - replaced_profit + profit
                category_set.add(category)
                res = max(res, total_profit + len(category_set) ** 2)
        
        return res
```",Y,
length-of-the-longest-valid-substring,Length of the Longest Valid Substring,"```python
class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        forbidden_set = set(forbidden)
        max_len = max(len(f) for f in forbidden) if forbidden else 0
        left = 0
        res = 0
        n = len(word)
        
        for right in range(n):
            for l in range(1, min(max_len + 1, right - left + 2)):
                substring = word[right - l + 1 : right + 1]
                if substring in forbidden_set:
                    left = right - l + 2
                    break
            res = max(res, right - left + 1)
        
        return res
```",Y,
minimum-changes-to-make-k-semi-palindromes,Minimum Changes to Make K Semi-palindromes,"```python
class Solution:
    def minimumChanges(self, s: str, k: int) -> int:
        n = len(s)
        cost = [[0] * n for _ in range(n)]
        
        for i in range(n):
            for j in range(i + 1, n):
                length = j - i + 1
                min_cost = float('inf')
                for d in range(1, length):
                    if length % d != 0:
                        continue
                    current_cost = 0
                    for group in range(d):
                        left = i + group
                        right = j - (d - 1 - group)
                        l, r = left, right
                        while l < r:
                            if s[l] != s[r]:
                                current_cost += 1
                            l += d
                            r -= d
                    min_cost = min(min_cost, current_cost)
                cost[i][j] = min_cost if min_cost != float('inf') else 0
        
        dp = [[float('inf')] * n for _ in range(k + 1)]
        for i in range(n):
            dp[1][i] = cost[0][i]
        
        for t in range(2, k + 1):
            for i in range(t - 1, n):
                for j in range(t - 2, i):
                    if dp[t - 1][j] + cost[j + 1][i] < dp[t][i]:
                        dp[t][i] = dp[t - 1][j] + cost[j + 1][i]
        
        return dp[k][n - 1]
```",Y,
sum-of-imbalance-numbers-of-all-subarrays,Sum of Imbalance Numbers of All Subarrays,"```python
class Solution:
    def sumImbalanceNumbers(self, nums: List[int]) -> int:
        n = len(nums)
        total = 0
        for i in range(n):
            seen = set()
            current_imbalance = 0
            for j in range(i, n):
                x = nums[j]
                if x not in seen:
                    seen.add(x)
                    left = x - 1 in seen
                    right = x + 1 in seen
                    if left and right:
                        current_imbalance -= 1
                    elif not left and not right and len(seen) > 1:
                        current_imbalance += 1
                total += current_imbalance
        return total
```",Y,
robot-collisions,Robot Collisions,"```python
from typing import List

class Solution:
    def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:
        robots = sorted(zip(positions, healths, directions, range(len(positions))), key=lambda x: x[0])
        stack = []
        
        for pos, health, direction, idx in robots:
            if direction == 'R':
                stack.append((pos, health, direction, idx))
                continue
            while stack and stack[-1][2] == 'R':
                prev_pos, prev_health, prev_dir, prev_idx = stack.pop()
                if prev_health > health:
                    new_health = prev_health - 1
                    if new_health > 0:
                        stack.append((prev_pos, new_health, prev_dir, prev_idx))
                    health = 0
                    break
                elif prev_health < health:
                    health -= 1
                else:
                    health = 0
                    break
            if health > 0:
                stack.append((pos, health, direction, idx))
        
        stack.sort(key=lambda x: x[3])
        return [robot[1] for robot in stack]
```",Y,
maximum-sum-queries,Maximum Sum Queries,"```python
import bisect
from typing import List

class Solution:
    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        pairs = sorted([(a, b) for a, b in zip(nums1, nums2)], key=lambda x: -x[0] - x[1])
        
        
        
        
        
        
        
        stack = []
        for a, b in pairs:
            sum_ab = a + b
            if not stack:
                stack.append((b, sum_ab))
            else:
                if b > stack[-1][0]:
                    stack.append((b, sum_ab))
                else:
                    idx = bisect.bisect_left(stack, (b, 0))
                    if idx == len(stack):
                        if sum_ab > stack[-1][1]:
                            stack.append((b, sum_ab))
                    else:
                        if sum_ab > stack[idx][1]:
                            stack.insert(idx, (b, sum_ab))
        
        
        
        
        
        
        
        all_y = nums2.copy()
        for _, y in queries:
            all_y.append(y)
        sorted_unique_y = sorted(set(all_y))
        y_to_compressed = {y: i for i, y in enumerate(sorted_unique_y)}
        
        
        
        m = len(sorted_unique_y)
        max_val = [ -1 ] * (4 * m)
        
        def update(node, l, r, y, val):
            if l == r:
                max_val[node] = max(max_val[node], val)
                return
            mid = (l + r) // 2
            if y <= sorted_unique_y[mid]:
                update(2 * node + 1, l, mid, y, val)
            else:
                update(2 * node + 2, mid + 1, r, y, val)
            max_val[node] = max(max_val[2 * node + 1], max_val[2 * node + 2])
        
        def query(node, l, r, y_low):
            if y_low <= sorted_unique_y[l]:
                return max_val[node]
            if y_low > sorted_unique_y[r]:
                return -1
            mid = (l + r) // 2
            left = query(2 * node + 1, l, mid, y_low)
            right = query(2 * node + 2, mid + 1, r, y_low)
            return max(left, right)
        
        indexed_queries = [ (xi, yi, i) for i, (xi, yi) in enumerate(queries) ]
        indexed_queries.sort(reverse=True, key=lambda q: q[0])
        pairs.sort(reverse=True, key=lambda p: p[0])
        
        res = [ -1 ] * len(queries)
        ptr = 0
        n = len(pairs)
        
        for xi, yi, idx in indexed_queries:
            while ptr < n and pairs[ptr][0] >= xi:
                a, b = pairs[ptr]
                sum_ab = a + b
                compressed_y = y_to_compressed[b]
                update(0, 0, m - 1, b, sum_ab)
                ptr += 1
            if yi > sorted_unique_y[-1]:
                res[idx] = -1
            else:
                res[idx] = query(0, 0, m - 1, yi)
        
        return res
```",Y,
greatest-common-divisor-traversal,Greatest Common Divisor Traversal,"```python
import math
from collections import defaultdict

class Solution:
    def canTraverseAllPairs(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return True
        
        parent = {}
        size = defaultdict(int)
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root == v_root:
                return
            if size[u_root] > size[v_root]:
                parent[v_root] = u_root
                size[u_root] += size[v_root]
            else:
                parent[u_root] = v_root
                size[v_root] += size[u_root]
        
        prime_to_indices = defaultdict(list)
        
        for i, num in enumerate(nums):
            if num == 1:
                return False
            factors = self.get_prime_factors(num)
            for p in factors:
                prime_to_indices[p].append(i)
        
        for p in prime_to_indices:
            indices = prime_to_indices[p]
            for i in range(1, len(indices)):
                union(indices[i-1], indices[i])
        
        root = find(0)
        for i in range(len(nums)):
            if find(i) != root:
                return False
        return True
    
    def get_prime_factors(self, n):
        factors = set()
        if n == 1:
            return factors
        while n % 2 == 0:
            factors.add(2)
            n = n // 2
        i = 3
        while i * i <= n:
            while n % i == 0:
                factors.add(i)
                n = n // i
            i += 2
        if n > 2:
            factors.add(n)
        return factors
```",Y,
find-a-good-subset-of-the-matrix,Find a Good Subset of the Matrix,"```python
from typing import List

class Solution:
    def goodSubsetofBinaryMatrix(self, grid: List[List[int]]) -> List[int]:
        m = len(grid)
        n = len(grid[0]) if m > 0 else 0
        
        for i in range(m):
            all_leq_half = True
            for val in grid[i]:
                if val > 0.5:  # since k=1, floor(1/2)=0, so sum must be 0
                    all_leq_half = False
                    break
            if all_leq_half:
                return [i]
        
        for i in range(m):
            for j in range(i + 1, m):
                k = 2
                valid = True
                for col in range(n):
                    total = grid[i][col] + grid[j][col]
                    if total > k // 2:
                        valid = False
                        break
                if valid:
                    return sorted([i, j])
        
        return []
```",Y,
maximum-strictly-increasing-cells-in-a-matrix,Maximum Strictly Increasing Cells in a Matrix,"```python
from collections import defaultdict
from bisect import bisect_right

class Solution:
    def maxIncreasingCells(self, mat: List[List[int]]) -> int:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        
        value_positions = defaultdict(list)
        for i in range(m):
            for j in range(n):
                value_positions[mat[i][j]].append((i, j))
        
        sorted_values = sorted(value_positions.keys())
        
        row_max = [0] * m
        col_max = [0] * n
        
        temp_row = defaultdict(int)
        temp_col = defaultdict(int)
        
        for val in sorted_values:
            for i, j in value_positions[val]:
                max_step = max(row_max[i], col_max[j]) + 1
                temp_row[i] = max(temp_row[i], max_step)
                temp_col[j] = max(temp_col[j], max_step)
            
            for i, j in value_positions[val]:
                row_max[i] = max(row_max[i], temp_row[i])
                col_max[j] = max(col_max[j], temp_col[j])
        
        return max(max(row_max), max(col_max))
```",Y,
painting-the-walls,Painting the Walls,"```python
class Solution:
    def paintWalls(self, cost: List[int], time: List[int]) -> int:
        n = len(cost)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        for i in range(n):
            c, t = cost[i], time[i]
            for j in range(n, -1, -1):
                new_j = min(j + t + 1, n)
                if dp[j] + c < dp[new_j]:
                    dp[new_j] = dp[j] + c
        return dp[n]
```",Y,
modify-graph-edge-weights,Modify Graph Edge Weights,"```python
import heapq
from collections import defaultdict

class Solution:
    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:
        adj = defaultdict(list)
        for i, (u, v, w) in enumerate(edges):
            adj[u].append((v, i))
            adj[v].append((u, i))
        
        def dijkstra(adj, edges, src, dest, skip_negative):
            min_heap = []
            heapq.heappush(min_heap, (0, src))
            dist = {node: float('inf') for node in range(n)}
            dist[src] = 0
            parent = {}
            visited = set()
            
            while min_heap:
                current_dist, u = heapq.heappop(min_heap)
                if u in visited:
                    continue
                visited.add(u)
                if u == dest:
                    break
                for (v, idx) in adj[u]:
                    w = edges[idx][2]
                    if w == -1:
                        if skip_negative:
                            continue
                        w = 1  # treat -1 as 1 temporarily
                    if dist[v] > current_dist + w:
                        dist[v] = current_dist + w
                        parent[v] = u
                        heapq.heappush(min_heap, (dist[v], v))
            return dist.get(dest, float('inf')), parent
        
        shortest_path, _ = dijkstra(adj, edges, source, destination, skip_negative=False)
        if shortest_path > target:
            return []
        
        shortest_path_skip, parent = dijkstra(adj, edges, source, destination, skip_negative=True)
        if shortest_path_skip < target:
            return []
        elif shortest_path_skip == target:
            path_edges = set()
            node = destination
            while node != source:
                prev = parent[node]
                for (v, idx) in adj[prev]:
                    if v == node:
                        path_edges.add(idx)
                        break
                node = prev
            modified_edges = []
            for i, (u, v, w) in enumerate(edges):
                if w == -1:
                    if i not in path_edges:
                        modified_edges.append([u, v, 1])
                    else:
                        modified_edges.append([u, v, target - shortest_path_skip + 1])
                else:
                    modified_edges.append([u, v, w])
            return modified_edges
        
        dist = {node: float('inf') for node in range(n)}
        dist[source] = 0
        heap = [(0, source)]
        parent = {}
        edge_usage = {}  # to store which edge was used to reach a node
        
        while heap:
            current_dist, u = heapq.heappop(heap)
            if u == destination:
                break
            if current_dist > dist[u]:
                continue
            for (v, idx) in adj[u]:
                w = edges[idx][2]
                if w == -1:
                    w = 1
                if dist[v] > current_dist + w:
                    dist[v] = current_dist + w
                    parent[v] = u
                    edge_usage[v] = idx
                    heapq.heappush(heap, (dist[v], v))
        
        path = []
        node = destination
        while node != source:
            prev = parent[node]
            edge_idx = edge_usage[node]
            path.append(edge_idx)
            node = prev
        
        count_neg = 0
        for idx in path:
            if edges[idx][2] == -1:
                count_neg += 1
        
        if count_neg == 0:
            return []  # no -1 edges to adjust
        
        total_needed = target - (dist[destination] - count_neg)
        if total_needed < count_neg:
            return []  # each -1 edge must be at least 1
        
        remaining = total_needed
        modified = {}
        for idx in path:
            if edges[idx][2] == -1:
                if remaining > 0:
                    assign = 1 + remaining
                    modified[idx] = assign
                    remaining = 0
                else:
                    modified[idx] = 1
        
        result = []
        for i, (u, v, w) in enumerate(edges):
            if w == -1:
                if i in modified:
                    result.append([u, v, modified[i]])
                else:
                    result.append([u, v, 1])
            else:
                result.append([u, v, w])
        
        adj_modified = defaultdict(list)
        for u, v, w in result:
            adj_modified[u].append((v, w))
            adj_modified[v].append((u, w))
        
        heap = [(0, source)]
        dist_modified = {node: float('inf') for node in range(n)}
        dist_modified[source] = 0
        
        while heap:
            current_dist, u = heapq.heappop(heap)
            if u == destination:
                break
            if current_dist > dist_modified[u]:
                continue
            for (v, w) in adj_modified[u]:
                if dist_modified[v] > current_dist + w:
                    dist_modified[v] = current_dist + w
                    heapq.heappush(heap, (dist_modified[v], v))
        
        if dist_modified.get(destination, float('inf')) == target:
            return result
        else:
            return []
```",Y,
power-of-heroes,Power of Heroes,"```python
class Solution:
    def sumOfPower(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        nums.sort()
        res = 0
        prefix = 0
        for num in nums:
            res = (res + (num ** 3) % MOD + (prefix * (num ** 2) % MOD) % MOD
            prefix = (prefix * 2 + num) % MOD
        return res
```",Y,
make-array-empty,Make Array Empty,"```python
from typing import List
import bisect

class Solution:
    def countOperationsToEmptyArray(self, nums: List[int]) -> int:
        n = len(nums)
        sorted_nums = sorted((num, i) for i, num in enumerate(nums))
        res = n  # initial pass through all elements
        
        for k in range(1, n):
            if sorted_nums[k-1][1] > sorted_nums[k][1]:
                res += n - k
        
        return res
```",Y,
count-of-integers,Count of Integers,"```python
class Solution:
    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:
        MOD = 10**9 + 7
        
        def digit_dp(s):
            n = len(s)
            memo = {}
            
            def dfs(pos, tight, sum_so_far):
                if pos == n:
                    return 1 if min_sum <= sum_so_far <= max_sum else 0
                key = (pos, tight, sum_so_far)
                if key in memo:
                    return memo[key]
                
                limit = int(s[pos]) if tight else 9
                total = 0
                for d in range(0, limit + 1):
                    new_tight = tight and (d == limit)
                    new_sum = sum_so_far + d
                    if new_sum > max_sum:
                        continue
                    total += dfs(pos + 1, new_tight, new_sum)
                    total %= MOD
                
                memo[key] = total
                return total
            
            return dfs(0, True, 0)
        
        def is_valid(num_str):
            digit_sum = sum(int(c) for c in num_str)
            return min_sum <= digit_sum <= max_sum
        
        total = digit_dp(num2) - digit_dp(num1) + (1 if is_valid(num1) else 0)
        return total % MOD
```",Y,
minimize-the-total-price-of-the-trips,Minimize the Total Price of the Trips,"```python
from typing import List
from collections import defaultdict, deque

class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        count = [0] * n
        for start, end in trips:
            parent = {}
            visited = set()
            q = deque()
            q.append(start)
            visited.add(start)
            found = False
            while q and not found:
                node = q.popleft()
                for neighbor in graph[node]:
                    if neighbor not in visited:
                        parent[neighbor] = node
                        visited.add(neighbor)
                        q.append(neighbor)
                        if neighbor == end:
                            found = True
                            break
            path = []
            current = end
            while current != start:
                path.append(current)
                current = parent[current]
            path.append(start)
            for node in path:
                count[node] += 1
        
        dp = [[0, 0] for _ in range(n)]
        
        visited = [False] * n
        
        def dfs(node, parent):
            visited[node] = True
            for neighbor in graph[node]:
                if neighbor != parent and not visited[neighbor]:
                    dfs(neighbor, node)
            halve = (price[node] // 2) * count[node]
            no_halve = price[node] * count[node]
            
            for neighbor in graph[node]:
                if neighbor != parent:
                    halve += dp[neighbor][0]
                    no_halve += min(dp[neighbor][0], dp[neighbor][1])
            
            dp[node][0] = no_halve
            dp[node][1] = halve
        
        dfs(0, -1)
        
        return min(dp[0][0], dp[0][1])
```",Y,
minimum-reverse-operations,Minimum Reverse Operations,"```python
from collections import deque
from typing import List

class Solution:
    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:
        banned_set = set(banned)
        res = [-1] * n
        res[p] = 0
        q = deque([p])
        
        
        available = [set(), set()]  # 0 for even indices, 1 for odd
        for i in range(n):
            if i != p and i not in banned_set:
                available[i % 2].add(i)
        
        while q:
            current = q.popleft()
            low = max(0, current - k + 1)
            high = min(current, n - k)
            min_new_pos = 2 * low + k - 1 - current
            max_new_pos = 2 * high + k - 1 - current
            parity = (k - 1 - current) % 2
            to_remove = []
            for num in available[parity]:
                if min_new_pos <= num <= max_new_pos:
                    res[num] = res[current] + 1
                    q.append(num)
                    to_remove.append(num)
            for num in to_remove:
                available[parity].remove(num)
        return res
```",Y,
collect-coins-in-a-tree,Collect Coins in a Tree,"```python
from typing import List
from collections import deque

class Solution:
    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:
        n = len(coins)
        if n == 1:
            return 0
        
        graph = [[] for _ in range(n)]
        degree = [0] * n
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)
            degree[a] += 1
            degree[b] += 1
        
        q = deque()
        for i in range(n):
            if degree[i] == 1 and coins[i] == 0:
                q.append(i)
        
        remaining_nodes = n
        while q:
            u = q.popleft()
            remaining_nodes -= 1
            for v in graph[u]:
                if degree[v] > 0:
                    degree[v] -= 1
                    if degree[v] == 1 and coins[v] == 0:
                        q.append(v)
        
        q = deque()
        for i in range(n):
            if degree[i] == 1 and coins[i] == 1:
                q.append(i)
        
        for _ in range(2):
            sz = len(q)
            for __ in range(sz):
                u = q.popleft()
                remaining_nodes -= 1
                for v in graph[u]:
                    if degree[v] > 0:
                        degree[v] -= 1
                        if degree[v] == 1:
                            q.append(v)
        
        if remaining_nodes <= 1:
            return 0
        return 2 * (remaining_nodes - 1)
```",Y,
minimum-time-to-visit-a-cell-in-a-grid,Minimum Time to Visit a Cell In a Grid,"```python
import heapq
from typing import List

class Solution:
    def minimumTime(self, grid: List[List[int]]) -> int:
        if grid[0][1] > 1 and grid[1][0] > 1:
            return -1
        
        m, n = len(grid), len(grid[0])
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        heap = []
        heapq.heappush(heap, (0, 0, 0))  # (time, row, col)
        visited = [[False for _ in range(n)] for _ in range(m)]
        
        while heap:
            time, row, col = heapq.heappop(heap)
            if row == m - 1 and col == n - 1:
                return time
            if visited[row][col]:
                continue
            visited[row][col] = True
            for dr, dc in directions:
                nr, nc = row + dr, col + dc
                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]:
                    if grid[nr][nc] <= time + 1:
                        heapq.heappush(heap, (time + 1, nr, nc))
                    else:
                        diff = grid[nr][nc] - time
                        wait_time = diff + (1 if diff % 2 == 0 else 0)
                        heapq.heappush(heap, (time + wait_time, nr, nc))
        return -1
```",Y,
find-the-string-with-lcp,Find the String with LCP,"```python
from typing import List

class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        n = len(lcp)
        word = [''] * n
        
        for i in range(n):
            if lcp[i][i] != n - i:
                return """"
            for j in range(n):
                if lcp[i][j] != lcp[j][i]:
                    return """"
                if lcp[i][j] > n - max(i, j):
                    return """"
        
        current_char = 'a'
        for i in range(n):
            if word[i] == '':
                if current_char > 'z':
                    return """"  # Not enough letters
                word[i] = current_char
                for j in range(i + 1, n):
                    if lcp[i][j] > 0:
                        if j >= n:
                            return """"
                        if word[j] == '':
                            word[j] = word[i]
                        elif word[j] != word[i]:
                            return """"
                current_char = chr(ord(current_char) + 1)
        
        for i in range(n - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if i == j:
                    if lcp[i][j] != n - i:
                        return """"
                else:
                    if word[i] != word[j]:
                        if lcp[i][j] != 0:
                            return """"
                    else:
                        max_len = 0
                        if i + 1 < n and j + 1 < n:
                            if word[i] == word[j]:
                                max_len = lcp[i + 1][j + 1] + 1
                        if lcp[i][j] != max_len:
                            return """"
        return ''.join(word)
```",Y,
handling-sum-queries-after-update,Handling Sum Queries After Update,"```python
class Solution:
    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        n = len(nums1)
        res = []
        sum_nums2 = sum(nums2)
        sum_nums1 = sum(nums1)
        
        for query in queries:
            if query[0] == 1:
                l, r = query[1], query[2]
                for i in range(l, r + 1):
                    if nums1[i] == 1:
                        nums1[i] = 0
                        sum_nums1 -= 1
                    else:
                        nums1[i] = 1
                        sum_nums1 += 1
            elif query[0] == 2:
                p = query[1]
                sum_nums2 += sum_nums1 * p
            elif query[0] == 3:
                res.append(sum_nums2)
        
        return res
```",Y,
subsequence-with-the-minimum-score,Subsequence With the Minimum Score,"```python
class Solution:
    def minimumScore(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        left_pos = [-1] * n
        i = 0
        for j in range(n):
            while i < m and s[i] != t[j]:
                i += 1
            if i < m:
                left_pos[j] = i
                i += 1
            else:
                break
        
        right_pos = [-1] * n
        i = m - 1
        for j in range(n - 1, -1, -1):
            while i >= 0 and s[i] != t[j]:
                i -= 1
            if i >= 0:
                right_pos[j] = i
                i -= 1
            else:
                break
        
        left = 0
        while left < n and left_pos[left] != -1:
            left += 1
        
        right = n - 1
        while right >= 0 and right_pos[right] != -1:
            right -= 1
        
        if left > right:
            return 0
        
        min_score = right - left + 1
        
        i = 0
        j = right + 1
        while i < left and j < n:
            if left_pos[i] < right_pos[j]:
                min_score = min(min_score, j - i - 1)
                i += 1
            else:
                j += 1
        
        return min_score
```",Y,
minimum-number-of-visited-cells-in-a-grid,Minimum Number of Visited Cells in a Grid,"```python
import heapq
from typing import List

class Solution:
    def minimumVisitedCells(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        if m == 1 and n == 1:
            return 1
        
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = 1
        
        heap = []
        heapq.heappush(heap, (1, 0, 0))
        
        row_next = [list(range(n)) for _ in range(m)]
        col_next = [list(range(m)) for _ in range(n)]
        
        while heap:
            current_dist, i, j = heapq.heappop(heap)
            if i == m - 1 and j == n - 1:
                return current_dist
            if current_dist > dist[i][j]:
                continue
            
            max_k = min(n - 1, j + grid[i][j])
            k = row_next[i][j]
            while k <= max_k:
                if dist[i][k] > current_dist + 1:
                    dist[i][k] = current_dist + 1
                    heapq.heappush(heap, (dist[i][k], i, k))
                row_next[i][k] = max_k + 1
                k_next = row_next[i][k]
                if k_next > max_k:
                    break
                k = k_next
            
            max_k = min(m - 1, i + grid[i][j])
            k = col_next[j][i]
            while k <= max_k:
                if dist[k][j] > current_dist + 1:
                    dist[k][j] = current_dist + 1
                    heapq.heappush(heap, (dist[k][j], k, j))
                col_next[j][k] = max_k + 1
                k_next = col_next[j][k]
                if k_next > max_k:
                    break
                k = k_next
        
        return -1
```",Y,
rearranging-fruits,Rearranging Fruits,"```python
from collections import defaultdict
from typing import List

class Solution:
    def minCost(self, basket1: List[int], basket2: List[int]) -> int:
        count = defaultdict(int)
        for num in basket1:
            count[num] += 1
        for num in basket2:
            count[num] -= 1
        
        swaps = []
        for num in count:
            if count[num] % 2 != 0:
                return -1
            swaps.extend([num] * (abs(count[num]) // 2))
        
        min_val = min(min(basket1), min(basket2))
        swaps.sort()
        res = 0
        for i in range(len(swaps) // 2):
            res += min(swaps[i], 2 * min_val)
        
        return res
```",Y,
lexicographically-smallest-beautiful-string,Lexicographically Smallest Beautiful String,"```python
class Solution:
    def smallestBeautifulString(self, s: str, k: int) -> str:
        n = len(s)
        s = list(s)
        found = False
        
        for i in range(n - 1, -1, -1):
            for c in range(ord(s[i]) - ord('a') + 1, k):
                char = chr(c + ord('a'))
                if (i == 0 or char != s[i - 1]) and (i <= 1 or char != s[i - 2]):
                    s[i] = char
                    found = True
                    for j in range(i + 1, n):
                        for d in range(0, k):
                            char_j = chr(d + ord('a'))
                            if (j == 0 or char_j != s[j - 1]) and (j <= 1 or char_j != s[j - 2])):
                                s[j] = char_j
                                break
                    if found:
                        break
                if found:
                    break
            if found:
                break
        
        if not found:
            return """"
        
        return ''.join(s)
```",Y,
count-increasing-quadruplets,Count Increasing Quadruplets,"```python
class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        
        
        
        left_less = [[0] * n for _ in range(n)]
        right_greater = [[0] * n for _ in range(n)]
        
        for k in range(n):
            cnt = 0
            for j in range(n):
                if nums[j] < nums[k]:
                    cnt += 1
                left_less[k][j] = cnt
        
        for j in range(n):
            cnt = 0
            for k in range(n-1, -1, -1):
                if nums[k] > nums[j]:
                    cnt += 1
                right_greater[j][k] = cnt
        
        res = 0
        for j in range(n):
            for k in range(j+1, n):
                if nums[j] > nums[k]:
                    res += left_less[k][j] * right_greater[j][k]
        
        return res
```",Y,
put-marbles-in-bags,Put Marbles in Bags,"```python
class Solution:
    def putMarbles(self, weights: List[int], k: int) -> int:
        if k == 1 or k == len(weights):
            return 0
        
        n = len(weights)
        splits = []
        for i in range(n - 1):
            splits.append(weights[i] + weights[i + 1])
        
        splits.sort()
        min_sum = sum(splits[:k-1])
        max_sum = sum(splits[-(k-1):])
        
        return max_sum - min_sum
```",Y,
design-graph-with-shortest-path-calculator,Design Graph With Shortest Path Calculator,"```python
import heapq
from typing import List

class Graph:

    def __init__(self, n: int, edges: List[List[int]]):
        self.n = n
        self.graph = [[] for _ in range(n)]
        for edge in edges:
            from_node, to_node, cost = edge
            self.graph[from_node].append((to_node, cost))

    def addEdge(self, edge: List[int]) -> None:
        from_node, to_node, cost = edge
        self.graph[from_node].append((to_node, cost))

    def shortestPath(self, node1: int, node2: int) -> int:
        heap = []
        heapq.heappush(heap, (0, node1))
        visited = {}
        
        while heap:
            current_cost, current_node = heapq.heappop(heap)
            if current_node == node2:
                return current_cost
            if current_node in visited:
                continue
            visited[current_node] = current_cost
            for neighbor, cost in self.graph[current_node]:
                if neighbor not in visited:
                    heapq.heappush(heap, (current_cost + cost, neighbor))
        
        return -1
```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
shortest-cycle-in-a-graph,Shortest Cycle in a Graph,"```python
from collections import deque
from typing import List

class Solution:
    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        min_cycle = float('inf')
        
        for i in range(n):
            distances = [-1] * n
            parent = [-1] * n
            q = deque()
            q.append(i)
            distances[i] = 0
            
            while q:
                u = q.popleft()
                for v in graph[u]:
                    if distances[v] == -1:
                        distances[v] = distances[u] + 1
                        parent[v] = u
                        q.append(v)
                    elif parent[u] != v and parent[v] != u:
                        cycle_length = distances[u] + distances[v] + 1
                        if cycle_length < min_cycle:
                            min_cycle = cycle_length
        
        return min_cycle if min_cycle != float('inf') else -1
```",Y,
minimum-time-to-complete-all-tasks,Minimum Time to Complete All Tasks,"```python
class Solution:
    def findMinimumTime(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x: x[1])
        used = set()
        for start, end, duration in tasks:
            needed = duration
            for t in range(end, start - 1, -1):
                if t in used:
                    needed -= 1
                    if needed == 0:
                        break
            for t in range(end, start - 1, -1):
                if needed <= 0:
                    break
                if t not in used:
                    used.add(t)
                    needed -= 1
        return len(used)
```",Y,
count-number-of-possible-root-nodes,Count Number of Possible Root Nodes,"```python
from collections import defaultdict
from typing import List

class Solution:
    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:
        tree = defaultdict(list)
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        
        guess_set = set((u, v) for u, v in guesses)
        
        parent = {}
        stack = [(0, None)]
        correct = 0
        
        while stack:
            node, par = stack.pop()
            parent[node] = par
            if par is not None and (par, node) in guess_set:
                correct += 1
            for neighbor in tree[node]:
                if neighbor != par:
                    stack.append((neighbor, node))
        
        res = 0
        if correct >= k:
            res += 1
        
        stack = [(0, correct)]
        while stack:
            node, current_correct = stack.pop()
            for neighbor in tree[node]:
                if neighbor == parent[node]:
                    continue
                new_correct = current_correct
                if (node, neighbor) in guess_set:
                    new_correct -= 1
                if (neighbor, node) in guess_set:
                    new_correct += 1
                if new_correct >= k:
                    res += 1
                stack.append((neighbor, new_correct))
        
        return res
```",Y,
number-of-ways-to-earn-points,Number of Ways to Earn Points,"```python
class Solution:
    def waysToReachTarget(self, target: int, types: List[List[int]]) -> int:
        MOD = 10**9 + 7
        dp = [0] * (target + 1)
        dp[0] = 1
        
        for count, mark in types:
            for t in range(target, -1, -1):
                for k in range(1, count + 1):
                    if t - k * mark >= 0:
                        dp[t] = (dp[t] + dp[t - k * mark]) % MOD
        
        return dp[target]
```",Y,
split-the-array-to-make-coprime-products,Split the Array to Make Coprime Products,"```python
import math
from collections import defaultdict

class Solution:
    def findValidSplit(self, nums: List[int]) -> int:
        def get_prime_factors(x):
            factors = set()
            if x == 1:
                return factors
            while x % 2 == 0:
                factors.add(2)
                x = x // 2
            i = 3
            max_factor = math.sqrt(x) + 1
            while i <= max_factor:
                while x % i == 0:
                    factors.add(i)
                    x = x // i
                    max_factor = math.sqrt(x) + 1
                i += 2
            if x > 1:
                factors.add(x)
            return factors
        
        n = len(nums)
        if n == 1:
            return -1
        
        left_primes = defaultdict(int)
        right_primes = defaultdict(int)
        
        for num in nums:
            primes = get_prime_factors(num)
            for p in primes:
                right_primes[p] += 1
        
        current_primes = set()
        for i in range(n - 1):
            num = nums[i]
            primes = get_prime_factors(num)
            for p in primes:
                current_primes.add(p)
                right_primes[p] -= 1
                if right_primes[p] == 0:
                    del right_primes[p]
            
            valid = True
            for p in current_primes:
                if p in right_primes:
                    valid = False
                    break
            if valid:
                return i
        
        return -1
```",Y,
time-to-cross-a-bridge,Time to Cross a Bridge,"```python
import heapq

class Solution:
    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:
        left_waiting = []
        right_waiting = []
        for i in range(k):
            left, pick, right, put = time[i]
            heapq.heappush(left_waiting, (-(left + right), -i))
        
        left_working = []
        right_working = []
        
        current_time = 0
        remaining_boxes = n
        boxes_on_left = 0
        
        while remaining_boxes > 0 or boxes_on_left < n:
            while left_working and left_working[0][0] <= current_time:
                time_available, i = heapq.heappop(left_working)
                heapq.heappush(left_waiting, (-(time[i][0] + time[i][2]), -i))
            
            while right_working and right_working[0][0] <= current_time:
                time_available, i = heapq.heappop(right_working)
                heapq.heappush(right_waiting, (-(time[i][0] + time[i][2]), -i))
            
            if right_waiting:
                _, neg_i = heapq.heappop(right_waiting)
                i = -neg_i
                crossing_time = time[i][2]
                current_time += crossing_time
                put_time = time[i][3]
                heapq.heappush(left_working, (current_time + put_time, i))
                boxes_on_left += 1
            elif left_waiting and remaining_boxes > 0:
                _, neg_i = heapq.heappop(left_waiting)
                i = -neg_i
                crossing_time = time[i][0]
                current_time += crossing_time
                pick_time = time[i][1]
                heapq.heappush(right_working, (current_time + pick_time, i))
                remaining_boxes -= 1
            else:
                next_time = float('inf')
                if left_working:
                    next_time = min(next_time, left_working[0][0])
                if right_working:
                    next_time = min(next_time, right_working[0][0])
                if next_time != float('inf'):
                    current_time = next_time
        
        return current_time
```",Y,
check-if-point-is-reachable,Check if Point Is Reachable,"```python
class Solution:
    def isReachable(self, targetX: int, targetY: int) -> bool:
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a
        
        g = gcd(targetX, targetY)
        return (g & (g - 1)) == 0
```",Y,
minimum-cost-to-split-an-array,Minimum Cost to Split an Array,"```python
from typing import List

class Solution:
    def minCost(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        
        for i in range(1, n + 1):
            freq = {}
            trimmed_length = 0
            for j in range(i - 1, -1, -1):
                num = nums[j]
                if num in freq:
                    if freq[num] == 1:
                        trimmed_length += 2
                    else:
                        trimmed_length += 1
                freq[num] = freq.get(num, 0) + 1
                current_cost = dp[j] + k + trimmed_length
                if current_cost < dp[i]:
                    dp[i] = current_cost
        
        return dp[n]
```",Y,
difference-between-maximum-and-minimum-price-sum,Difference Between Maximum and Minimum Price Sum,"```python
from typing import List
import collections

class Solution:
    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:
        tree = collections.defaultdict(list)
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        
        res = 0
        
        def dfs(node, parent):
            nonlocal res
            max1 = price[node]
            max2 = 0
            for neighbor in tree[node]:
                if neighbor == parent:
                    continue
                cmax1, cmax2 = dfs(neighbor, node)
                res = max(res, max1 + cmax2, max2 + cmax1)
                max1 = max(max1, cmax1 + price[node])
                max2 = max(max2, cmax2 + price[node])
            return (max1, max2)
        
        dfs(0, -1)
        return res
```",Y,
maximize-the-minimum-powered-city,Maximize the Minimum Powered City,"```python
from typing import List

class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        n = len(stations)
        left = 0
        right = max(stations) + k
        res = 0
        
        def is_possible(target):
            nonlocal k
            diff = [0] * (n + 1)
            current = 0
            remaining = k
            for i in range(n):
                current += diff[i]
                total = stations[i] + current
                if total < target:
                    needed = target - total
                    if needed > remaining:
                        return False
                    remaining -= needed
                    current += needed
                    end = min(i + 2 * r + 1, n)
                    diff[end] -= needed
            return True
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                res = mid
                left = mid + 1
            else:
                right = mid - 1
        return res
```",Y,
count-anagrams,Count Anagrams,"```python
import math
from collections import defaultdict

class Solution:
    def countAnagrams(self, s: str) -> int:
        MOD = 10**9 + 7
        words = s.split()
        result = 1
        for word in words:
            freq = defaultdict(int)
            for c in word:
                freq[c] += 1
            denominator = 1
            for cnt in freq.values():
                denominator = (denominator * math.factorial(cnt)) % MOD
            numerator = math.factorial(len(word))
            result = (result * numerator * pow(denominator, MOD-2, MOD)) % MOD
        return result
```",Y,
number-of-great-partitions,Number of Great Partitions,"```python
class Solution:
    def countPartitions(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        total = sum(nums)
        if total < 2 * k:
            return 0
        
        dp = [0] * k
        dp[0] = 1
        for num in nums:
            for j in range(k - 1, num - 1, -1):
                dp[j] = (dp[j] + dp[j - num]) % MOD
        
        total_partitions = pow(2, len(nums), MOD)
        invalid_partitions = 2 * sum(dp) % MOD
        return (total_partitions - invalid_partitions) % MOD
```",Y,
cycle-length-queries-in-a-tree,Cycle Length Queries in a Tree,"```python
from typing import List

class Solution:
    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:
        res = []
        for a, b in queries:
            path_a = []
            path_b = []
            while a != b:
                if a > b:
                    path_a.append(a)
                    a = a // 2
                else:
                    path_b.append(b)
                    b = b // 2
            cycle_length = len(path_a) + len(path_b) + 1
            res.append(cycle_length)
        return res
```",Y,
add-edges-to-make-degrees-of-all-nodes-even,Add Edges to Make Degrees of All Nodes Even,"```python
from typing import List
from collections import defaultdict

class Solution:
    def isPossible(self, n: int, edges: List[List[int]]) -> bool:
        degree = defaultdict(int)
        edge_set = set()
        
        for u, v in edges:
            degree[u] += 1
            degree[v] += 1
            edge_set.add((min(u, v), max(u, v)))
        
        odd_nodes = [node for node in degree if degree[node] % 2 != 0]
        if len(odd_nodes) == 0:
            return True
        if len(odd_nodes) not in (2, 4):
            return False
        
        if len(odd_nodes) == 2:
            a, b = odd_nodes
            if (min(a, b), max(a, b)) not in edge_set:
                return True
            for c in range(1, n + 1):
                if c != a and c != b and (min(a, c), max(a, c)) not in edge_set and (min(b, c), max(b, c)) not in edge_set:
                    return True
            return False
        
        if len(odd_nodes) == 4:
            a, b, c, d = odd_nodes
            if ((min(a, b), max(a, b)) not in edge_set and (min(c, d), max(c, d)) not in edge_set) or \
               ((min(a, c), max(a, c)) not in edge_set and (min(b, d), max(b, d)) not in edge_set) or \
               ((min(a, d), max(a, d)) not in edge_set and (min(b, c), max(b, c)) not in edge_set):
                return True
            return False
        
        return False
```",Y,
minimum-total-cost-to-make-arrays-unequal,Minimum Total Cost to Make Arrays Unequal,"```python
from collections import defaultdict

class Solution:
    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        swap_indices = []
        freq = defaultdict(int)
        total_cost = 0
        max_freq_val = -1
        max_freq = 0
        
        for i in range(n):
            if nums1[i] == nums2[i]:
                swap_indices.append(i)
                val = nums1[i]
                freq[val] += 1
                if freq[val] > max_freq:
                    max_freq = freq[val]
                    max_freq_val = val
        
        if not swap_indices:
            return 0
        
        required = 2 * max_freq - len(swap_indices)
        if required <= 0:
            return sum(swap_indices)
        
        extra_needed = required
        for i in range(n):
            if nums1[i] != nums2[i] and nums1[i] != max_freq_val and nums2[i] != max_freq_val:
                swap_indices.append(i)
                extra_needed -= 1
                if extra_needed == 0:
                    break
        
        if extra_needed > 0:
            return -1
        
        return sum(swap_indices)
```",Y,
maximum-number-of-points-from-grid-queries,Maximum Number of Points From Grid Queries,"```python
import heapq
from typing import List

class Solution:
    def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:
        m, n = len(grid), len(grid[0])
        k = len(queries)
        queries_sorted = sorted((val, i) for i, val in enumerate(queries))
        answer = [0] * k
        
        heap = []
        heapq.heappush(heap, (grid[0][0], 0, 0))
        visited = [[False for _ in range(n)] for _ in range(m)]
        visited[0][0] = True
        count = 0
        
        for val, idx in queries_sorted:
            while heap and heap[0][0] < val:
                v, i, j = heapq.heappop(heap)
                count += 1
                for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj]:
                        visited[ni][nj] = True
                        heapq.heappush(heap, (grid[ni][nj], ni, nj))
            answer[idx] = count
        
        return answer
```",Y,
divide-nodes-into-the-maximum-number-of-groups,Divide Nodes Into the Maximum Number of Groups,"```python
from collections import deque
from typing import List

class Solution:
    def magnificentSets(self, n: int, edges: List[List[int]]) -> int:
        graph = [[] for _ in range(n + 1)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        visited = [0] * (n + 1)
        components = []
        
        for node in range(1, n + 1):
            if not visited[node]:
                queue = deque([node])
                visited[node] = 1
                component = []
                while queue:
                    current = queue.popleft()
                    component.append(current)
                    for neighbor in graph[current]:
                        if not visited[neighbor]:
                            visited[neighbor] = 1
                            queue.append(neighbor)
                components.append(component)
        
        max_groups = 0
        
        for component in components:
            current_max = 0
            for start in component:
                groups = {start: 1}
                queue = deque([start])
                valid = True
                while queue and valid:
                    current = queue.popleft()
                    for neighbor in graph[current]:
                        if neighbor not in groups:
                            groups[neighbor] = groups[current] + 1
                            queue.append(neighbor)
                        elif abs(groups[neighbor] - groups[current]) != 1:
                            valid = False
                            break
                    if not valid:
                        break
                if valid:
                    current_max = max(current_max, max(groups.values()))
            if current_max == 0:
                return -1
            max_groups += current_max
        
        return max_groups
```",Y,
count-palindromic-subsequences,Count Palindromic Subsequences,"```python
class Solution:
    def countPalindromes(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        if n < 5:
            return 0
        
        prefix = [[0] * 10 for _ in range(n+1)]
        for i in range(n):
            for d in range(10):
                prefix[i+1][d] = prefix[i][d]
            prefix[i+1][int(s[i])] += 1
        
        suffix = [[0] * 10 for _ in range(n+1)]
        for i in range(n-1, -1, -1):
            for d in range(10):
                suffix[i][d] = suffix[i+1][d]
            suffix[i][int(s[i])] += 1
        
        prefix_2 = [[[0] * 10 for _ in range(10)] for __ in range(n+1)]
        for i in range(n):
            current_d = int(s[i])
            for d1 in range(10):
                for d2 in range(10):
                    prefix_2[i+1][d1][d2] = prefix_2[i][d1][d2]
            for d in range(10):
                prefix_2[i+1][d][current_d] += prefix[i][d]
        
        suffix_2 = [[[0] * 10 for _ in range(10)] for __ in range(n+1)]
        for i in range(n-1, -1, -1):
            current_d = int(s[i])
            for d1 in range(10):
                for d2 in range(10):
                    suffix_2[i][d1][d2] = suffix_2[i+1][d1][d2]
            for d in range(10):
                suffix_2[i][current_d][d] += suffix[i+1][d]
        
        res = 0
        for i in range(2, n-2):
            for d1 in range(10):
                for d2 in range(10):
                    cnt_prefix = prefix_2[i][d1][d2]
                    cnt_suffix = suffix_2[i+1][d2][d1]
                    res = (res + cnt_prefix * cnt_suffix) % MOD
        return res
```",Y,
count-subarrays-with-median-k,Count Subarrays With Median K,"```python
from typing import List
from collections import defaultdict

class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        pos = nums.index(k)
        count = defaultdict(int)
        count[0] = 1
        res = 0
        balance = 0
        
        for i in range(pos + 1, len(nums)):
            balance += 1 if nums[i] > k else -1
            count[balance] += 1
        
        res += count[0] + count[1]
        balance = 0
        
        for i in range(pos - 1, -1, -1):
            balance += 1 if nums[i] < k else -1
            res += count[balance] + count[balance + 1]
        
        return res
```",Y,
number-of-beautiful-partitions,Number of Beautiful Partitions,"```python
class Solution:
    def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:
        MOD = 10**9 + 7
        primes = {'2', '3', '5', '7'}
        n = len(s)
        if k * minLength > n or s[0] not in primes or s[-1] in primes:
            return 0
        
        dp = [[0] * (n + 1) for _ in range(k + 1)]
        dp[0][0] = 1
        
        for parts in range(1, k + 1):
            total = 0
            for end in range(1, n + 1):
                if end >= minLength:
                    start = end - minLength
                    if start >= 0 and s[start] in primes and (end == n or s[end] not in primes):
                        total += dp[parts - 1][start]
                        total %= MOD
                dp[parts][end] = total
        
        return dp[k][n]
```",Y,
split-message-based-on-limit,Split Message Based on Limit,"```python
from typing import List

class Solution:
    def splitMessage(self, message: str, limit: int) -> List[str]:
        n = len(message)
        parts = 0
        low, high = 1, n
        found = False
        while low <= high:
            mid = (low + high) // 2
            total = 0
            ok = True
            a_digits = 1
            b_digits = len(str(mid))
            pos = 0
            for a in range(1, mid + 1):
                if a >= 10 ** a_digits:
                    a_digits += 1
                suffix_len = 3 + a_digits + b_digits  # <a/b> is 3 + digits of a + digits of b
                if suffix_len >= limit:
                    ok = False
                    break
                chunk_len = limit - suffix_len
                total += chunk_len
                if total > n:
                    break
            if ok and total >= n:
                found = True
                parts = mid
                high = mid - 1
            else:
                low = mid + 1
        if not found:
            return []
        
        res = []
        pos = 0
        b_digits = len(str(parts))
        a_digits = 1
        for a in range(1, parts + 1):
            if a >= 10 ** a_digits:
                a_digits += 1
            suffix_len = 3 + a_digits + b_digits
            chunk_len = limit - suffix_len
            chunk = message[pos: pos + chunk_len]
            pos += chunk_len
            part = f""{chunk}<{a}/{parts}>""
            res.append(part)
        return res
```",Y,
maximum-number-of-non-overlapping-palindrome-substrings,Maximum Number of Non-overlapping Palindrome Substrings,"```python
class Solution:
    def maxPalindromes(self, s: str, k: int) -> int:
        n = len(s)
        dp = [0] * (n + 1)
        
        for i in range(n):
            dp[i+1] = dp[i]
            l, r = i, i
            while l >= 0 and r < n and s[l] == s[r]:
                if r - l + 1 >= k:
                    dp[r+1] = max(dp[r+1], dp[l] + 1)
                    break
                l -= 1
                r += 1
            l, r = i, i+1
            while l >= 0 and r < n and s[l] == s[r]:
                if r - l + 1 >= k:
                    dp[r+1] = max(dp[r+1], dp[l] + 1)
                    break
                l -= 1
                r += 1
        
        return dp[n]
```",Y,
minimum-total-distance-traveled,Minimum Total Distance Traveled,"```python
class Solution:
    def minimumTotalDistance(self, robot: List[int], factory: List[List[int]]) -> int:
        robot.sort()
        factory.sort()
        m, n = len(robot), len(factory)
        
        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = 0
        
        for j in range(1, n + 1):
            pos, limit = factory[j - 1]
            for i in range(m + 1):
                if dp[i][j - 1] == float('inf'):
                    continue
                dp[i][j] = min(dp[i][j], dp[i][j - 1])
                cost = 0
                max_repair = min(limit, m - i)
                for k in range(1, max_repair + 1):
                    cost += abs(robot[i + k - 1] - pos)
                    if dp[i][j - 1] + cost < dp[i + k][j]:
                        dp[i + k][j] = dp[i][j - 1] + cost
        
        return dp[m][n]
```",Y,
next-greater-element-iv,Next Greater Element IV,"```python
class Solution:
    def secondGreaterElement(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [-1] * n
        s1 = []
        s2 = []
        temp = []
        
        for i in range(n):
            while s2 and nums[s2[-1]] < nums[i]:
                res[s2.pop()] = nums[i]
            while s1 and nums[s1[-1]] < nums[i]:
                temp.append(s1.pop())
            while temp:
                s2.append(temp.pop())
            s1.append(i)
        
        return res
```",Y,
height-of-binary-tree-after-subtree-removal-queries,Height of Binary Tree After Subtree Removal Queries,"```python
class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:
        from collections import defaultdict

        depth = defaultdict(int)
        height = defaultdict(int)
        ancestors = defaultdict(list)
        node_map = {}

        stack = [(root, 0, [])]
        while stack:
            node, d, path = stack.pop()
            if not node:
                continue
            depth[node.val] = d
            node_map[node.val] = node
            ancestors[node.val] = path.copy()
            stack.append((node.right, d + 1, path + [node.val]))
            stack.append((node.left, d + 1, path + [node.val]))

        stack = [(root, False)]
        while stack:
            node, visited = stack.pop()
            if not node:
                continue
            if visited:
                left_height = height[node.left.val] if node.left else -1
                right_height = height[node.right.val] if node.right else -1
                height[node.val] = 1 + max(left_height, right_height)
            else:
                stack.append((node, True))
                stack.append((node.right, False))
                stack.append((node.left, False))

        max_heights = defaultdict(dict)
        for node_val in node_map:
            path = ancestors[node_val]
            for i, ancestor_val in enumerate(path):
                sibling = None
                ancestor_node = node_map[ancestor_val]
                if i < len(path) - 1:
                    next_val = path[i+1]
                    if ancestor_node.left and ancestor_node.left.val == next_val:
                        sibling = ancestor_node.right
                    else:
                        sibling = ancestor_node.left
                else:
                    if ancestor_node.left and ancestor_node.left.val == node_val:
                        sibling = ancestor_node.right
                    else:
                        sibling = ancestor_node.left
                sibling_height = height[sibling.val] if sibling else -1
                current_max = depth[ancestor_val] + sibling_height
                if i == 0:
                    max_heights[node_val][ancestor_val] = current_max
                else:
                    parent_val = path[i-1]
                    max_heights[node_val][ancestor_val] = max(current_max, max_heights[node_val][parent_val])

        res = []
        for q in queries:
            path = ancestors[q]
            if not path:
                res.append(-1)
                continue
            max_h = -1
            for ancestor_val in path:
                if ancestor_val in max_heights[q]:
                    max_h = max(max_h, max_heights[q][ancestor_val])
            res.append(max_h)
        return res
```",Y,
minimum-number-of-operations-to-make-arrays-similar,Minimum Number of Operations to Make Arrays Similar,"```python
class Solution:
    def makeSimilar(self, nums: List[int], target: List[int]) -> int:
        nums_odd = sorted([x for x in nums if x % 2 == 1])
        nums_even = sorted([x for x in nums if x % 2 == 0])
        target_odd = sorted([x for x in target if x % 2 == 1])
        target_even = sorted([x for x in target if x % 2 == 0])
        
        res = 0
        for a, b in zip(nums_odd, target_odd):
            if a > b:
                res += (a - b) // 2
        for a, b in zip(nums_even, target_even):
            if a > b:
                res += (a - b) // 2
        return res
```",Y,
minimum-cost-to-make-array-equal,Minimum Cost to Make Array Equal,"```python
class Solution:
    def minCost(self, nums: List[int], cost: List[int]) -> int:
        num_cost = sorted(zip(nums, cost))
        total_cost = sum(cost)
        median_cost = total_cost // 2
        cumulative_cost = 0
        target = 0
        
        for num, c in num_cost:
            cumulative_cost += c
            if cumulative_cost > median_cost:
                target = num
                break
        
        min_total_cost = 0
        for num, c in num_cost:
            min_total_cost += abs(num - target) * c
        
        return min_total_cost
```",Y,
create-components-with-same-value,Create Components With Same Value,"```python
from typing import List

class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        total = sum(nums)
        n = len(nums)
        if n == 1:
            return 0
        
        adj = [[] for _ in range(n)]
        for a, b in edges:
            adj[a].append(b)
            adj[b].append(a)
        
        max_k = 0
        
        for target in range(1, total):
            if total % target != 0:
                continue
            stack = [(0, -1)]
            valid = True
            temp = nums.copy()
            parent = [-1] * n
            order = []
            while stack:
                node, p = stack.pop()
                parent[node] = p
                order.append(node)
                for neighbor in adj[node]:
                    if neighbor != p:
                        stack.append((neighbor, node))
            for node in reversed(order):
                if parent[node] != -1 and temp[node] != target:
                    temp[parent[node]] += temp[node]
                    if temp[parent[node]] > target:
                        valid = False
                        break
            if valid and temp[0] == target:
                max_k = max(max_k, total // target - 1)
        
        return max_k
```",Y,
count-subarrays-with-fixed-bounds,Count Subarrays With Fixed Bounds,"```python
from typing import List

class Solution:
    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -> int:
        res = 0
        min_pos = -1
        max_pos = -1
        left_bound = -1
        
        for i, num in enumerate(nums):
            if num < minK or num > maxK:
                left_bound = i
                min_pos = -1
                max_pos = -1
                continue
            
            if num == minK:
                min_pos = i
            if num == maxK:
                max_pos = i
            
            if min_pos != -1 and max_pos != -1:
                res += min(min_pos, max_pos) - left_bound
        
        return res
```",Y,
longest-increasing-subsequence-ii,Longest Increasing Subsequence II,"```python
import bisect

class Solution:
    def lengthOfLIS(self, nums: List[int], k: int) -> int:
        tails = []
        for num in nums:
            idx = bisect.bisect_left(tails, num)
            if idx == 0:
                if not tails or num <= tails[0]:
                    if not tails:
                        tails.append(num)
                    else:
                        tails[0] = num
            else:
                left = bisect.bisect_left(tails, num - k)
                if left < idx:
                    if idx < len(tails):
                        tails[idx] = min(tails[idx], num)
                    else:
                        tails.append(num)
        return len(tails)
```",Y,
paths-in-matrix-whose-sum-is-divisible-by-k,Paths in Matrix Whose Sum Is Divisible by K,"```python
class Solution:
    def numberOfPaths(self, grid: List[List[int]], k: int) -> int:
        m, n = len(grid), len(grid[0])
        MOD = 10**9 + 7
        
        dp = [[[0] * k for _ in range(n)] for __ in range(m)]
        dp[0][0][grid[0][0] % k] = 1
        
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    continue
                current_val = grid[i][j]
                for rem in range(k):
                    new_rem = (rem + current_val) % k
                    if i > 0:
                        dp[i][j][new_rem] += dp[i-1][j][rem]
                    if j > 0:
                        dp[i][j][new_rem] += dp[i][j-1][rem]
                    dp[i][j][new_rem] %= MOD
        
        return dp[m-1][n-1][0]
```",Y,
number-of-pairs-satisfying-inequality,Number of Pairs Satisfying Inequality,"```python
import bisect

class Solution:
    def numberOfPairs(self, nums1: List[int], nums2: List[int], diff: int) -> int:
        n = len(nums1)
        arr = [nums1[i] - nums2[i] for i in range(n)]
        sorted_list = []
        res = 0
        
        for num in arr:
            target = num + diff
            count = bisect.bisect_right(sorted_list, target)
            res += count
            bisect.insort(sorted_list, num)
        
        return res
```",Y,
maximum-deletions-on-a-string,Maximum Deletions on a String,"```python
class Solution:
    def deleteString(self, s: str) -> int:
        n = len(s)
        dp = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            dp[i] = 1
            max_len = (n - i) // 2
            for l in range(1, max_len + 1):
                if s[i:i+l] == s[i+l:i+2*l]:
                    dp[i] = max(dp[i], 1 + dp[i + l])
        return dp[0]
```",Y,
number-of-good-paths,Number of Good Paths,"```python
from typing import List
from collections import defaultdict

class Solution:
    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:
        n = len(vals)
        parent = list(range(n))
        count = [1] * n
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            root_u = find(u)
            root_v = find(v)
            if root_u != root_v:
                if vals[root_u] > vals[root_v]:
                    parent[root_v] = root_u
                elif vals[root_u] < vals[root_v]:
                    parent[root_u] = root_v
                else:
                    parent[root_v] = root_u
                    count[root_u] += count[root_v]
        
        adj = defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        
        nodes = sorted(range(n), key=lambda x: vals[x])
        
        res = 0
        i = 0
        while i < n:
            j = i
            while j < n and vals[nodes[j]] == vals[nodes[i]]:
                j += 1
            for k in range(i, j):
                u = nodes[k]
                for v in adj[u]:
                    if vals[v] <= vals[u]:
                        union(u, v)
            freq = defaultdict(int)
            for k in range(i, j):
                root = find(nodes[k])
                freq[root] += 1
            for cnt in freq.values():
                res += cnt * (cnt + 1) // 2
            i = j
        return res
```",Y,
minimum-money-required-before-transactions,Minimum Money Required Before Transactions,"```python
from typing import List

class Solution:
    def minimumMoney(self, transactions: List[List[int]]) -> int:
        total_loss = 0
        max_cashback = 0
        max_cost = 0
        
        for cost, cashback in transactions:
            if cost > cashback:
                total_loss += cost - cashback
                max_cashback = max(max_cashback, cashback)
            else:
                max_cost = max(max_cost, cost)
        
        return total_loss + max(max_cashback, max_cost)
```",Y,
sum-of-prefix-scores-of-strings,Sum of Prefix Scores of Strings,"```python
class Solution:
    def sumPrefixScores(self, words: List[str]) -> List[int]:
        prefix_counts = {}
        
        for word in words:
            for i in range(1, len(word)+1):
                prefix = word[:i]
                prefix_counts[prefix] = prefix_counts.get(prefix, 0) + 1
        
        answer = []
        for word in words:
            total = 0
            for i in range(1, len(word)+1):
                prefix = word[:i]
                total += prefix_counts[prefix]
            answer.append(total)
        
        return answer
```",Y,
meeting-rooms-iii,Meeting Rooms III,"```python
import heapq

class Solution:
    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
        meetings.sort()
        available = list(range(n))
        used = []
        count = [0] * n
        
        for start, end in meetings:
            while used and used[0][0] <= start:
                time, room = heapq.heappop(used)
                heapq.heappush(available, room)
            
            if available:
                room = heapq.heappop(available)
                heapq.heappush(used, (end, room))
            else:
                time, room = heapq.heappop(used)
                new_end = time + (end - start)
                heapq.heappush(used, (new_end, room))
            
            count[room] += 1
        
        max_count = max(count)
        return count.index(max_count)
```",Y,
build-a-matrix-with-conditions,Build a Matrix With Conditions,"```python
from collections import deque

class Solution:
    def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:
        def topological_sort(conditions, k):
            graph = [[] for _ in range(k+1)]
            in_degree = [0] * (k+1)
            
            for u, v in conditions:
                graph[u].append(v)
                in_degree[v] += 1
            
            queue = deque()
            for i in range(1, k+1):
                if in_degree[i] == 0:
                    queue.append(i)
            
            order = []
            while queue:
                u = queue.popleft()
                order.append(u)
                for v in graph[u]:
                    in_degree[v] -= 1
                    if in_degree[v] == 0:
                        queue.append(v)
            
            if len(order) != k:
                return None
            return order
        
        row_order = topological_sort(rowConditions, k)
        col_order = topological_sort(colConditions, k)
        
        if not row_order or not col_order:
            return []
        
        row_pos = {num: i for i, num in enumerate(row_order)}
        col_pos = {num: i for i, num in enumerate(col_order)}
        
        matrix = [[0] * k for _ in range(k)]
        for num in range(1, k+1):
            matrix[row_pos[num]][col_pos[num]] = num
        
        return matrix
```",Y,
maximum-segment-sum-after-removals,Maximum Segment Sum After Removals,"```python
from typing import List
import heapq

class Solution:
    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:
        n = len(nums)
        parent = [i for i in range(n)]
        sum_seg = [0] * n
        max_heap = []
        res = [0] * n
        removed = [False] * n
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            root_u = find(u)
            root_v = find(v)
            if root_u == root_v:
                return
            if root_u < root_v:
                parent[root_v] = root_u
                sum_seg[root_u] += sum_seg[root_v]
                heapq.heappush(max_heap, -sum_seg[root_u])
            else:
                parent[root_u] = root_v
                sum_seg[root_v] += sum_seg[root_u]
                heapq.heappush(max_heap, -sum_seg[root_v])
        
        for i in range(n-1, -1, -1):
            pos = removeQueries[i]
            sum_seg[pos] = nums[pos]
            heapq.heappush(max_heap, -sum_seg[pos])
            removed[pos] = True
            if pos > 0 and removed[pos-1]:
                union(pos, pos-1)
            if pos < n-1 and removed[pos+1]:
                union(pos, pos+1)
            current_max = 0
            while max_heap:
                current_candidate = -max_heap[0]
                root = find(removeQueries[heapq.nlargest(1, range(n), key=lambda x: -max_heap[x])[0]])
                if sum_seg[root] == current_candidate:
                    current_max = current_candidate
                    break
                else:
                    heapq.heappop(max_heap)
            res[i] = current_max
        return res
```",Y,
find-the-k-sum-of-an-array,Find the K-Sum of an Array,"```python
import heapq
from typing import List

class Solution:
    def kSum(self, nums: List[int], k: int) -> int:
        max_sum = sum(num for num in nums if num > 0)
        abs_nums = sorted(abs(num) for num in nums)
        max_heap = [(-max_sum, 0)]
        result = max_sum
        
        for _ in range(k - 1):
            current_sum, i = heapq.heappop(max_heap)
            current_sum = -current_sum
            result = current_sum
            
            if i < len(abs_nums):
                heapq.heappush(max_heap, (-(current_sum - abs_nums[i]), i + 1))
                if i > 0:
                    heapq.heappush(max_heap, (-(current_sum - abs_nums[i] + abs_nums[i - 1]), i + 1))
        
        return result
```",Y,
count-special-integers,Count Special Integers,"```python
class Solution:
    def countSpecialNumbers(self, n: int) -> int:
        s = str(n)
        length = len(s)
        used = [False] * 10
        total = 0

        for l in range(1, length):
            count = 9
            choices = 9
            for _ in range(1, l):
                count *= choices
                choices -= 1
            total += count

        for i in range(length):
            digit = int(s[i])
            start = 1 if i == 0 else 0
            for d in range(start, digit):
                if not used[d]:
                    remaining_positions = length - i - 1
                    choices = 9 - i
                    count = 1
                    for _ in range(remaining_positions):
                        count *= choices
                        choices -= 1
                    total += count
            if used[digit]:
                break
            used[digit] = True
        else:
            total += 1

        return total
```",Y,
minimum-replacements-to-sort-the-array,Minimum Replacements to Sort the Array,"```python
class Solution:
    def minimumReplacement(self, nums: List[int]) -> int:
        operations = 0
        n = len(nums)
        prev = nums[-1]
        
        for i in range(n - 2, -1, -1):
            if nums[i] > prev:
                parts = (nums[i] + prev - 1) // prev
                operations += parts - 1
                prev = nums[i] // parts
            else:
                prev = nums[i]
        
        return operations
```",Y,
maximum-number-of-robots-within-budget,Maximum Number of Robots Within Budget,"```python
from collections import deque

class Solution:
    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:
        n = len(chargeTimes)
        left = 0
        current_sum = 0
        max_deque = deque()
        max_k = 0
        
        for right in range(n):
            current_sum += runningCosts[right]
            
            while max_deque and chargeTimes[right] >= chargeTimes[max_deque[-1]]:
                max_deque.pop()
            max_deque.append(right)
            
            while left <= right and (chargeTimes[max_deque[0]] + (right - left + 1) * current_sum) > budget:
                current_sum -= runningCosts[left]
                if max_deque[0] == left:
                    max_deque.popleft()
                left += 1
            
            max_k = max(max_k, right - left + 1)
        
        return max_k
```",Y,
longest-cycle-in-a-graph,Longest Cycle in a Graph,"```python
class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n = len(edges)
        visited = [False] * n
        max_cycle = -1
        
        for i in range(n):
            if not visited[i]:
                cycle = {}
                current = i
                pos = 0
                while current != -1:
                    if current in cycle:
                        max_cycle = max(max_cycle, pos - cycle[current])
                        break
                    if visited[current]:
                        break
                    visited[current] = True
                    cycle[current] = pos
                    pos += 1
                    current = edges[current]
        return max_cycle if max_cycle != 0 else -1
```",Y,
shortest-impossible-sequence-of-rolls,Shortest Impossible Sequence of Rolls,"```python
from typing import List

class Solution:
    def shortestSequence(self, rolls: List[int], k: int) -> int:
        res = 1
        seen = set()
        for num in rolls:
            seen.add(num)
            if len(seen) == k:
                res += 1
                seen = set()
        return res
```",Y,
number-of-excellent-pairs,Number of Excellent Pairs,"```python
from typing import List

class Solution:
    def countExcellentPairs(self, nums: List[int], k: int) -> int:
        unique_nums = list(set(nums))
        bit_counts = []
        for num in unique_nums:
            bit_counts.append(bin(num).count('1'))
        
        bit_counts.sort()
        n = len(bit_counts)
        res = 0
        
        left = 0
        right = n - 1
        while left < n and right >= 0:
            if bit_counts[left] + bit_counts[right] >= k:
                res += n - left
                right -= 1
            else:
                left += 1
        return res
```",Y,
minimum-deletions-to-make-array-divisible,Minimum Deletions to Make Array Divisible,"```python
import math
from typing import List

class Solution:
    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:
        overall_gcd = numsDivide[0]
        for num in numsDivide[1:]:
            overall_gcd = math.gcd(overall_gcd, num)
            if overall_gcd == 1:
                break
        
        nums.sort()
        for i, num in enumerate(nums):
            if overall_gcd % num == 0:
                return i
        return -1
```",Y,
subarray-with-elements-greater-than-varying-threshold,Subarray With Elements Greater Than Varying Threshold,"```python
class Solution:
    def validSubarraySize(self, nums: List[int], threshold: int) -> int:
        n = len(nums)
        left = [-1] * n
        right = [n] * n
        stack = []
        
        for i in range(n):
            while stack and nums[stack[-1]] >= nums[i]:
                stack.pop()
            if stack:
                left[i] = stack[-1]
            stack.append(i)
        
        stack = []
        for i in range(n-1, -1, -1):
            while stack and nums[stack[-1]] >= nums[i]:
                stack.pop()
            if stack:
                right[i] = stack[-1]
            stack.append(i)
        
        for i in range(n):
            k = right[i] - left[i] - 1
            if nums[i] > threshold / k:
                return k
        
        return -1
```",Y,
count-the-number-of-ideal-arrays,Count the Number of Ideal Arrays,"```python
import math

class Solution:
    def idealArrays(self, n: int, maxValue: int) -> int:
        MOD = 10**9 + 7
        
        divisors = [[] for _ in range(maxValue + 1)]
        for i in range(1, maxValue + 1):
            for j in range(2 * i, maxValue + 1, i):
                divisors[j].append(i)
        
        max_k = 20  # Since maxValue can be 1e4, log2(1e4) ~ 13.29
        comb = [[0] * (max_k + 1) for _ in range(n + 1)]
        comb[0][0] = 1
        for i in range(1, n + 1):
            comb[i][0] = 1
            for j in range(1, max_k + 1):
                comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD
        
        dp_k = [{} for _ in range(maxValue + 1)]
        for v in range(1, maxValue + 1):
            dp_k[v][1] = 1
        
        for v in range(1, maxValue + 1):
            for u in divisors[v]:
                for k in dp_k[u]:
                    new_k = k + 1
                    if new_k in dp_k[v]:
                        dp_k[v][new_k] = (dp_k[v][new_k] + dp_k[u][k]) % MOD
                    else:
                        dp_k[v][new_k] = dp_k[u][k] % MOD
        
        res = 0
        for v in range(1, maxValue + 1):
            for k in dp_k[v]:
                res = (res + dp_k[v][k] * comb[n-1][k-1]) % MOD
        
        return res
```",Y,
number-of-increasing-paths-in-a-grid,Number of Increasing Paths in a Grid,"```python
class Solution:
    def countPaths(self, grid: List[List[int]]) -> int:
        MOD = 10**9 + 7
        m, n = len(grid), len(grid[0])
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        dp = [[1] * n for _ in range(m)]
        cells = [(i, j) for i in range(m) for j in range(n)]
        cells.sort(key=lambda x: grid[x[0]][x[1]])
        
        for i, j in cells:
            for di, dj in directions:
                ni, nj = i + di, j + dj
                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] > grid[i][j]:
                    dp[ni][nj] = (dp[ni][nj] + dp[i][j]) % MOD
        
        return sum(sum(row) % MOD for row in dp) % MOD
```",Y,
number-of-distinct-roll-sequences,Number of Distinct Roll Sequences,"```python
import math

class Solution:
    def distinctSequences(self, n: int) -> int:
        if n == 1:
            return 6
        MOD = 10**9 + 7
        
        gcd_pairs = [[False]*7 for _ in range(7)]
        for a in range(1, 7):
            for b in range(1, 7):
                gcd_pairs[a][b] = (math.gcd(a, b) == 1)
        
        dp = [[[0]*7 for _ in range(7)] for __ in range(n+1)]
        
        for a in range(1, 7):
            for b in range(1, 7):
                if a != b and gcd_pairs[a][b]:
                    dp[2][a][b] = 1
        
        for i in range(3, n+1):
            for a in range(1, 7):
                for b in range(1, 7):
                    if a == b or not gcd_pairs[a][b]:
                        continue
                    total = 0
                    for c in range(1, 7):
                        if c == a or not gcd_pairs[b][c]:
                            continue
                        total += dp[i-1][b][c]
                    dp[i][a][b] = total % MOD
        
        result = 0
        for a in range(1, 7):
            for b in range(1, 7):
                result = (result + dp[n][a][b]) % MOD
        return result
```",Y,
minimum-score-after-removals-on-a-tree,Minimum Score After Removals on a Tree,"```python
from typing import List

class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        adj = [[] for _ in range(n)]
        for a, b in edges:
            adj[a].append(b)
            adj[b].append(a)
        
        xor = [0] * n
        parent = [0] * n
        in_time = [0] * n
        out_time = [0] * n
        time = 0
        
        stack = [(0, -1, False)]
        
        while stack:
            node, p, visited = stack.pop()
            if not visited:
                parent[node] = p
                in_time[node] = time
                time += 1
                stack.append((node, p, True))
                for neighbor in adj[node]:
                    if neighbor != p:
                        stack.append((neighbor, node, False))
            else:
                xor[node] = nums[node]
                for neighbor in adj[node]:
                    if neighbor != p:
                        xor[node] ^= xor[neighbor]
                out_time[node] = time - 1
        
        total_xor = xor[0]
        min_score = float('inf')
        
        for i in range(1, n):
            for j in range(i + 1, n):
                if in_time[i] < in_time[j] <= out_time[i]:
                    x = xor[j]
                    y = xor[i] ^ xor[j]
                    z = total_xor ^ xor[i]
                elif in_time[j] < in_time[i] <= out_time[j]:
                    x = xor[i]
                    y = xor[j] ^ xor[i]
                    z = total_xor ^ xor[j]
                else:
                    x = xor[i]
                    y = xor[j]
                    z = total_xor ^ x ^ y
                current_max = max(x, y, z)
                current_min = min(x, y, z)
                min_score = min(min_score, current_max - current_min)
        
        return min_score
```",Y,
count-subarrays-with-score-less-than-k,Count Subarrays With Score Less Than K,"```python
class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        left = 0
        current_sum = 0
        result = 0
        
        for right in range(len(nums)):
            current_sum += nums[right]
            
            while current_sum * (right - left + 1) >= k and left <= right:
                current_sum -= nums[left]
                left += 1
            
            result += right - left + 1
        
        return result
```",Y,
match-substring-after-replacement,Match Substring After Replacement,"```python
from typing import List

class Solution:
    def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:
        from collections import defaultdict
        
        replace_map = defaultdict(set)
        for old, new in mappings:
            replace_map[old].add(new)
        
        len_sub = len(sub)
        len_s = len(s)
        
        for i in range(len_s - len_sub + 1):
            window = s[i:i+len_sub]
            match = True
            for j in range(len_sub):
                original_char = sub[j]
                window_char = window[j]
                if original_char == window_char:
                    continue
                if window_char in replace_map.get(original_char, set()):
                    continue
                match = False
                break
            if match:
                return True
        return False
```",Y,
naming-a-company,Naming a Company,"```python
from collections import defaultdict
from typing import List

class Solution:
    def distinctNames(self, ideas: List[str]) -> int:
        initial_groups = defaultdict(set)
        for idea in ideas:
            initial = idea[0]
            suffix = idea[1:]
            initial_groups[initial].add(suffix)
        
        initials = list(initial_groups.keys())
        res = 0
        n = len(initials)
        
        for i in range(n):
            set1 = initial_groups[initials[i]]
            for j in range(i + 1, n):
                set2 = initial_groups[initials[j]]
                common = len(set1 & set2)
                res += 2 * (len(set1) - common) * (len(set2) - common)
        
        return res
```",Y,
design-a-text-editor,Design a Text Editor,"```python
class TextEditor:

    def __init__(self):
        self.left = []
        self.right = []

    def addText(self, text: str) -> None:
        for c in text:
            self.left.append(c)

    def deleteText(self, k: int) -> int:
        deleted = 0
        while k > 0 and self.left:
            self.left.pop()
            deleted += 1
            k -= 1
        return deleted

    def cursorLeft(self, k: int) -> str:
        while k > 0 and self.left:
            self.right.append(self.left.pop())
            k -= 1
        return ''.join(self.left[-10:])

    def cursorRight(self, k: int) -> str:
        while k > 0 and self.right:
            self.left.append(self.right.pop())
            k -= 1
        return ''.join(self.left[-10:])
```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
booking-concert-tickets-in-groups,Booking Concert Tickets in Groups,"```python
import bisect

class BookMyShow:

    def __init__(self, n: int, m: int):
        self.n = n
        self.m = m
        self.min_row = 0
        self.rows = [0] * n  # tracks the next available seat in each row
        self.seg_tree = [0] * (4 * n)  # segment tree for max remaining seats in a range
        self.sum_tree = [0] * (4 * n)  # segment tree for sum of remaining seats in a range
        
        def build(node, l, r):
            if l == r:
                self.seg_tree[node] = self.m
                self.sum_tree[node] = self.m
                return
            mid = (l + r) // 2
            build(2 * node + 1, l, mid)
            build(2 * node + 2, mid + 1, r)
            self.seg_tree[node] = max(self.seg_tree[2 * node + 1], self.seg_tree[2 * node + 2])
            self.sum_tree[node] = self.sum_tree[2 * node + 1] + self.sum_tree[2 * node + 2]
        
        build(0, 0, n - 1)

    def gather(self, k: int, maxRow: int) -> List[int]:
        def query_max(node, l, r, max_row, val):
            if l > max_row or self.seg_tree[node] < val:
                return -1
            if l == r:
                return l
            mid = (l + r) // 2
            left = query_max(2 * node + 1, l, mid, max_row, val)
            if left != -1:
                return left
            return query_max(2 * node + 2, mid + 1, r, max_row, val)
        
        row = query_max(0, 0, self.n - 1, maxRow, k)
        if row == -1:
            return []
        seat = self.rows[row]
        self.rows[row] += k
        
        def update_seg(node, l, r, pos):
            if l == r:
                self.seg_tree[node] = self.m - self.rows[pos]
                self.sum_tree[node] = self.m - self.rows[pos]
                return
            mid = (l + r) // 2
            if pos <= mid:
                update_seg(2 * node + 1, l, mid, pos)
            else:
                update_seg(2 * node + 2, mid + 1, r, pos)
            self.seg_tree[node] = max(self.seg_tree[2 * node + 1], self.seg_tree[2 * node + 2])
            self.sum_tree[node] = self.sum_tree[2 * node + 1] + self.sum_tree[2 * node + 2]
        
        update_seg(0, 0, self.n - 1, row)
        return [row, seat]

    def scatter(self, k: int, maxRow: int) -> bool:
        def query_sum(node, l, r, max_row):
            if l > max_row:
                return 0
            if r <= max_row:
                return self.sum_tree[node]
            mid = (l + r) // 2
            return query_sum(2 * node + 1, l, mid, max_row) + query_sum(2 * node + 2, mid + 1, r, max_row)
        
        total = query_sum(0, 0, self.n - 1, maxRow)
        if total < k:
            return False
        
        remaining = k
        while remaining > 0 and self.min_row <= maxRow:
            row = self.min_row
            available = self.m - self.rows[row]
            take = min(available, remaining)
            self.rows[row] += take
            remaining -= take
            if self.rows[row] == self.m:
                self.min_row += 1
            
            def update_seg(node, l, r, pos):
                if l == r:
                    self.seg_tree[node] = self.m - self.rows[pos]
                    self.sum_tree[node] = self.m - self.rows[pos]
                    return
                mid = (l + r) // 2
                if pos <= mid:
                    update_seg(2 * node + 1, l, mid, pos)
                else:
                    update_seg(2 * node + 2, mid + 1, r, pos)
                self.seg_tree[node] = max(self.seg_tree[2 * node + 1], self.seg_tree[2 * node + 2])
                self.sum_tree[node] = self.sum_tree[2 * node + 1] + self.sum_tree[2 * node + 2]
            
            update_seg(0, 0, self.n - 1, row)
        return True
```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
minimum-obstacle-removal-to-reach-corner,Minimum Obstacle Removal to Reach Corner,"```python
import heapq
from typing import List

class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        heap = []
        heapq.heappush(heap, (0, 0, 0))
        
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = 0
        
        while heap:
            current_cost, x, y = heapq.heappop(heap)
            if x == m - 1 and y == n - 1:
                return current_cost
            if current_cost > dist[x][y]:
                continue
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n:
                    new_cost = current_cost + grid[nx][ny]
                    if new_cost < dist[nx][ny]:
                        dist[nx][ny] = new_cost
                        heapq.heappush(heap, (new_cost, nx, ny))
        return -1
```",Y,
sum-of-total-strength-of-wizards,Sum of Total Strength of Wizards,"```python
class Solution:
    def totalStrength(self, strength: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(strength)
        
        prefix = [0] * (n + 2)
        for i in range(n):
            prefix[i+1] = (prefix[i] + strength[i]) % MOD
        prefix_prefix = [0] * (n + 2)
        for i in range(n+1):
            prefix_prefix[i+1] = (prefix_prefix[i] + prefix[i]) % MOD
        
        left = [-1] * n
        stack = []
        for i in range(n):
            while stack and strength[stack[-1]] >= strength[i]:
                stack.pop()
            if stack:
                left[i] = stack[-1]
            else:
                left[i] = -1
            stack.append(i)
        
        right = [n] * n
        stack = []
        for i in range(n-1, -1, -1):
            while stack and strength[stack[-1]] > strength[i]:
                stack.pop()
            if stack:
                right[i] = stack[-1]
            else:
                right[i] = n
            stack.append(i)
        
        res = 0
        for i in range(n):
            l, r = left[i] + 1, right[i] - 1
            total = (i - l + 1) * (prefix_prefix[r+2] - prefix_prefix[i+1]) - (r - i + 1) * (prefix_prefix[i+1] - prefix_prefix[l])
            total %= MOD
            res += strength[i] * total
            res %= MOD
        return res
```",Y,
longest-path-with-different-adjacent-characters,Longest Path With Different Adjacent Characters,"```python
from typing import List

class Solution:
    def longestPath(self, parent: List[int], s: str) -> int:
        n = len(parent)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)
        
        res = 1
        
        def dfs(node):
            nonlocal res
            max1 = max2 = 0
            for child in children[node]:
                path_len = dfs(child)
                if s[child] != s[node]:
                    if path_len > max1:
                        max2 = max1
                        max1 = path_len
                    elif path_len > max2:
                        max2 = path_len
            res = max(res, max1 + max2 + 1)
            return max1 + 1
        
        dfs(0)
        return res
```",Y,
substring-with-largest-variance,Substring With Largest Variance,"```python
class Solution:
    def largestVariance(self, s: str) -> int:
        unique_chars = list(set(s))
        max_variance = 0
        
        for i in range(len(unique_chars)):
            for j in range(len(unique_chars)):
                if i == j:
                    continue
                char1, char2 = unique_chars[i], unique_chars[j]
                count1 = count2 = 0
                reset_flag = False
                
                for char in s:
                    if char == char1:
                        count1 += 1
                    elif char == char2:
                        count2 += 1
                    
                    if count2 > count1:
                        count1 = count2 = 0
                        reset_flag = True
                    elif count1 > 0 and count2 > 0:
                        max_variance = max(max_variance, count1 - count2)
                
                if reset_flag:
                    count1 = count2 = 0
                    for char in reversed(s):
                        if char == char1:
                            count1 += 1
                        elif char == char2:
                            count2 += 1
                        
                        if count2 > count1:
                            break
                        elif count1 > 0 and count2 > 0:
                            max_variance = max(max_variance, count1 - count2)
        
        return max_variance
```",Y,
count-integers-in-intervals,Count Integers in Intervals,"```python
import bisect

class CountIntervals:

    def __init__(self):
        self.intervals = []
        self.total = 0

    def add(self, left: int, right: int) -> None:
        intervals = self.intervals
        i = bisect.bisect_left(intervals, (left, right))
        if i > 0 and intervals[i-1][1] >= left - 1:
            left_prev, right_prev = intervals[i-1]
            new_left = min(left_prev, left)
            new_right = max(right_prev, right)
            self.total -= right_prev - left_prev + 1
            intervals.pop(i-1)
            left, right = new_left, new_right
            i -= 1
        while i < len(intervals) and intervals[i][0] <= right + 1:
            next_left, next_right = intervals[i]
            new_right = max(right, next_right)
            self.total -= next_right - next_left + 1
            intervals.pop(i)
            right = new_right
        bisect.insort(intervals, (left, right))
        self.total += right - left + 1

    def count(self) -> int:
        return self.total
```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
maximum-score-of-a-node-sequence,Maximum Score of a Node Sequence,"```python
from collections import defaultdict

class Solution:
    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for a, b in edges:
            graph[a].append((scores[b], b))
            graph[b].append((scores[a], a))
        
        for node in graph:
            graph[node].sort(reverse=True)
            graph[node] = graph[node][:3]
        
        max_score = -1
        
        for a, b in edges:
            for (score_c, c) in graph[a]:
                if c == b:
                    continue
                for (score_d, d) in graph[b]:
                    if d == a or d == c:
                        continue
                    current_sum = scores[a] + scores[b] + scores[c] + scores[d]
                    if current_sum > max_score:
                        max_score = current_sum
        
        return max_score
```",Y,
check-if-there-is-a-valid-parentheses-string-path, Check if There Is a Valid Parentheses String Path,"```python
class Solution:
    def hasValidPath(self, grid: List[List[str]]) -> bool:
        m, n = len(grid), len(grid[0])
        max_len = m + n - 1
        if max_len % 2 != 0:
            return False
        
        from functools import lru_cache
        
        @lru_cache(maxsize=None)
        def dfs(i, j, balance):
            if balance < 0 or balance > (m + n - 1 - i - j):
                return False
            if i == m - 1 and j == n - 1:
                return balance == 1 and grid[i][j] == ')'
            res = False
            if i + 1 < m:
                if grid[i][j] == '(':
                    res = res or dfs(i + 1, j, balance + 1)
                else:
                    res = res or dfs(i + 1, j, balance - 1)
            if j + 1 < n:
                if grid[i][j] == '(':
                    res = res or dfs(i + 1, j, balance + 1) if i + 1 < m else False
                    res = res or dfs(i, j + 1, balance + 1)
                else:
                    res = res or dfs(i + 1, j, balance - 1) if i + 1 < m else False
                    res = res or dfs(i, j + 1, balance - 1)
            return res
        
        return dfs(0, 0, 0)
```",Y,
escape-the-spreading-fire,Escape the Spreading Fire,"```python
from typing import List
from collections import deque

class Solution:
    def maximumMinutes(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        def is_possible(wait_time):
            fire_queue = deque()
            fire_time = [[-1 for _ in range(n)] for _ in range(m)]
            
            for i in range(m):
                for j in range(n):
                    if grid[i][j] == 1:
                        fire_queue.append((i, j))
                        fire_time[i][j] = 0
            
            while fire_queue:
                x, y = fire_queue.popleft()
                for dx, dy in directions:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < m and 0 <= ny < n:
                        if grid[nx][ny] == 2:
                            continue
                        if fire_time[nx][ny] == -1:
                            fire_time[nx][ny] = fire_time[x][y] + 1
                            fire_queue.append((nx, ny))
            
            queue = deque()
            queue.append((0, 0))
            arrival_time = [[-1 for _ in range(n)] for _ in range(m)]
            arrival_time[0][0] = wait_time
            
            while queue:
                x, y = queue.popleft()
                for dx, dy in directions:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < m and 0 <= ny < n:
                        if grid[nx][ny] == 2:
                            continue
                        if arrival_time[nx][ny] == -1:
                            new_time = arrival_time[x][y] + 1
                            if nx == m - 1 and ny == n - 1:
                                if fire_time[nx][ny] == -1 or new_time <= fire_time[nx][ny]:
                                    return True
                            if fire_time[nx][ny] == -1 or new_time < fire_time[nx][ny]:
                                arrival_time[nx][ny] = new_time
                                queue.append((nx, ny))
            return False
        
        left, right = 0, 10**9
        answer = -1
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                answer = mid
                left = mid + 1
            else:
                right = mid - 1
        
        return answer if answer != 10**9 else 10**9
```",Y,
total-appeal-of-a-string,Total Appeal of A String,"```python
class Solution:
    def appealSum(self, s: str) -> int:
        last_pos = {}
        total = 0
        res = 0
        for i, char in enumerate(s):
            total += i - last_pos.get(char, -1)
            res += total
            last_pos[char] = i
        return res
```",Y,
number-of-flowers-in-full-bloom,Number of Flowers in Full Bloom,"```python
import bisect
from typing import List

class Solution:
    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:
        starts = []
        ends = []
        for start, end in flowers:
            starts.append(start)
            ends.append(end + 1)
        
        starts.sort()
        ends.sort()
        
        res = []
        for person in people:
            i = bisect.bisect_right(starts, person)
            j = bisect.bisect_right(ends, person)
            res.append(i - j)
        return res
```",Y,
maximum-total-beauty-of-the-gardens,Maximum Total Beauty of the Gardens,"```python
class Solution:
    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:
        flowers.sort()
        n = len(flowers)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + flowers[i]
        
        res = 0
        j = n - 1
        while j >= 0 and flowers[j] >= target:
            j -= 1
        
        if j < 0:
            return n * full
        
        for k in range(n, -1, -1):
            if k > 0:
                required = target * k - (prefix[n] - prefix[n - k])
                if required > newFlowers:
                    continue
                remaining = newFlowers - required
                if remaining <= 0:
                    current = k * full
                    if current > res:
                        res = current
                    continue
                low = 0
                high = target - 1
                best_min = 0
                while low <= high:
                    mid = (low + high) // 2
                    left = 0
                    right = n - k - 1
                    pos = -1
                    while left <= right:
                        m = (left + right) // 2
                        if flowers[m] < mid:
                            pos = m
                            left = m + 1
                        else:
                            right = m - 1
                    if pos == -1:
                        high = mid - 1
                    else:
                        total = mid * (pos + 1) - prefix[pos + 1]
                        if total <= remaining:
                            best_min = mid
                            low = mid + 1
                        else:
                            high = mid - 1
                current = k * full + best_min * partial
                if current > res:
                    res = current
            else:
                low = 0
                high = target - 1
                best_min = 0
                while low <= high:
                    mid = (low + high) // 2
                    left = 0
                    right = n - 1
                    pos = -1
                    while left <= right:
                        m = (left + right) // 2
                        if flowers[m] < mid:
                            pos = m
                            left = m + 1
                        else:
                            right = m - 1
                    if pos == -1:
                        high = mid - 1
                    else:
                        total = mid * (pos + 1) - prefix[pos + 1]
                        if total <= newFlowers:
                            best_min = mid
                            low = mid + 1
                        else:
                            high = mid - 1
                current = best_min * partial
                if current > res:
                    res = current
        return res
```",Y,
sum-of-scores-of-built-strings,Sum of Scores of Built Strings,"```python
class Solution:
    def sumScores(self, s: str) -> int:
        n = len(s)
        z = [0] * n
        l, r = 0, 0
        for i in range(1, n):
            if i <= r:
                z[i] = min(r - i + 1, z[i - l])
            while i + z[i] < n and s[z[i]] == s[i + z[i]]:
                z[i] += 1
            if i + z[i] - 1 > r:
                l, r = i, i + z[i] - 1
        return sum(z) + n
```",Y,
minimum-weighted-subgraph-with-the-required-paths,Minimum Weighted Subgraph With the Required Paths,"```python
import heapq
from typing import List

class Solution:
    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:
        def dijkstra(graph, start):
            dist = [float('inf')] * n
            dist[start] = 0
            heap = [(0, start)]
            visited = set()
            while heap:
                current_dist, u = heapq.heappop(heap)
                if u in visited:
                    continue
                visited.add(u)
                for v, w in graph[u]:
                    if dist[v] > current_dist + w:
                        dist[v] = current_dist + w
                        heapq.heappush(heap, (dist[v], v))
            return dist
        
        graph = [[] for _ in range(n)]
        reversed_graph = [[] for _ in range(n)]
        for u, v, w in edges:
            graph[u].append((v, w))
            reversed_graph[v].append((u, w))
        
        dist_src1 = dijkstra(graph, src1)
        dist_src2 = dijkstra(graph, src2)
        dist_dest = dijkstra(reversed_graph, dest)
        
        min_weight = float('inf')
        for i in range(n):
            if dist_src1[i] != float('inf') and dist_src2[i] != float('inf') and dist_dest[i] != float('inf'):
                total = dist_src1[i] + dist_src2[i] + dist_dest[i]
                if total < min_weight:
                    min_weight = total
        
        return min_weight if min_weight != float('inf') else -1
```",Y,
longest-substring-of-one-repeating-character,Longest Substring of One Repeating Character,"```python
from typing import List

class Solution:
    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:
        s = list(s)
        n = len(s)
        k = len(queryCharacters)
        res = []
        
        class Node:
            __slots__ = ['left', 'right', 'l', 'r', 'max_len', 'left_char', 'right_char', 'left_len', 'right_len']
            def __init__(self, l, r):
                self.l = l
                self.r = r
                self.left = None
                self.right = None
                self.max_len = 0
                self.left_char = ''
                self.right_char = ''
                self.left_len = 0
                self.right_len = 0
        
        def build(l, r):
            node = Node(l, r)
            if l == r:
                node.max_len = 1
                node.left_char = s[l]
                node.right_char = s[l]
                node.left_len = 1
                node.right_len = 1
            else:
                mid = (l + r) // 2
                node.left = build(l, mid)
                node.right = build(mid+1, r)
                node = merge(node, node.left, node.right)
            return node
        
        def merge(parent, left, right):
            parent.max_len = max(left.max_len, right.max_len)
            parent.left_char = left.left_char
            parent.right_char = right.right_char
            
            if left.right_char == right.left_char:
                parent.max_len = max(parent.max_len, left.right_len + right.left_len)
            
            parent.left_len = left.left_len
            if left.left_len == (left.r - left.l + 1) and left.right_char == right.left_char:
                parent.left_len += right.left_len
            
            parent.right_len = right.right_len
            if right.right_len == (right.r - right.l + 1) and left.right_char == right.left_char:
                parent.right_len += left.right_len
            
            return parent
        
        def update(node, idx, char):
            if node.l == node.r:
                node.left_char = char
                node.right_char = char
                return
            if idx <= node.left.r:
                update(node.left, idx, char)
            else:
                update(node.right, idx, char)
            merge(node, node.left, node.right)
        
        root = build(0, n-1)
        
        for i in range(k):
            idx = queryIndices[i]
            char = queryCharacters[i]
            if s[idx] != char:
                s[idx] = char
                update(root, idx, char)
            res.append(root.max_len)
        
        return res
```",Y,
minimum-white-tiles-after-covering-with-carpets,Minimum White Tiles After Covering With Carpets,"```python
class Solution:
    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:
        n = len(floor)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + (1 if floor[i] == '1' else 0)
        
        dp = [[0] * (numCarpets + 1) for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            for k in range(numCarpets + 1):
                if k == 0:
                    dp[i][k] = prefix[i]
                else:
                    if i <= carpetLen:
                        dp[i][k] = 0
                    else:
                        dp[i][k] = min(dp[i-1][k] + (1 if floor[i-1] == '1' else 0), dp[i-carpetLen][k-1])
        
        return dp[n][numCarpets]
```",Y,
replace-non-coprime-numbers-in-array,Replace Non-Coprime Numbers in Array,"```python
import math
from typing import List

class Solution:
    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:
        stack = []
        for num in nums:
            current = num
            while stack:
                gcd_val = math.gcd(stack[-1], current)
                if gcd_val == 1:
                    break
                last = stack.pop()
                current = (last * current) // gcd_val
            stack.append(current)
        return stack
```",Y,
count-array-pairs-divisible-by-k,Count Array Pairs Divisible by K,"```python
import math
from collections import defaultdict
from typing import List

class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        freq = defaultdict(int)
        res = 0
        
        def compute_gcd_of_factors(num, k):
            gcd_val = math.gcd(num, k)
            return gcd_val
        
        for num in nums:
            gcd_val = compute_gcd_of_factors(num, k)
            target = k // gcd_val
            for d in freq:
                if d % target == 0:
                    res += freq[d]
            freq[gcd_val] += 1
        
        return res
```",Y,
minimum-time-to-finish-the-race,Minimum Time to Finish the Race,"```python
class Solution:
    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:
        max_consecutive_laps = 0
        min_time_no_change = [float('inf')] * (numLaps + 1)
        
        for f, r in tires:
            total = 0
            time = f
            for lap in range(1, numLaps + 1):
                total += time
                if total >= (1 << 20):  # Prevent overflow and early termination
                    break
                if total < min_time_no_change[lap]:
                    min_time_no_change[lap] = total
                time *= r
        
        dp = [float('inf')] * (numLaps + 1)
        dp[0] = 0
        
        for lap in range(1, numLaps + 1):
            for prev_laps in range(max(0, lap - 20), lap):
                current_time = dp[prev_laps] + changeTime + min_time_no_change[lap - prev_laps]
                if current_time < dp[lap]:
                    dp[lap] = current_time
        
        return dp[numLaps] - changeTime  # Subtract the initial changeTime which is not needed
```",Y,
maximum-and-sum-of-array,Maximum AND Sum of Array,"```python
class Solution:
    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:
        n = len(nums)
        dp = [0] * (1 << (2 * numSlots))
        
        for mask in range(1 << (2 * numSlots)):
            cnt = bin(mask).count('1')
            if cnt >= n:
                continue
            for i in range(2 * numSlots):
                slot = (i // 2) + 1
                if not (mask & (1 << i)):
                    new_mask = mask | (1 << i)
                    dp[new_mask] = max(dp[new_mask], dp[mask] + (nums[cnt] & slot))
        
        return max(dp)
```",Y,
minimum-time-to-remove-all-cars-containing-illegal-goods,Minimum Time to Remove All Cars Containing Illegal Goods,"```python
class Solution:
    def minimumTime(self, s: str) -> int:
        n = len(s)
        left = [0] * n
        left[0] = 1 if s[0] == '1' else 0
        for i in range(1, n):
            if s[i] == '1':
                left[i] = min(left[i-1] + 2, i + 1)
            else:
                left[i] = left[i-1]
        
        right = [0] * n
        right[-1] = 1 if s[-1] == '1' else 0
        for i in range(n-2, -1, -1):
            if s[i] == '1':
                right[i] = min(right[i+1] + 2, n - i)
            else:
                right[i] = right[i+1]
        
        res = min(left[-1], right[0])
        for i in range(n-1):
            res = min(res, left[i] + right[i+1])
        
        return res
```",Y,
count-good-triplets-in-an-array,Count Good Triplets in an Array,"```python
import bisect

class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        pos2 = [0] * n
        for idx, num in enumerate(nums2):
            pos2[num] = idx
        
        pos_in_nums2 = [0] * n
        for i in range(n):
            pos_in_nums2[i] = pos2[nums1[i]]
        
        res = 0
        sorted_list = []
        for i in range(n):
            y = pos_in_nums2[i]
            left = bisect.bisect_left(sorted_list, y)
            right = len(sorted_list) - left
            res += left * (n - 1 - i - right)
            bisect.insort(sorted_list, y)
        return res
```",Y,
groups-of-strings,Groups of Strings,"```python
class Solution:
    def groupStrings(self, words: List[str]) -> List[int]:
        from collections import defaultdict, deque
        
        masks = []
        for word in words:
            mask = 0
            for c in word:
                mask |= 1 << (ord(c) - ord('a'))
            masks.append(mask)
        
        mask_to_indices = defaultdict(list)
        for idx, mask in enumerate(masks):
            mask_to_indices[mask].append(idx)
        
        visited = [False] * len(words)
        max_group_size = 0
        num_groups = 0
        
        for i in range(len(words)):
            if not visited[i]:
                queue = deque()
                queue.append(i)
                visited[i] = True
                current_group_size = 0
                
                while queue:
                    current_idx = queue.popleft()
                    current_group_size += 1
                    current_mask = masks[current_idx]
                    
                    for bit in range(26):
                        if not (current_mask & (1 << bit)):
                            new_mask = current_mask | (1 << bit)
                            if new_mask in mask_to_indices:
                                for neighbor_idx in mask_to_indices[new_mask]:
                                    if not visited[neighbor_idx]:
                                        visited[neighbor_idx] = True
                                        queue.append(neighbor_idx)
                    
                    for bit in range(26):
                        if current_mask & (1 << bit):
                            new_mask = current_mask ^ (1 << bit)
                            if new_mask in mask_to_indices:
                                for neighbor_idx in mask_to_indices[new_mask]:
                                    if not visited[neighbor_idx]:
                                        visited[neighbor_idx] = True
                                        queue.append(neighbor_idx)
                    
                    for bit_to_remove in range(26):
                        if current_mask & (1 << bit_to_remove):
                            temp_mask = current_mask ^ (1 << bit_to_remove)
                            for bit_to_add in range(26):
                                if not (temp_mask & (1 << bit_to_add)):
                                    new_mask = temp_mask | (1 << bit_to_add)
                                    if new_mask in mask_to_indices:
                                        for neighbor_idx in mask_to_indices[new_mask]:
                                            if not visited[neighbor_idx]:
                                                visited[neighbor_idx] = True
                                                queue.append(neighbor_idx)
                
                max_group_size = max(max_group_size, current_group_size)
                num_groups += 1
        
        return [num_groups, max_group_size]
```",Y,
find-substring-with-given-hash-value,Find Substring With Given Hash Value,"```python
class Solution:
    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:
        n = len(s)
        current_hash = 0
        power_k = 1
        
        for i in range(n - 1, n - k - 1, -1):
            current_hash = (current_hash * power + (ord(s[i]) - ord('a') + 1)) % modulo
            if i != n - k:
                power_k = (power_k * power) % modulo
        
        result = -1
        if current_hash == hashValue:
            result = n - k
        
        for i in range(n - k - 1, -1, -1):
            outgoing_char = (ord(s[i + k]) - ord('a') + 1) * power_k % modulo
            current_hash = (current_hash - outgoing_char) % modulo
            current_hash = (current_hash * power + (ord(s[i]) - ord('a') + 1)) % modulo
            if current_hash == hashValue:
                result = i
        
        return s[result:result + k]
```",Y,
maximum-good-people-based-on-statements,Maximum Good People Based on Statements,"```python
from typing import List

class Solution:
    def maximumGood(self, statements: List[List[int]]) -> int:
        n = len(statements)
        max_good = 0
        
        for mask in range(1, 1 << n):
            is_valid = True
            good_count = bin(mask).count('1')
            
            for i in range(n):
                if not (mask & (1 << i)):
                    continue
                
                for j in range(n):
                    if statements[i][j] == 2:
                        continue
                    expected = (mask >> j) & 1
                    if statements[i][j] != expected:
                        is_valid = False
                        break
                if not is_valid:
                    break
            
            if is_valid and good_count > max_good:
                max_good = good_count
        
        return max_good
```",Y,
minimum-difference-in-sums-after-removal-of-elements,Minimum Difference in Sums After Removal of Elements,"```python
import heapq

class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums) // 3
        
        max_heap = []
        left_sum = 0
        left_sums = [0] * (3 * n)
        
        for i in range(2 * n):
            num = nums[i]
            heapq.heappush(max_heap, -num)
            left_sum += num
            if len(max_heap) > n:
                val = -heapq.heappop(max_heap)
                left_sum -= val
            if i >= n - 1:
                left_sums[i] = left_sum
        
        min_heap = []
        right_sum = 0
        right_sums = [0] * (3 * n)
        
        for i in range(3 * n - 1, n - 1, -1):
            num = nums[i]
            heapq.heappush(min_heap, num)
            right_sum += num
            if len(min_heap) > n:
                val = heapq.heappop(min_heap)
                right_sum -= val
            if i <= 2 * n:
                right_sums[i] = right_sum
        
        min_diff = float('inf')
        for i in range(n - 1, 2 * n):
            diff = left_sums[i] - right_sums[i + 1]
            if diff < min_diff:
                min_diff = diff
        
        return min_diff
```",Y,
maximum-running-time-of-n-computers,Maximum Running Time of N Computers,"```python
from typing import List

class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        left, right = 1, sum(batteries) // n
        
        while left < right:
            mid = (left + right + 1) // 2
            total = 0
            for bat in batteries:
                total += min(bat, mid)
                if total >= mid * n:
                    break
            if total >= mid * n:
                left = mid
            else:
                right = mid - 1
        return left
```",Y,
earliest-possible-day-of-full-bloom,Earliest Possible Day of Full Bloom,"```python
from typing import List

class Solution:
    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:
        indices = sorted(range(len(growTime)), key=lambda i: -growTime[i])
        current_plant_time = 0
        max_bloom_time = 0
        for i in indices:
            current_plant_time += plantTime[i]
            bloom_time = current_plant_time + growTime[i]
            if bloom_time > max_bloom_time:
                max_bloom_time = bloom_time
        return max_bloom_time
```",Y,
number-of-ways-to-divide-a-long-corridor,Number of Ways to Divide a Long Corridor,"```python
class Solution:
    def numberOfWays(self, corridor: str) -> int:
        MOD = 10**9 + 7
        seats = []
        for i, c in enumerate(corridor):
            if c == 'S':
                seats.append(i)
        if len(seats) % 2 != 0 or len(seats) == 0:
            return 0
        if len(seats) == 2:
            return 1
        res = 1
        for i in range(1, len(seats) // 2):
            res *= (seats[2*i] - seats[2*i - 1])
            res %= MOD
        return res
```",Y,
maximum-employees-to-be-invited-to-a-meeting,Maximum Employees to Be Invited to a Meeting,"```python
class Solution:
    def maximumInvitations(self, favorite: List[int]) -> int:
        n = len(favorite)
        visited = [False] * n
        max_cycle = 0
        pair_chains = {}

        for i in range(n):
            if not visited[i]:
                path = []
                current = i
                while True:
                    if visited[current]:
                        if current in path:
                            idx = path.index(current)
                            cycle_len = len(path) - idx
                            max_cycle = max(max_cycle, cycle_len)
                        break
                    visited[current] = True
                    path.append(current)
                    current = favorite[current]

        mutual_pairs = []
        for i in range(n):
            if favorite[favorite[i]] == i and i < favorite[i]:
                mutual_pairs.append((i, favorite[i]))

        from collections import defaultdict
        graph = defaultdict(list)
        for u in range(n):
            v = favorite[u]
            if favorite[v] != u:
                graph[v].append(u)

        def dfs(node, forbidden):
            max_depth = 0
            for neighbor in graph[node]:
                if neighbor != forbidden:
                    max_depth = max(max_depth, dfs(neighbor, forbidden))
            return max_depth + 1

        total_pairs = 0
        for a, b in mutual_pairs:
            len_a = dfs(a, b)
            len_b = dfs(b, a)
            total_pairs += len_a + len_b

        return max(max_cycle, total_pairs)
```",Y,
recover-the-original-array,Recover the Original Array,"```python
from collections import defaultdict

class Solution:
    def recoverArray(self, nums: List[int]) -> List[int]:
        nums.sort()
        n = len(nums)
        possible_ks = set()
        
        for j in range(1, n):
            diff = nums[j] - nums[0]
            if diff > 0 and diff % 2 == 0:
                possible_ks.add(diff // 2)
        
        for k in sorted(possible_ks):
            freq = defaultdict(int)
            for num in nums:
                freq[num] += 1
            res = []
            valid = True
            for num in nums:
                if freq[num] == 0:
                    continue
                if freq[num + 2 * k] == 0:
                    valid = False
                    break
                freq[num] -= 1
                freq[num + 2 * k] -= 1
                res.append(num + k)
            if valid and len(res) == n // 2:
                return res
        return []
```",Y,
minimum-operations-to-make-the-array-k-increasing,Minimum Operations to Make the Array K-Increasing,"```python
import bisect
from typing import List

class Solution:
    def kIncreasing(self, arr: List[int], k: int) -> int:
        total_operations = 0
        for i in range(k):
            subseq = []
            for j in range(i, len(arr), k):
                subseq.append(arr[j])
            lis = []
            for num in subseq:
                idx = bisect.bisect_right(lis, num)
                if idx == len(lis):
                    lis.append(num)
                else:
                    lis[idx] = num
            total_operations += len(subseq) - len(lis)
        return total_operations
```",Y,
maximum-fruits-harvested-after-at-most-k-steps,Maximum Fruits Harvested After at Most K Steps,"```python
class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        left = 0
        right = 0
        n = len(fruits)
        max_fruits = 0
        current_sum = 0
        
        positions = [pos for pos, _ in fruits]
        amounts = [amount for _, amount in fruits]
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + amounts[i]
        
        for i in range(n):
            pos = fruits[i][0]
            if pos <= startPos:
                steps = startPos - pos
                remaining = k - steps
                if remaining >= 0:
                    max_right = startPos + remaining
                    l, r = i, n - 1
                    best = i
                    while l <= r:
                        mid = (l + r) // 2
                        if fruits[mid][0] <= max_right:
                            best = mid
                            l = mid + 1
                        else:
                            r = mid - 1
                    current = prefix[best + 1] - prefix[i]
                    if current > max_fruits:
                        max_fruits = current
            if pos >= startPos:
                steps = pos - startPos
                remaining = k - steps
                if remaining >= 0:
                    min_left = startPos - remaining
                    l, r = 0, i
                    best = i
                    while l <= r:
                        mid = (l + r) // 2
                        if fruits[mid][0] >= min_left:
                            best = mid
                            r = mid - 1
                        else:
                            l = mid + 1
                    current = prefix[i + 1] - prefix[best]
                    if current > max_fruits:
                        max_fruits = current
        
        return max_fruits
```",Y,
abbreviating-the-product-of-a-range,Abbreviating the Product of a Range,"```python
import math

class Solution:
    def abbreviateProduct(self, left: int, right: int) -> str:
        product = 1
        count2 = 0
        count5 = 0
        
        for num in range(left, right + 1):
            product *= num
            while num % 2 == 0:
                num //= 2
                count2 += 1
            while num % 5 == 0:
                num //= 5
                count5 += 1
        
        C = min(count2, count5)
        
        for _ in range(C):
            product //= 10
        
        s = str(product)
        d = len(s)
        
        if d <= 10:
            return f""{product}e{C}""
        else:
            pre = s[:5]
            suf = s[-5:]
            return f""{pre}...{suf}e{C}""
```",Y,
find-all-people-with-secret,Find All People With Secret,"```python
from collections import defaultdict, deque

class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        known = set([0, firstPerson])
        
        time_map = defaultdict(list)
        for x, y, time in meetings:
            time_map[time].append((x, y))
        
        for time in sorted(time_map.keys()):
            graph = defaultdict(list)
            current_meetings = time_map[time]
            participants = set()
            
            for x, y in current_meetings:
                graph[x].append(y)
                graph[y].append(x)
                participants.add(x)
                participants.add(y)
            
            queue = deque()
            for person in participants:
                if person in known:
                    queue.append(person)
            
            while queue:
                current = queue.popleft()
                for neighbor in graph[current]:
                    if neighbor not in known:
                        known.add(neighbor)
                        queue.append(neighbor)
        
        return list(known)
```",Y,
sequentially-ordinal-rank-tracker,Sequentially Ordinal Rank Tracker,"```python
import heapq

class SORTracker:

    def __init__(self):
        self.min_heap = []
        self.max_heap = []
        self.get_count = 0

    def add(self, name: str, score: int) -> None:
        if self.min_heap and (-self.min_heap[0][0] > score or (-self.min_heap[0][0] == score and self.min_heap[0][1] < name)):
            val = heapq.heappop(self.min_heap)
            heapq.heappush(self.max_heap, (-val[0], val[1]))
            heapq.heappush(self.min_heap, (-score, name))
        else:
            heapq.heappush(self.max_heap, (score, name))
        
        if len(self.max_heap) > self.get_count:
            val = heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, (-val[0], val[1]))

    def get(self) -> str:
        self.get_count += 1
        result = self.min_heap[0][1]
        if self.max_heap and len(self.min_heap) < self.get_count:
            val = heapq.heappop(self.max_heap)
            heapq.heappush(self.min_heap, (-val[0], val[1]))
        return result
```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
sum-of-k-mirror-numbers,Sum of k-Mirror Numbers,"```python
class Solution:
    def kMirror(self, k: int, n: int) -> int:
        def is_palindrome(s):
            return s == s[::-1]
        
        def get_palindromes():
            length = 1
            while True:
                for half in range(10 ** (length // 2 - 1), 10 ** (length // 2)):
                    half_str = str(half)
                    if length % 2 == 0:
                        palindrome = int(half_str + half_str[::-1])
                    else:
                        for d in '0123456789':
                            palindrome = int(half_str + d + half_str[::-1])
                            yield palindrome
                length += 1
        
        count = 0
        total = 0
        for num in get_palindromes():
            if is_palindrome(self.convert_base(num, k)):
                total += num
                count += 1
                if count == n:
                    break
        return total
    
    def convert_base(self, num, k):
        if num == 0:
            return '0'
        digits = []
        while num > 0:
            digits.append(str(num % k))
            num = num // k
        return ''.join(reversed(digits))
```",Y,
valid-arrangement-of-pairs,Valid Arrangement of Pairs,"```python
from collections import defaultdict, deque

class Solution:
    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:
        graph = defaultdict(list)
        in_degree = defaultdict(int)
        out_degree = defaultdict(int)
        
        for u, v in pairs:
            graph[u].append(v)
            out_degree[u] += 1
            in_degree[v] += 1
        
        start = pairs[0][0]
        for u in out_degree:
            if out_degree[u] - in_degree[u] == 1:
                start = u
                break
        
        stack = []
        path = []
        stack.append(start)
        
        while stack:
            current = stack[-1]
            if graph[current]:
                next_node = graph[current].pop()
                stack.append(next_node)
            else:
                path.append(stack.pop())
        
        path.reverse()
        result = []
        for i in range(len(path) - 1):
            result.append([path[i], path[i+1]])
        
        return result
```",Y,
stamping-the-grid,Stamping the Grid,"```python
class Solution:
    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:
        m, n = len(grid), len(grid[0])
        
        prefix = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m):
            row_sum = 0
            for j in range(n):
                row_sum += grid[i][j]
                prefix[i+1][j+1] = prefix[i][j+1] + row_sum
        
        diff = [[0] * (n + 2) for _ in range(m + 2)]
        for i in range(m - stampHeight + 1):
            for j in range(n - stampWidth + 1):
                x1, y1 = i, j
                x2, y2 = i + stampHeight - 1, j + stampWidth - 1
                total = prefix[x2+1][y2+1] - prefix[x1][y2+1] - prefix[x2+1][y1] + prefix[x1][y1]
                if total == 0:
                    diff[x1+1][y1+1] += 1
                    diff[x1+1][y2+2] -= 1
                    diff[x2+2][y1+1] -= 1
                    diff[x2+2][y2+2] += 1
        
        stamp = [[0] * (n + 1) for _ in range(m + 1)]
        possible = True
        for i in range(1, m + 1):
            row_sum = 0
            for j in range(1, n + 1):
                row_sum += diff[i][j]
                stamp[i][j] = stamp[i-1][j] + row_sum
                if grid[i-1][j-1] == 0 and stamp[i][j] == 0:
                    possible = False
                    break
            if not possible:
                break
        
        return possible
```",Y,
process-restricted-friend-requests,Process Restricted Friend Requests,"```python
class Solution:
    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:
        parent = list(range(n))
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root != v_root:
                parent[v_root] = u_root
        
        res = []
        for u, v in requests:
            u_root = find(u)
            v_root = find(v)
            if u_root == v_root:
                res.append(True)
                continue
            
            valid = True
            for x, y in restrictions:
                x_root = find(x)
                y_root = find(y)
                if (x_root == u_root and y_root == v_root) or (x_root == v_root and y_root == u_root):
                    valid = False
                    break
            if valid:
                union(u, v)
                res.append(True)
            else:
                res.append(False)
        return res
```",Y,
count-fertile-pyramids-in-a-land,Count Fertile Pyramids in a Land,"```python
class Solution:
    def countPyramids(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        res = 0
        dp = [[0] * n for _ in range(m)]
        
        for i in range(m - 1, -1, -1):
            for j in range(n):
                if grid[i][j] == 0:
                    dp[i][j] = 0
                else:
                    if i == m - 1 or j == 0 or j == n - 1:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = 1 + min(dp[i + 1][j - 1], dp[i + 1][j], dp[i + 1][j + 1])
                    res += dp[i][j] - 1
        
        dp = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:
                    dp[i][j] = 0
                else:
                    if i == 0 or j == 0 or j == n - 1:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1])
                    res += dp[i][j] - 1
        
        return res
```",Y,
maximum-path-quality-of-a-graph,Maximum Path Quality of a Graph,"```python
from typing import List
from collections import defaultdict

class Solution:
    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:
        graph = defaultdict(list)
        for u, v, time in edges:
            graph[u].append((v, time))
            graph[v].append((u, time))
        
        max_quality = 0
        visited = {0: 1}
        
        def dfs(node, current_time, current_quality):
            nonlocal max_quality
            if node == 0:
                max_quality = max(max_quality, current_quality)
            
            for neighbor, time in graph[node]:
                if current_time + time <= maxTime:
                    if neighbor not in visited:
                        visited[neighbor] = 1
                        dfs(neighbor, current_time + time, current_quality + values[neighbor])
                        del visited[neighbor]
                    else:
                        dfs(neighbor, current_time + time, current_quality)
        
        dfs(0, 0, values[0])
        return max_quality
```",Y,
check-if-an-original-string-exists-given-two-encoded-strings,Check if an Original String Exists Given Two Encoded Strings,"```python
class Solution:
    def possiblyEquals(self, s1: str, s2: str) -> bool:
        from functools import lru_cache

        def get_possible_lengths(s):
            res = [int(s)]
            if len(s) >= 2:
                a, b = s[:1], s[1:]
                for la in get_possible_lengths(a):
                    for lb in get_possible_lengths(b):
                        res.append(la + lb)
            if len(s) >= 3:
                a, b = s[:2], s[2:]
                for la in get_possible_lengths(a):
                    for lb in get_possible_lengths(b):
                        res.append(la + lb)
            return list(set(res))

        @lru_cache(maxsize=None)
        def dfs(i, j, diff):
            if i == len(s1) and j == len(s2):
                return diff == 0
            if i < len(s1) and s1[i].isdigit():
                k = i
                while k < len(s1) and s1[k].isdigit():
                    k += 1
                for l in get_possible_lengths(s1[i:k]):
                    if dfs(k, j, diff - l):
                        return True
                return False
            if j < len(s2) and s2[j].isdigit():
                k = j
                while k < len(s2) and s2[k].isdigit():
                    k += 1
                for l in get_possible_lengths(s2[j:k]):
                    if dfs(i, k, diff + l):
                        return True
                return False
            if diff == 0:
                if i < len(s1) and j < len(s2) and s1[i] == s2[j]:
                    return dfs(i + 1, j + 1, 0)
                else:
                    return False
            elif diff > 0:
                if i < len(s1):
                    return dfs(i + 1, j, diff - 1)
                else:
                    return False
            else:
                if j < len(s2):
                    return dfs(i, j + 1, diff + 1)
                else:
                    return False

        return dfs(0, 0, 0)
```",Y,
maximum-number-of-tasks-you-can-assign,Maximum Number of Tasks You Can Assign,"```python
import bisect

class Solution:
    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:
        tasks.sort()
        workers.sort()
        
        left, right = 0, min(len(tasks), len(workers))
        answer = 0
        
        def is_possible(k):
            if k == 0:
                return True
            available_workers = workers[-k:]
            remaining_pills = pills
            task_ptr = 0
            dq = []
            
            for worker in available_workers:
                if task_ptr < k:
                    if worker >= tasks[task_ptr]:
                        task_ptr += 1
                    else:
                        if remaining_pills > 0 and worker + strength >= tasks[task_ptr]:
                            remaining_pills -= 1
                            task_ptr += 1
                        else:
                            pass
            return task_ptr == k
        
        while left <= right:
            mid = (left + right) // 2
            if is_possible(mid):
                answer = mid
                left = mid + 1
            else:
                right = mid - 1
        return answer
```",Y,
parallel-courses-iii,Parallel Courses III,"```python
from collections import deque
from typing import List

class Solution:
    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        graph = [[] for _ in range(n)]
        in_degree = [0] * n
        for prev, next_course in relations:
            graph[prev - 1].append(next_course - 1)
            in_degree[next_course - 1] += 1
        
        queue = deque()
        max_time = [0] * n
        for i in range(n):
            if in_degree[i] == 0:
                queue.append(i)
                max_time[i] = time[i]
        
        while queue:
            current = queue.popleft()
            for neighbor in graph[current]:
                if max_time[neighbor] < max_time[current] + time[neighbor]:
                    max_time[neighbor] = max_time[current] + time[neighbor]
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)
        
        return max(max_time)
```",Y,
second-minimum-time-to-reach-destination,Second Minimum Time to Reach Destination,"```python
from typing import List
import heapq

class Solution:
    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
        graph = [[] for _ in range(n + 1)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        min_times = [[float('inf')] * 2 for _ in range(n + 1)]
        min_times[1][0] = 0
        heap = []
        heapq.heappush(heap, (0, 1))
        
        while heap:
            current_time, node = heapq.heappop(heap)
            if node == n and current_time > min_times[n][0]:
                return current_time
            
            for neighbor in graph[node]:
                total_time = current_time
                if (total_time // change) % 2 == 1:
                    total_time += change - (total_time % change)
                total_time += time
                
                if total_time < min_times[neighbor][0]:
                    min_times[neighbor][1] = min_times[neighbor][0]
                    min_times[neighbor][0] = total_time
                    heapq.heappush(heap, (total_time, neighbor))
                elif min_times[neighbor][0] < total_time < min_times[neighbor][1]:
                    min_times[neighbor][1] = total_time
                    heapq.heappush(heap, (total_time, neighbor))
        
        return min_times[n][1]
```",Y,
number-of-valid-move-combinations-on-chessboard,Number of Valid Move Combinations On Chessboard,"```python
class Solution:
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        directions = {
            'rook': [(1, 0), (-1, 0), (0, 1), (0, -1)],
            'bishop': [(1, 1), (1, -1), (-1, 1), (-1, -1)],
            'queen': [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        }
        
        n = len(pieces)
        targets = []
        
        for i in range(n):
            piece = pieces[i]
            r, c = positions[i]
            dirs = directions['queen'] if piece == 'queen' else directions[piece]
            possible = []
            for dr, dc in dirs:
                nr, nc = r, c
                while True:
                    nr += dr
                    nc += dc
                    if 1 <= nr <= 8 and 1 <= nc <= 8:
                        possible.append((nr, nc))
                    else:
                        break
            possible.append((r, c))
            targets.append(possible)
        
        from itertools import product
        
        count = 0
        
        for dests in product(*targets):
            valid = True
            occupied = set()
            for i in range(n):
                r, c = positions[i]
                tr, tc = dests[i]
                if (r, c) == (tr, tc):
                    occupied.add((r, c))
                    continue
                dr = 1 if tr > r else (-1 if tr < r else 0)
                dc = 1 if tc > c else (-1 if tc < c else 0)
                steps = max(abs(tr - r), abs(tc - c))
                for step in range(1, steps + 1):
                    pos = (r + dr * step, c + dc * step)
                    if pos in occupied:
                        valid = False
                        break
                    occupied.add(pos)
                if not valid:
                    break
            if valid:
                count += 1
        
        return count
```",Y,
partition-array-into-two-arrays-to-minimize-sum-difference,Partition Array Into Two Arrays to Minimize Sum Difference,"```python
class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        n = len(nums) // 2
        total = sum(nums)
        half = total // 2
        
        left = nums[:n]
        right = nums[n:]
        
        left_sums = [[] for _ in range(n+1)]
        right_sums = [[] for _ in range(n+1)]
        
        for mask in range(1 << n):
            cnt = bin(mask).count('1')
            sum_l = 0
            sum_r = 0
            for i in range(n):
                if mask & (1 << i):
                    sum_l += left[i]
                    sum_r += right[i]
            left_sums[cnt].append(sum_l)
            right_sums[cnt].append(sum_r)
        
        for k in range(n+1):
            right_sums[k].sort()
        
        min_diff = float('inf')
        
        for k in range(n+1):
            for sum_l in left_sums[k]:
                remaining = half - sum_l
                arr = right_sums[n -k]
                low, high = 0, len(arr) -1
                while low <= high:
                    mid = (low + high) // 2
                    if arr[mid] <= remaining:
                        low = mid +1
                    else:
                        high = mid -1
                if high >=0:
                    sum_r = arr[high]
                    current_sum = sum_l + sum_r
                    diff = abs(total - 2 * current_sum)
                    if diff < min_diff:
                        min_diff = diff
                if low < len(arr):
                    sum_r = arr[low]
                    current_sum = sum_l + sum_r
                    diff = abs(total - 2 * current_sum)
                    if diff < min_diff:
                        min_diff = diff
                if min_diff ==0:
                    return 0
        return min_diff
```",Y,
smallest-k-length-subsequence-with-occurrences-of-a-letter,Smallest K-Length Subsequence With Occurrences of a Letter,"```python
class Solution:
    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:
        stack = []
        n = len(s)
        total_letter = s.count(letter)
        remaining_letter = total_letter
        needed = repetition
        
        for i, ch in enumerate(s):
            while stack and stack[-1] > ch and (len(stack) + (n - i)) > k:
                if stack[-1] == letter:
                    if remaining_letter <= needed:
                        break
                    needed += 1
                stack.pop()
            
            if len(stack) < k:
                if ch == letter:
                    stack.append(ch)
                    needed -= 1
                else:
                    if (k - len(stack)) > needed:
                        stack.append(ch)
            remaining_letter -= (ch == letter)
        
        return ''.join(stack)
```",Y,
kth-smallest-product-of-two-sorted-arrays,Kth Smallest Product of Two Sorted Arrays,"```python
from typing import List

class Solution:
    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:
        def count_leq(mid):
            count = 0
            for num in nums1:
                if num == 0:
                    if mid >= 0:
                        count += len(nums2)
                elif num > 0:
                    left, right = 0, len(nums2)
                    while left < right:
                        mid_j = (left + right) // 2
                        if num * nums2[mid_j] <= mid:
                            left = mid_j + 1
                        else:
                            right = mid_j
                    count += left
                else:
                    left, right = 0, len(nums2)
                    while left < right:
                        mid_j = (left + right) // 2
                        if num * nums2[mid_j] <= mid:
                            right = mid_j
                        else:
                            left = mid_j + 1
                    count += len(nums2) - left
            return count

        left = -10**10 - 1
        right = 10**10 + 1
        while left < right:
            mid = (left + right) // 2
            if count_leq(mid) < k:
                left = mid + 1
            else:
                right = mid
        return left
```",Y,
the-score-of-students-solving-math-expression,The Score of Students Solving Math Expression,"```python
from typing import List

class Solution:
    def scoreOfStudents(self, s: str, answers: List[int]) -> int:
        def compute_correct(s):
            stack = []
            num = 0
            op = '+'
            for i, c in enumerate(s):
                if c.isdigit():
                    num = num * 10 + int(c)
                if not c.isdigit() or i == len(s) - 1:
                    if op == '+':
                        stack.append(num)
                    elif op == '*':
                        stack.append(stack.pop() * num)
                    op = c
                    num = 0
            return sum(stack)
        
        correct = compute_correct(s)
        
        n = len(s)
        dp = [[set() for _ in range(n)] for __ in range(n)]
        
        for i in range(n):
            if s[i].isdigit():
                dp[i][i].add(int(s[i]))
        
        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                if s[j].isdigit() or s[j] in {'+', '*'}:
                    for k in range(i, j):
                        if s[k] in {'+', '*'}:
                            left = dp[i][k - 1]
                            right = dp[k + 1][j]
                            for a in left:
                                for b in right:
                                    res = a + b if s[k] == '+' else a * b
                                    if res <= 1000:
                                        dp[i][j].add(res)
        
        possible_wrong = dp[0][n - 1]
        
        total = 0
        for ans in answers:
            if ans == correct:
                total += 5
            elif ans in possible_wrong:
                total += 2
        return total
```",Y,
longest-subsequence-repeated-k-times,Longest Subsequence Repeated k Times,"```python
class Solution:
    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:
        n = len(s)
        freq = [0] * 26
        for c in s:
            freq[ord(c) - ord('a')] += 1
        
        possible_chars = []
        for i in range(26):
            if freq[i] >= k:
                possible_chars.append(chr(ord('a') + i))
        possible_chars.sort(reverse=True)
        
        def is_possible(seq):
            m = len(seq)
            concat = seq * k
            idx = 0
            for c in s:
                if idx < m * k and c == concat[idx]:
                    idx += 1
            return idx == m * k
        
        max_len = n // k
        for l in range(max_len, 0, -1):
            from itertools import product
            for candidate in product(possible_chars, repeat=l):
                candidate_str = ''.join(candidate)
                if is_possible(candidate_str):
                    return candidate_str
        return """"
```",Y,
maximum-number-of-ways-to-partition-an-array,Maximum Number of Ways to Partition an Array,"```python
from typing import List
from collections import defaultdict

class Solution:
    def waysToPartition(self, nums: List[int], k: int) -> int:
        n = len(nums)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + nums[i]
        total = prefix[n]
        
        res = 0
        for pivot in range(1, n):
            if prefix[pivot] == total - prefix[pivot]:
                res += 1
        
        left_counts = defaultdict(int)
        right_counts = defaultdict(int)
        
        for pivot in range(1, n):
            s = prefix[pivot]
            right_counts[total - 2 * s] += 1
        
        max_changes = 0
        for i in range(n):
            delta = k - nums[i]
            
            cnt = right_counts.get(delta, 0)
            cnt += left_counts.get(total - delta, 0)
            
            if cnt > max_changes:
                max_changes = cnt
            
            if i < n - 1:
                pivot = i + 1
                s = prefix[pivot]
                key = total - 2 * s
                right_counts[key] -= 1
                new_key = (total + 2 * delta) - 2 * s  # Not sure, maybe better to recompute
                left_key = total - 2 * s
                left_counts[left_key] += 1
        
        return max(res, max_changes)
```",Y,
smallest-missing-genetic-value-in-each-subtree,Smallest Missing Genetic Value in Each Subtree,"```python
from typing import List

class Solution:
    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:
        n = len(parents)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parents[i]].append(i)
        
        res = [1] * n
        if 1 not in nums:
            return res
        
        node = nums.index(1)
        visited = set()
        missing = 1
        while node != -1:
            stack = [node]
            while stack:
                u = stack.pop()
                if nums[u] not in visited:
                    visited.add(nums[u])
                    for v in children[u]:
                        stack.append(v)
            while missing in visited:
                missing += 1
            res[node] = missing
            node = parents[node]
        
        return res
```",Y,
gcd-sort-of-an-array,GCD Sort of an Array,"```python
import math
from collections import defaultdict

class Solution:
    def gcdSort(self, nums: List[int]) -> bool:
        parent = {}
        rank = defaultdict(int)
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root == v_root:
                return
            if rank[u_root] > rank[v_root]:
                parent[v_root] = u_root
            else:
                parent[u_root] = v_root
                if rank[u_root] == rank[v_root]:
                    rank[v_root] += 1
        
        max_num = max(nums) if nums else 0
        sieve = list(range(max_num + 1))
        for i in range(2, int(math.sqrt(max_num)) + 1):
            if sieve[i] == i:
                for j in range(i*i, max_num + 1, i):
                    if sieve[j] == j:
                        sieve[j] = i
        
        for num in nums:
            if num == 1:
                continue
            factors = []
            x = num
            while x > 1:
                p = sieve[x]
                factors.append(p)
                while x % p == 0:
                    x = x // p
            if not factors:
                continue
            parent.setdefault(factors[0], factors[0])
            for p in factors[1:]:
                parent.setdefault(p, p)
                union(factors[0], p)
        
        sorted_nums = sorted(nums)
        for a, b in zip(nums, sorted_nums):
            if a == b:
                continue
            if a == 1 or b == 1:
                return False
            a_factors = []
            x = a
            while x > 1:
                p = sieve[x]
                a_factors.append(p)
                while x % p == 0:
                    x = x // p
            b_factors = []
            x = b
            while x > 1:
                p = sieve[x]
                b_factors.append(p)
                while x % p == 0:
                    x = x // p
            if not a_factors or not b_factors:
                return False
            a_root = find(a_factors[0])
            b_root = find(b_factors[0])
            if a_root != b_root:
                return False
        return True
```",Y,
minimum-number-of-operations-to-make-array-continuous,Minimum Number of Operations to Make Array Continuous,"```python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        unique_nums = sorted(list(set(nums)))
        m = len(unique_nums)
        res = float('inf')
        
        left = 0
        for right in range(m):
            while unique_nums[right] - unique_nums[left] >= n:
                left += 1
            res = min(res, n - (right - left + 1))
        
        return res
```",Y,
number-of-unique-good-subsequences,Number of Unique Good Subsequences,"```python
class Solution:
    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
        MOD = 10**9 + 7
        ends0 = 0  # number of unique subsequences ending with 0
        ends1 = 0   # number of unique subsequences ending with 1
        has0 = 0    # whether '0' has appeared in the binary string
        
        for c in binary:
            if c == '0':
                ends0 = (ends0 + ends1) % MOD
                has0 = 1
            else:
                ends1 = (ends0 + ends1 + 1) % MOD
        
        return (ends0 + ends1 + has0) % MOD
```",Y,
find-array-given-subset-sums,Find Array Given Subset Sums,"```python
from collections import defaultdict

class Solution:
    def recoverArray(self, n: int, sums: List[int]) -> List[int]:
        sums.sort()
        res = []
        while len(sums) > 1:
            num = sums[-1] - sums[-2]
            freq = defaultdict(int)
            for x in sums:
                freq[x] += 1
            new_sums = []
            new_sums_zero = []
            found_zero = False
            for x in sums:
                if freq[x] > 0:
                    if x == 0:
                        found_zero = True
                    if found_zero:
                        if freq[x + num] > 0:
                            new_sums_zero.append(x)
                            freq[x] -= 1
                            freq[x + num] -= 1
                    else:
                        pass
                    if not found_zero:
                        if freq[x + num] > 0:
                            new_sums.append(x)
                            freq[x] -= 1
                            freq[x + num] -= 1
            if found_zero:
                sums = new_sums_zero
                res.append(num)
            else:
                sums = new_sums
                res.append(-num)
        return res
```",Y,
the-number-of-good-subsets,The Number of Good Subsets,"```python
class Solution:
    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
        count = [0] * 31
        for num in nums:
            count[num] += 1
        
        mask = [0] * 31
        for num in range(2, 31):
            tmp = num
            m = 0
            for i, p in enumerate(primes):
                if tmp % p == 0:
                    tmp //= p
                    m |= (1 << i)
                    if tmp % p == 0:
                        mask[num] = -1
                        break
            if mask[num] != -1:
                mask[num] = m
        
        dp = [0] * (1 << len(primes))
        dp[0] = 1
        
        for num in range(2, 31):
            if mask[num] == -1 or count[num] == 0:
                continue
            current_mask = mask[num]
            for prev_mask in range((1 << len(primes)) - 1, -1, -1):
                if (prev_mask & current_mask) == 0:
                    new_mask = prev_mask | current_mask
                    dp[new_mask] = (dp[new_mask] + dp[prev_mask] * count[num]) % MOD
        
        total = 0
        for m in range(1, 1 << len(primes)):
            total = (total + dp[m]) % MOD
        
        if count[1] > 0:
            total = (total * pow(2, count[1], MOD)) % MOD
        
        return total
```",Y,
last-day-where-you-can-still-cross,Last Day Where You Can Still Cross,"```python
from typing import List

class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        left, right = 0, len(cells) - 1
        answer = 0
        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        while left <= right:
            mid = (left + right) // 2
            grid = [[0 for _ in range(col)] for _ in range(row)]
            for i in range(mid + 1):
                r, c = cells[i]
                grid[r-1][c-1] = 1
            
            queue = []
            for c in range(col):
                if grid[0][c] == 0:
                    queue.append((0, c))
                    grid[0][c] = 1
            
            found = False
            while queue:
                r, c = queue.pop(0)
                if r == row - 1:
                    found = True
                    break
                for dr, dc in dirs:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 0:
                        grid[nr][nc] = 1
                        queue.append((nr, nc))
            
            if found:
                answer = mid
                left = mid + 1
            else:
                right = mid - 1
        
        return answer + 1 if answer + 1 < len(cells) else answer
```",Y,
find-the-longest-valid-obstacle-course-at-each-position,Find the Longest Valid Obstacle Course at Each Position,"```python
import bisect
from typing import List

class Solution:
    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:
        tails = []
        res = []
        for num in obstacles:
            idx = bisect.bisect_right(tails, num)
            if idx == len(tails):
                tails.append(num)
            else:
                tails[idx] = num
            res.append(idx + 1)
        return res
```",Y,
number-of-ways-to-separate-numbers,Number of Ways to Separate Numbers,"```python
class Solution:
    def numberOfCombinations(self, num: str) -> int:
        MOD = 10**9 + 7
        n = len(num)
        if num[0] == '0':
            return 0
        
        lcp = [[0] * (n + 1) for _ in range(n + 1)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if num[i] == num[j]:
                    lcp[i][j] = lcp[i+1][j+1] + 1
        
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for i in range(1, n + 1):
            if num[i-1] == '0':
                continue
            for l in range(1, i + 1):
                j = i - l
                if j < 0:
                    continue
                res = 0
                if j >= l:
                    res = dp[j][l-1]
                if j >= l:
                    k = j - l
                    if k >= 0:
                        common = lcp[k][j]
                        if common < l and num[k + common] < num[j + common]:
                            res += dp[j][l]
                            res %= MOD
                else:
                    res += dp[j][j] if j > 0 else 0
                    res %= MOD
                dp[i][l] = (dp[i][l-1] + res) % MOD
        
        return dp[n][n]
```",Y,
count-number-of-special-subsequences,Count Number of Special Subsequences,"```python
class Solution:
    def countSpecialSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        a = b = c = 0
        for num in nums:
            if num == 0:
                a = (2 * a + 1) % MOD
            elif num == 1:
                b = (2 * b + a) % MOD
            elif num == 2:
                c = (2 * c + b) % MOD
        return c
```",Y,
delete-duplicate-folders-in-system,Delete Duplicate Folders in System,"```python
class Solution:
    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
        root = {}
        root[""#""] = {}  # dummy root
        
        for path in paths:
            node = root[""#""]
            for folder in path:
                if folder not in node:
                    node[folder] = {}
                node = node[folder]
        
        subtree_counts = defaultdict(int)
        subtree_serialization = {}
        
        def serialize(node):
            if not node:
                return ""#""
            keys = []
            for folder in sorted(node.keys()):
                serialized_child = serialize(node[folder])
                keys.append(f""{folder}:{serialized_child}"")
            key = ""("" + "","".join(keys) + "")""
            subtree_counts[key] += 1
            subtree_serialization[id(node)] = key
            return key
        
        serialize(root[""#""])
        
        to_delete = set()
        
        def mark_deletions(node):
            key = subtree_serialization.get(id(node), """")
            if key and subtree_counts[key] > 1 and key != ""()"":
                to_delete.add(id(node))
                return
            for folder in node:
                mark_deletions(node[folder])
        
        mark_deletions(root[""#""])
        
        result = []
        
        def collect_paths(node, current_path):
            for folder in node:
                if id(node[folder]) not in to_delete:
                    new_path = current_path + [folder]
                    result.append(new_path.copy())
                    collect_paths(node[folder], new_path)
        
        collect_paths(root[""#""], [])
        
        return result
```",Y,
maximum-genetic-difference-query,Maximum Genetic Difference Query,"```python
class Solution:
    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:
        from collections import defaultdict, deque

        tree = defaultdict(list)
        root = -1
        for i, p in enumerate(parents):
            if p == -1:
                root = i
            else:
                tree[p].append(i)
        
        query_map = defaultdict(list)
        for idx, (node, val) in enumerate(queries):
            query_map[node].append((val, idx))
        
        ans = [0] * len(queries)
        
        class TrieNode:
            __slots__ = ['children', 'count']
            def __init__(self):
                self.children = [None, None]
                self.count = 0
        
        root_trie = TrieNode()
        
        def insert(num):
            node = root_trie
            for i in range(17, -1, -1):
                bit = (num >> i) & 1
                if not node.children[bit]:
                    node.children[bit] = TrieNode()
                node = node.children[bit]
                node.count += 1
        
        def remove(num):
            node = root_trie
            for i in range(17, -1, -1):
                bit = (num >> i) & 1
                node = node.children[bit]
                node.count -= 1
        
        def query(num):
            res = 0
            node = root_trie
            for i in range(17, -1, -1):
                bit = (num >> i) & 1
                toggled_bit = 1 - bit
                if node.children[toggled_bit] and node.children[toggled_bit].count > 0:
                    res |= (1 << i)
                    node = node.children[toggled_bit]
                else:
                    node = node.children[bit]
            return res
        
        stack = [(root, True)]
        
        while stack:
            node, is_entering = stack.pop()
            if is_entering:
                insert(node)
                stack.append((node, False))
                for child in reversed(tree[node]):
                    stack.append((child, True))
            else:
                if node in query_map:
                    for val, idx in query_map[node]:
                        ans[idx] = query(val)
                remove(node)
        
        return ans
```",Y,
painting-a-grid-with-three-different-colors,Painting a Grid With Three Different Colors,"```python
class Solution:
    def colorTheGrid(self, m: int, n: int) -> int:
        MOD = 10**9 + 7
        
        def get_valid_states(m):
            from itertools import product
            colors = [0, 1, 2]
            states = []
            for state in product(colors, repeat=m):
                valid = True
                for i in range(m - 1):
                    if state[i] == state[i + 1]:
                        valid = False
                        break
                if valid:
                    states.append(state)
            return states
        
        states = get_valid_states(m)
        if not states:
            return 0
        
        state_to_idx = {state: idx for idx, state in enumerate(states)}
        k = len(states)
        
        transition = [[0] * k for _ in range(k)]
        for i in range(k):
            for j in range(k):
                valid = True
                for x in range(m):
                    if states[i][x] == states[j][x]:
                        valid = False
                        break
                if valid:
                    transition[i][j] = 1
        
        dp = [1] * k
        
        for _ in range(1, n):
            new_dp = [0] * k
            for i in range(k):
                for j in range(k):
                    if transition[i][j]:
                        new_dp[j] = (new_dp[j] + dp[i]) % MOD
            dp = new_dp
        
        return sum(dp) % MOD
```",Y,
merge-bsts-to-create-single-bst,Merge BSTs to Create Single BST,"```python
class Solution:
    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:
        if not trees:
            return None
        
        leaves = set()
        root_dict = {}
        
        for tree in trees:
            root_dict[tree.val] = tree
            if tree.left:
                leaves.add(tree.left.val)
            if tree.right:
                leaves.add(tree.right.val)
        
        candidates = []
        for tree in trees:
            if tree.val not in leaves:
                candidates.append(tree)
        
        if len(candidates) != 1:
            return None
        
        root = candidates[0]
        del root_dict[root.val]
        stack = [(root, float('-inf'), float('inf'))]
        count = 1
        
        while stack:
            node, lower, upper = stack.pop()
            if not node:
                continue
            if node.val <= lower or node.val >= upper:
                return None
            if node.left:
                if node.left.val in root_dict:
                    left_node = root_dict[node.left.val]
                    node.left = left_node
                    del root_dict[left_node.val]
                    count += 1
                stack.append((node.left, lower, node.val))
            if node.right:
                if node.right.val in root_dict:
                    right_node = root_dict[node.right.val]
                    node.right = right_node
                    del root_dict[right_node.val]
                    count += 1
                stack.append((node.right, node.val, upper))
        
        return root if len(root_dict) == 0 and count == len(trees) else None
```",Y,
longest-common-subpath,Longest Common Subpath,"```python
import bisect
from typing import List

class Solution:
    def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:
        if not paths:
            return 0
        
        paths.sort(key=lambda x: len(x))
        shortest_path = paths[0]
        m = len(shortest_path)
        
        base = 10**5 + 3
        mod = 10**11 + 7
        
        max_len = m
        power = [1] * (max_len + 1)
        for i in range(1, max_len + 1):
            power[i] = (power[i-1] * base) % mod
        
        def get_subpath_hashes(path, L):
            if L == 0:
                return []
            h = 0
            for i in range(L):
                h = (h * base + path[i]) % mod
            hashes = [h]
            for i in range(L, len(path)):
                h = (h * base - path[i - L] * power[L] + path[i]) % mod
                hashes.append(h)
            return hashes
        
        low, high = 0, m
        result = 0
        while low <= high:
            mid = (low + high) // 2
            common_hashes = set(get_subpath_hashes(shortest_path, mid))
            
            for path in paths[1:]:
                if len(path) < mid:
                    common_hashes = set()
                    break
                current_hashes = set(get_subpath_hashes(path, mid))
                common_hashes.intersection_update(current_hashes)
                if not common_hashes:
                    break
            
            if common_hashes:
                result = mid
                low = mid + 1
            else:
                high = mid - 1
        
        return result
```",Y,
minimum-cost-to-reach-destination-in-time,Minimum Cost to Reach Destination in Time,"```python
import heapq
from typing import List

class Solution:
    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:
        n = len(passingFees)
        graph = [[] for _ in range(n)]
        for x, y, time in edges:
            graph[x].append((y, time))
            graph[y].append((x, time))
        
        heap = []
        heapq.heappush(heap, (passingFees[0], 0, 0))
        
        min_time = [float('inf')] * n
        min_time[0] = 0
        
        while heap:
            current_cost, current_time, current_node = heapq.heappop(heap)
            if current_node == n - 1:
                return current_cost
            if current_time > min_time[current_node]:
                continue
            for neighbor, time in graph[current_node]:
                new_time = current_time + time
                if new_time > maxTime:
                    continue
                if new_time < min_time[neighbor]:
                    min_time[neighbor] = new_time
                    heapq.heappush(heap, (current_cost + passingFees[neighbor], new_time, neighbor))
        
        return -1
```",Y,
the-earliest-and-latest-rounds-where-players-compete,The Earliest and Latest Rounds Where Players Compete,"```python
class Solution:
    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:
        from functools import lru_cache

        firstPlayer -= 1
        secondPlayer -= 1

        @lru_cache(maxsize=None)
        def dp(mask, round):
            players = []
            for i in range(n):
                if mask & (1 << i):
                    players.append(i)
            if len(players) < 2:
                return (float('inf'), float('-inf'))
            
            next_players = []
            left = 0
            right = len(players) - 1
            while left < right:
                a = players[left]
                b = players[right]
                if (a == firstPlayer and b == secondPlayer) or (a == secondPlayer and b == firstPlayer):
                    return (round, round)
                if a == firstPlayer or a == secondPlayer:
                    next_players.append(a)
                elif b == firstPlayer or b == secondPlayer:
                    next_players.append(b)
                else:
                    next_players.append(a)  # or b, but we need to explore both possibilities
                left += 1
                right -= 1
            if left == right:
                next_players.append(players[left])
            
            next_players.sort()
            next_mask = 0
            for p in next_players:
                next_mask |= (1 << p)
            
            min_round = float('inf')
            max_round = float('-inf')
            if next_mask != mask:
                res = dp(next_mask, round + 1)
                min_round = min(min_round, res[0])
                max_round = max(max_round, res[1])
            else:
                pass
            return (min_round, max_round)
        
        initial_mask = (1 << n) - 1
        result = dp(initial_mask, 1)
        return [result[0], result[1]] if result[0] != float('inf') else [0, 0]
```",Y,
design-movie-rental-system,Design Movie Rental System,"```python
import heapq
from collections import defaultdict

class MovieRentingSystem:

    def __init__(self, n: int, entries: List[List[int]]):
        self.unrented = defaultdict(list)  # movie -> list of (price, shop) min-heap
        self.rented = []  # min-heap of (price, shop, movie)
        self.shop_movie_price = {}  # (shop, movie) -> price
        self.rented_set = set()  # (shop, movie)
        
        for shop, movie, price in entries:
            self.shop_movie_price[(shop, movie)] = price
            heapq.heappush(self.unrented[movie], (price, shop))
        
    def search(self, movie: int) -> List[int]:
        res = []
        temp_heap = []
        available = self.unrented.get(movie, [])
        
        while available and len(res) < 5:
            price, shop = heapq.heappop(available)
            if (shop, movie) not in self.rented_set:
                res.append(shop)
                temp_heap.append((price, shop))
        
        for price, shop in temp_heap:
            heapq.heappush(available, (price, shop))
        
        return res

    def rent(self, shop: int, movie: int) -> None:
        price = self.shop_movie_price[(shop, movie)]
        self.rented_set.add((shop, movie))
        heapq.heappush(self.rented, (price, shop, movie))

    def drop(self, shop: int, movie: int) -> None:
        price = self.shop_movie_price[(shop, movie)]
        self.rented_set.remove((shop, movie))
        heapq.heappush(self.unrented[movie], (price, shop))

    def report(self) -> List[List[int]]:
        res = []
        temp = []
        
        while self.rented and len(res) < 5:
            price, shop, movie = heapq.heappop(self.rented)
            if (shop, movie) in self.rented_set:
                res.append([shop, movie])
                temp.append((price, shop, movie))
        
        for item in temp:
            heapq.heappush(self.rented, item)
        
        return res
```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
minimum-space-wasted-from-packaging,Minimum Space Wasted From Packaging,"```python
import bisect

class Solution:
    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:
        MOD = 10**9 + 7
        packages.sort()
        prefix = [0]
        for p in packages:
            prefix.append(prefix[-1] + p)
        
        min_waste = float('inf')
        
        for supplier_boxes in boxes:
            supplier_boxes.sort()
            if supplier_boxes[-1] < packages[-1]:
                continue  # cannot fit the largest package
            
            total = 0
            prev_idx = 0
            for box in supplier_boxes:
                idx = bisect.bisect_right(packages, box) - 1
                if idx < 0:
                    continue
                count = idx - prev_idx + 1
                total += box * count - (prefix[idx + 1] - prefix[prev_idx])
                prev_idx = idx + 1
                if prev_idx >= len(packages):
                    break
            
            if prev_idx >= len(packages):
                if total < min_waste:
                    min_waste = total
        
        return min_waste % MOD if min_waste != float('inf') else -1
```",Y,
minimum-skips-to-arrive-at-meeting-on-time,Minimum Skips to Arrive at Meeting On Time,"```python
from typing import List

class Solution:
    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:
        n = len(dist)
        INF = float('inf')
        dp = [[INF] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 0.0
        
        for i in range(1, n + 1):
            d = dist[i - 1]
            for j in range(i + 1):
                if j > 0:
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + d / speed)
                if j < i:
                    wait_time = math.ceil(dp[i - 1][j]) - dp[i - 1][j] if (dp[i - 1][j] % 1 != 0) else 0.0
                    dp[i][j] = min(dp[i][j], math.ceil(dp[i - 1][j] + wait_time) + d / speed)
        
        for skips in range(n + 1):
            if dp[n][skips] <= hoursBefore + 1e-9:
                return skips
        return -1
```",Y,
minimum-cost-to-change-the-final-value-of-expression,Minimum Cost to Change the Final Value of Expression,"```python
class Solution:
    def minOperationsToFlip(self, expression: str) -> int:
        stack = []
        ops = []
        
        for ch in expression:
            if ch in ('0', '1'):
                val = int(ch)
                stack.append((val, 1))
            elif ch == '(':
                ops.append(ch)
            elif ch == ')':
                while ops[-1] != '(':
                    op = ops.pop()
                    b_val, b_cost = stack.pop()
                    a_val, a_cost = stack.pop()
                    new_val, new_cost = self.combine(a_val, a_cost, b_val, b_cost, op)
                    stack.append((new_val, new_cost))
                ops.pop()  # Remove '('
            else:
                while ops and ops[-1] != '(':
                    op = ops.pop()
                    b_val, b_cost = stack.pop()
                    a_val, a_cost = stack.pop()
                    new_val, new_cost = self.combine(a_val, a_cost, b_val, b_cost, op)
                    stack.append((new_val, new_cost))
                ops.append(ch)
        
        while ops:
            op = ops.pop()
            b_val, b_cost = stack.pop()
            a_val, a_cost = stack.pop()
            new_val, new_cost = self.combine(a_val, a_cost, b_val, b_cost, op)
            stack.append((new_val, new_cost))
        
        final_val, final_cost = stack[-1]
        return final_cost if final_val == 1 else final_cost
    
    def combine(self, a_val, a_cost, b_val, b_cost, op):
        if op == '&':
            if a_val == 1 and b_val == 1:
                new_val = 1
                new_cost = min(a_cost, b_cost, 1 + min(a_cost, b_cost))
            elif a_val == 1 and b_val == 0:
                new_val = 0
                new_cost = 1
            elif a_val == 0 and b_val == 1:
                new_val = 0
                new_cost = 1
            else:  # 0 & 0
                new_val = 0
                new_cost = min(a_cost + b_cost, 1 + min(a_cost, b_cost))
        else:  # '|'
            if a_val == 1 and b_val == 1:
                new_val = 1
                new_cost = min(a_cost + b_cost, 1 + min(a_cost, b_cost))
            elif a_val == 1 and b_val == 0:
                new_val = 1
                new_cost = 1
            elif a_val == 0 and b_val == 1:
                new_val = 1
                new_cost = 1
            else:  # 0 | 0
                new_val = 0
                new_cost = min(a_cost, b_cost, 1 + min(a_cost, b_cost))
        return (new_val, new_cost)
```",Y,
stone-game-viii,Stone Game VIII,"```python
class Solution:
    def stoneGameVIII(self, stones: List[int]) -> int:
        n = len(stones)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + stones[i]
        
        dp = [0] * n
        dp[-1] = prefix[n]
        
        for i in range(n-2, 0, -1):
            dp[i] = max(dp[i+1], prefix[i+1] - dp[i+1])
        
        return dp[1]
```",Y,
number-of-ways-to-rearrange-sticks-with-k-sticks-visible,Number of Ways to Rearrange Sticks With K Sticks Visible,"```python
class Solution:
    def rearrangeSticks(self, n: int, k: int) -> int:
        MOD = 10**9 + 7
        dp = [[0] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, k + 1):
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] * (i - 1)) % MOD
        return dp[n][k]
```",Y,
minimum-xor-sum-of-two-arrays,Minimum XOR Sum of Two Arrays,"```python
class Solution:
    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        dp = [float('inf')] * (1 << n)
        dp[0] = 0
        
        for mask in range(1 << n):
            cnt = bin(mask).count('1')
            for j in range(n):
                if not (mask & (1 << j)):
                    next_mask = mask | (1 << j)
                    dp[next_mask] = min(dp[next_mask], dp[mask] + (nums1[cnt] ^ nums2[j]))
        
        return dp[(1 << n) - 1]
```",Y,
largest-color-value-in-a-directed-graph,Largest Color Value in a Directed Graph,"```python
from collections import deque

class Solution:
    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:
        n = len(colors)
        adj = [[] for _ in range(n)]
        in_degree = [0] * n
        
        for u, v in edges:
            adj[u].append(v)
            in_degree[v] += 1
        
        q = deque()
        for i in range(n):
            if in_degree[i] == 0:
                q.append(i)
        
        cnt = [[0] * 26 for _ in range(n)]
        for i in range(n):
            c = ord(colors[i]) - ord('a')
            cnt[i][c] += 1
        
        processed = 0
        max_color = 0
        
        while q:
            u = q.popleft()
            processed += 1
            max_color = max(max_color, max(cnt[u]))
            
            for v in adj[u]:
                for c in range(26):
                    cnt_v_new = cnt[u][c] + (1 if c == (ord(colors[v]) - ord('a')) else 0)
                    if cnt[v][c] < cnt_v_new:
                        cnt[v][c] = cnt_v_new
                in_degree[v] -= 1
                if in_degree[v] == 0:
                    q.append(v)
        
        return max_color if processed == n else -1
```",Y,
minimum-interval-to-include-each-query,Minimum Interval to Include Each Query,"```python
import heapq
from bisect import bisect_left

class Solution:
    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
        intervals.sort()
        queries_sorted = sorted((q, i) for i, q in enumerate(queries))
        res = [-1] * len(queries)
        heap = []
        ptr = 0
        
        for q, original_idx in queries_sorted:
            while ptr < len(intervals) and intervals[ptr][0] <= q:
                l, r = intervals[ptr]
                size = r - l + 1
                heapq.heappush(heap, (size, r))
                ptr += 1
            
            while heap and heap[0][1] < q:
                heapq.heappop(heap)
            
            if heap:
                res[original_idx] = heap[0][0]
        
        return res
```",Y,
maximum-building-height,Maximum Building Height,"```python
from typing import List

class Solution:
    def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:
        if not restrictions:
            return n - 1
        
        restrictions.append([1, 0])
        restrictions.sort()
        if restrictions[-1][0] != n:
            restrictions.append([n, float('inf')])
        
        for i in range(1, len(restrictions)):
            prev_id, prev_h = restrictions[i-1]
            curr_id, curr_h = restrictions[i]
            restrictions[i][1] = min(curr_h, prev_h + (curr_id - prev_id))
        
        for i in range(len(restrictions)-2, -1, -1):
            next_id, next_h = restrictions[i+1]
            curr_id, curr_h = restrictions[i]
            restrictions[i][1] = min(curr_h, next_h + (next_id - curr_id))
        
        max_height = 0
        for i in range(1, len(restrictions)):
            prev_id, prev_h = restrictions[i-1]
            curr_id, curr_h = restrictions[i]
            distance = curr_id - prev_id
            max_possible = max(prev_h, curr_h) + (distance - abs(prev_h - curr_h)) // 2
            max_height = max(max_height, max_possible)
        
        return max_height
```",Y,
find-xor-sum-of-all-pairs-bitwise-and,Find XOR Sum of All Pairs Bitwise AND,"```python
from typing import List

class Solution:
    def getXORSum(self, arr1: List[int], arr2: List[int]) -> int:
        xor1 = 0
        for num in arr1:
            xor1 ^= num
        
        xor2 = 0
        for num in arr2:
            xor2 ^= num
        
        return xor1 & xor2
```",Y,
closest-room,Closest Room,"```python
import bisect

class Solution:
    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:
        rooms.sort(key=lambda x: -x[1])
        
        sorted_queries = []
        for idx, (preferred, minSize) in enumerate(queries):
            sorted_queries.append((minSize, preferred, idx))
        sorted_queries.sort(reverse=True, key=lambda x: x[0])
        
        room_ids = []
        res = [-1] * len(queries)
        ptr = 0
        n = len(rooms)
        
        for minSize, preferred, original_idx in sorted_queries:
            while ptr < n and rooms[ptr][1] >= minSize:
                bisect.insort(room_ids, rooms[ptr][0])
                ptr += 1
            
            if not room_ids:
                res[original_idx] = -1
                continue
            
            pos = bisect.bisect_left(room_ids, preferred)
            candidates = []
            if pos > 0:
                candidates.append(room_ids[pos - 1])
            if pos < len(room_ids):
                candidates.append(room_ids[pos])
            
            min_diff = float('inf')
            best_id = -1
            for id in candidates:
                current_diff = abs(id - preferred)
                if current_diff < min_diff:
                    min_diff = current_diff
                    best_id = id
                elif current_diff == min_diff and id < best_id:
                    best_id = id
            res[original_idx] = best_id
        
        return res
```",Y,
finding-mk-average,Finding MK Average,"```python
import heapq
from collections import deque

class MKAverage:

    def __init__(self, m: int, k: int):
        self.m = m
        self.k = k
        self.stream = deque()
        self.min_heap = []
        self.max_heap = []
        self.mid_heap = []
        self.min_heap_removed = {}
        self.max_heap_removed = {}
        self.mid_heap_removed = {}
        self.sum_mid = 0
        self.count_mid = 0

    def addElement(self, num: int) -> None:
        self.stream.append(num)
        if len(self.stream) > self.m:
            removed = self.stream.popleft()
            if removed in self.min_heap_removed:
                self.min_heap_removed[removed] += 1
            else:
                self.min_heap_removed[removed] = 1
            if removed in self.max_heap_removed:
                self.max_heap_removed[removed] += 1
            else:
                self.max_heap_removed[removed] = 1
            if removed in self.mid_heap_removed:
                self.mid_heap_removed[removed] += 1
            else:
                self.mid_heap_removed[removed] = 1
        
        heapq.heappush(self.min_heap, num)
        heapq.heappush(self.max_heap, -num)
        
        if len(self.stream) <= self.m:
            return
        
        self._balance_heaps()

    def _balance_heaps(self):
        while self.min_heap and self.min_heap[0] in self.min_heap_removed:
            val = heapq.heappop(self.min_heap)
            self.min_heap_removed[val] -= 1
            if self.min_heap_removed[val] == 0:
                del self.min_heap_removed[val]
        
        while self.max_heap and -self.max_heap[0] in self.max_heap_removed:
            val = -heapq.heappop(self.max_heap)
            self.max_heap_removed[val] -= 1
            if self.max_heap_removed[val] == 0:
                del self.max_heap_removed[val]
        
        while len(self.min_heap) > self.k:
            val = heapq.heappop(self.min_heap)
            heapq.heappush(self.mid_heap, val)
            self.sum_mid += val
            self.count_mid += 1
        
        while len(self.max_heap) > self.k:
            val = -heapq.heappop(self.max_heap)
            heapq.heappush(self.mid_heap, val)
            self.sum_mid += val
            self.count_mid += 1
        
        while self.mid_heap and self.mid_heap[0] in self.mid_heap_removed:
            val = heapq.heappop(self.mid_heap)
            self.mid_heap_removed[val] -= 1
            if self.mid_heap_removed[val] == 0:
                del self.mid_heap_removed[val]
            self.sum_mid -= val
            self.count_mid -= 1

    def calculateMKAverage(self) -> int:
        if len(self.stream) < self.m:
            return -1
        
        self._balance_heaps()
        
        if self.count_mid == 0:
            return 0
        
        return self.sum_mid // self.count_mid


```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
number-of-different-subsequences-gcds,Number of Different Subsequences GCDs,"```python
import math
from typing import List

class Solution:
    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:
        max_num = max(nums) if nums else 0
        present = [False] * (max_num + 1)
        for num in nums:
            present[num] = True
        
        res = 0
        for x in range(1, max_num + 1):
            current_gcd = 0
            for multiple in range(x, max_num + 1, x):
                if present[multiple]:
                    current_gcd = math.gcd(current_gcd, multiple)
                    if current_gcd == x:
                        res += 1
                        break
        return res
```",Y,
minimum-number-of-operations-to-make-string-sorted,Minimum Number of Operations to Make String Sorted,"```python
class Solution:
    def makeStringSorted(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        fact = [1] * (n + 1)
        inv_fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i-1] * i % MOD
            inv_fact[i] = pow(fact[i], MOD-2, MOD)
        
        res = 0
        freq = [0] * 26
        for i in range(n-1, -1, -1):
            c = ord(s[i]) - ord('a')
            freq[c] += 1
            t = sum(freq[:c])
            temp = t * fact[n - i - 1] % MOD
            for k in range(26):
                temp = temp * inv_fact[freq[k]] % MOD
            res = (res + temp) % MOD
        return res
```",Y,
maximize-number-of-nice-divisors,Maximize Number of Nice Divisors,"```python
class Solution:
    def maxNiceDivisors(self, primeFactors: int) -> int:
        MOD = 10**9 + 7
        if primeFactors == 1:
            return 1
        q, r = divmod(primeFactors, 3)
        if r == 1 and q > 0:
            q -= 1
            r = 4
        elif r == 0:
            r = 1
        return pow(3, q, MOD) * r % MOD
```",Y,
maximum-number-of-groups-getting-fresh-donuts,Maximum Number of Groups Getting Fresh Donuts,"```python
from typing import List
from functools import lru_cache

class Solution:
    def maxHappyGroups(self, batchSize: int, groups: List[int]) -> int:
        count = [0] * batchSize
        for num in groups:
            remainder = num % batchSize
            if remainder != 0:
                count[remainder] += 1
        
        res = count[0]
        count[0] = 0
        
        for i in range(1, batchSize // 2 + 1):
            j = batchSize - i
            if i == j:
                res += count[i] // 2
                count[i] %= 2
            else:
                min_val = min(count[i], count[j])
                res += min_val
                count[i] -= min_val
                count[j] -= min_val
        
        @lru_cache(maxsize=None)
        def dfs(remainder, cnt_tuple):
            cnt = list(cnt_tuple)
            res = 0
            for i in range(1, batchSize):
                if cnt[i] == 0:
                    continue
                cnt[i] -= 1
                new_remainder = (remainder - i) % batchSize
                current = 1 if new_remainder == 0 else 0
                res = max(res, current + dfs(new_remainder, tuple(cnt)))
                cnt[i] += 1
            return res
        
        max_additional = dfs(0, tuple(count))
        return res + max_additional
```",Y,
maximum-score-of-a-good-subarray,Maximum Score of a Good Subarray,"```python
class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        left = right = k
        min_val = nums[k]
        max_score = min_val
        
        while left > 0 or right < len(nums) - 1:
            if left == 0:
                right += 1
            elif right == len(nums) - 1:
                left -= 1
            elif nums[left - 1] > nums[right + 1]:
                left -= 1
            else:
                right += 1
            min_val = min(min_val, nums[left], nums[right])
            max_score = max(max_score, min_val * (right - left + 1))
        
        return max_score
```",Y,
make-the-xor-of-all-segments-equal-to-zero,Make the XOR of All Segments Equal to Zero,"```python
from typing import List
from collections import defaultdict

class Solution:
    def minChanges(self, nums: List[int], k: int) -> int:
        n = len(nums)
        freq = [defaultdict(int) for _ in range(k)]
        for i in range(n):
            freq[i % k][nums[i]] += 1
        
        dp = [[float('inf')] * 1024 for _ in range(k)]
        for x in range(1024):
            total = sum(freq[0].values())
            cnt = total - freq[0].get(x, 0)
            dp[0][x] = cnt
        
        for i in range(1, k):
            min_prev = min(dp[i-1])
            for x in range(1024):
                dp[i][x] = min_prev + sum(freq[i].values())  # change all in group i
                for num in freq[i]:
                    new_x = x ^ num
                    if new_x < 1024:
                        cnt = sum(freq[i].values()) - freq[i][num]
                        dp[i][x] = min(dp[i][x], dp[i-1][new_x] + cnt)
        
        return dp[k-1][0]
```",Y,
count-pairs-with-xor-in-a-range,Count Pairs With XOR in a Range,"```python
class Solution:
    def countPairs(self, nums: List[int], low: int, high: int) -> int:
        class TrieNode:
            __slots__ = ['children', 'count']
            def __init__(self):
                self.children = [None, None]
                self.count = 0
        
        root = TrieNode()
        
        def insert(num):
            node = root
            for i in range(15, -1, -1):
                bit = (num >> i) & 1
                if not node.children[bit]:
                    node.children[bit] = TrieNode()
                node = node.children[bit]
                node.count += 1
        
        def query(num, limit):
            node = root
            res = 0
            for i in range(15, -1, -1):
                if not node:
                    break
                num_bit = (num >> i) & 1
                limit_bit = (limit >> i) & 1
                if limit_bit:
                    if node.children[num_bit]:
                        res += node.children[num_bit].count
                    node = node.children[1 - num_bit]
                else:
                    node = node.children[num_bit]
            return res
        
        res = 0
        for num in nums:
            res += query(num, high + 1) - query(num, low)
            insert(num)
        return res
```",Y,
maximize-score-after-n-operations,Maximize Score After N Operations,"```python
from typing import List
import math
from functools import lru_cache

class Solution:
    def maxScore(self, nums: List[int]) -> int:
        n = len(nums)
        
        @lru_cache(maxsize=None)
        def dfs(mask, step):
            if mask == (1 << n) - 1:
                return 0
            max_score = 0
            for i in range(n):
                if not (mask & (1 << i)):
                    for j in range(i + 1, n):
                        if not (mask & (1 << j)):
                            current_gcd = math.gcd(nums[i], nums[j])
                            current_score = step * current_gcd
                            new_mask = mask | (1 << i) | (1 << j)
                            remaining_score = dfs(new_mask, step + 1)
                            total_score = current_score + remaining_score
                            if total_score > max_score:
                                max_score = total_score
            return max_score
        
        return dfs(0, 1)
```",Y,
car-fleet-ii,Car Fleet II,"```python
class Solution:
    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:
        n = len(cars)
        res = [-1.0] * n
        stack = []
        
        for i in range(n-1, -1, -1):
            position, speed = cars[i]
            while stack:
                j = stack[-1]
                next_pos, next_speed = cars[j]
                if speed <= next_speed:
                    stack.pop()
                else:
                    collision_time = (next_pos - position) / (speed - next_speed)
                    if res[j] != -1 and collision_time >= res[j]:
                        stack.pop()
                    else:
                        res[i] = collision_time
                        break
            stack.append(i)
        
        return res
```",Y,
maximize-palindrome-length-from-subsequences,Maximize Palindrome Length From Subsequences,"```python
class Solution:
    def longestPalindrome(self, word1: str, word2: str) -> int:
        s = word1 + word2
        n = len(s)
        m1 = len(word1)
        dp = [[0] * n for _ in range(n)]
        max_len = 0
        
        for i in range(n-1, -1, -1):
            dp[i][i] = 1
            for j in range(i+1, n):
                if s[i] == s[j]:
                    dp[i][j] = 2 + dp[i+1][j-1] if i+1 <= j-1 else 2
                    if i < m1 and j >= m1:
                        max_len = max(max_len, dp[i][j])
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        
        return max_len
```",Y,
maximum-score-from-performing-multiplication-operations,Maximum Score from Performing Multiplication Operations,"```python
from typing import List

class Solution:
    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:
        m = len(multipliers)
        n = len(nums)
        dp = [[0] * (m + 1) for _ in range(m + 1)]
        
        for i in range(m - 1, -1, -1):
            for left in range(i, -1, -1):
                right = n - 1 - (i - left)
                dp[i][left] = max(
                    multipliers[i] * nums[left] + dp[i + 1][left + 1],
                    multipliers[i] * nums[right] + dp[i + 1][left]
                )
        
        return dp[0][0]
```",Y,
count-pairs-of-nodes,Count Pairs Of Nodes,"```python
from collections import defaultdict
from bisect import bisect_right

class Solution:
    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:
        degree = [0] * (n + 1)
        edge_count = defaultdict(int)
        
        for u, v in edges:
            if u > v:
                u, v = v, u
            degree[u] += 1
            degree[v] += 1
            edge_count[(u, v)] += 1
        
        sorted_degree = sorted(degree[1:])
        res = []
        
        for q in queries:
            total = 0
            left, right = 1, n
            while left < right:
                if sorted_degree[left - 1] + sorted_degree[right - 1] > q:
                    total += right - left
                    right -= 1
                else:
                    left += 1
            
            for (u, v), cnt in edge_count.items():
                if degree[u] + degree[v] > q and degree[u] + degree[v] - cnt <= q:
                    total -= 1
            
            res.append(total)
        
        return res
```",Y,
minimum-degree-of-a-connected-trio-in-a-graph,Minimum Degree of a Connected Trio in a Graph,"```python
class Solution:
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        graph = [set() for _ in range(n + 1)]
        degree = [0] * (n + 1)
        
        for u, v in edges:
            graph[u].add(v)
            graph[v].add(u)
            degree[u] += 1
            degree[v] += 1
        
        min_degree = float('inf')
        
        for u in range(1, n + 1):
            neighbors = graph[u]
            for v in neighbors:
                if v <= u:
                    continue
                common_neighbors = neighbors & graph[v]
                for w in common_neighbors:
                    if w <= v:
                        continue
                    trio_degree = degree[u] + degree[v] + degree[w] - 6
                    if trio_degree < min_degree:
                        min_degree = trio_degree
                        if min_degree == 0:
                            return 0
        
        return min_degree if min_degree != float('inf') else -1
```",Y,
closest-subsequence-sum,Closest Subsequence Sum,"```python
class Solution:
    def minAbsDifference(self, nums: List[int], goal: int) -> int:
        n = len(nums)
        half = n // 2
        
        def generate_sums(arr):
            sums = {0}
            for num in arr:
                new_sums = set()
                for s in sums:
                    new_sums.add(s + num)
                sums.update(new_sums)
            return sorted(sums)
        
        left_sums = generate_sums(nums[:half])
        right_sums = generate_sums(nums[half:])
        
        min_diff = float('inf')
        
        for s in left_sums:
            remaining = goal - s
            idx = bisect.bisect_left(right_sums, remaining)
            if idx < len(right_sums):
                min_diff = min(min_diff, abs(remaining - right_sums[idx]))
            if idx > 0:
                min_diff = min(min_diff, abs(remaining - right_sums[idx-1]))
            if min_diff == 0:
                return 0
        return min_diff
```",Y,
tree-of-coprimes,Tree of Coprimes,"```python
import math
from collections import defaultdict, deque
from typing import List

class Solution:
    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:
        n = len(nums)
        tree = defaultdict(list)
        for u, v in edges:
            tree[u].append(v)
            tree[v].append(u)
        
        ans = [-1] * n
        stack = [[] for _ in range(51)]  # nums[i] is up to 50
        visited = [False] * n
        
        q = deque()
        q.append((0, -1, 0))  # (node, parent, depth)
        visited[0] = True
        
        while q:
            node, parent, depth = q.popleft()
            current_val = nums[node]
            best_depth = -1
            best_ancestor = -1
            
            for val in range(1, 51):
                if stack[val] and math.gcd(val, current_val) == 1:
                    last_node, last_depth = stack[val][-1]
                    if last_depth > best_depth:
                        best_depth = last_depth
                        best_ancestor = last_node
            
            ans[node] = best_ancestor
            stack[current_val].append((node, depth))
            
            for neighbor in tree[node]:
                if not visited[neighbor] and neighbor != parent:
                    visited[neighbor] = True
                    q.append((neighbor, node, depth + 1))
            
            stack[current_val].pop()
        
        return ans
```",Y,
palindrome-partitioning-iv,Palindrome Partitioning IV,"```python
class Solution:
    def checkPartitioning(self, s: str) -> bool:
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        
        for i in range(n-1, -1, -1):
            for j in range(i, n):
                if s[i] == s[j]:
                    if j - i <= 2 or dp[i+1][j-1]:
                        dp[i][j] = True
        
        for i in range(1, n-1):
            for j in range(i, n-1):
                if dp[0][i-1] and dp[i][j] and dp[j+1][n-1]:
                    return True
        return False
```",Y,
building-boxes,Building Boxes,"```python
class Solution:
    def minimumBoxes(self, n: int) -> int:
        if n == 0:
            return 0
        
        k = 0
        total = 0
        while True:
            next_total = (k + 1) * (k + 2) * (k + 3) // 6
            if next_total > n:
                break
            k += 1
            total = next_total
        
        remaining = n - total
        if remaining == 0:
            return k * (k + 1) // 2
        
        m = int((2 * remaining) ** 0.5)
        while m * (m + 1) // 2 < remaining:
            m += 1
        
        return k * (k + 1) // 2 + m
```",Y,
maximum-number-of-events-that-can-be-attended-ii,Maximum Number of Events That Can Be Attended II,"```python
import bisect
from typing import List

class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        events.sort()
        n = len(events)
        starts = [event[0] for event in events]
        
        dp = [[-1] * (k + 1) for _ in range(n)]
        
        def dfs(cur_index, count):
            if count == 0 or cur_index == n:
                return 0
            if dp[cur_index][count] != -1:
                return dp[cur_index][count]
            
            max_val = dfs(cur_index + 1, count)
            
            next_index = bisect.bisect_right(starts, events[cur_index][1])
            current_value = events[cur_index][2]
            max_val = max(max_val, current_value + dfs(next_index, count - 1))
            
            dp[cur_index][count] = max_val
            return max_val
        
        return dfs(0, k)
```",Y,
count-ways-to-make-array-with-product,Count Ways to Make Array With Product,"```python
import math
from math import comb
from collections import defaultdict

MOD = 10**9 + 7

class Solution:
    def waysToFillArray(self, queries: List[List[int]]) -> List[int]:
        max_k = max(q[1] for q in queries) if queries else 0
        spf = list(range(max_k + 1))
        for i in range(2, int(math.isqrt(max_k)) + 1):
            if spf[i] == i:
                for j in range(i*i, max_k + 1, i):
                    if spf[j] == j:
                        spf[j] = i
        
        def factorize(x):
            factors = defaultdict(int)
            if x == 1:
                return factors
            while x > 1:
                p = spf[x]
                while x % p == 0:
                    factors[p] += 1
                    x = x // p
            return factors
        
        factorizations = {}
        for q in queries:
            k = q[1]
            if k not in factorizations:
                factorizations[k] = factorize(k)
        
        res = []
        for n, k in queries:
            if k == 1:
                res.append(1)
                continue
            factors = factorizations[k]
            total = 1
            for cnt in factors.values():
                total = total * comb(n + cnt - 1, cnt) % MOD
            res.append(total)
        return res
```",Y,
minimum-operations-to-make-a-subsequence,Minimum Operations to Make a Subsequence,"```python
import bisect
from typing import List

class Solution:
    def minOperations(self, target: List[int], arr: List[int]) -> int:
        value_to_index = {v: i for i, v in enumerate(target)}
        indices = []
        for num in arr:
            if num in value_to_index:
                idx = value_to_index[num]
                pos = bisect.bisect_left(indices, idx)
                if pos == len(indices):
                    indices.append(idx)
                else:
                    indices[pos] = idx
        return len(target) - len(indices)
```",Y,
maximum-xor-with-an-element-from-array,Maximum XOR With an Element From Array,"```python
class Solution:
    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        nums.sort()
        sorted_queries = sorted([(x, m, i) for i, (x, m) in enumerate(queries)], key=lambda q: q[1])
        
        trie = {}
        res = [-1] * len(queries)
        ptr = 0
        
        for x, m, idx in sorted_queries:
            while ptr < len(nums) and nums[ptr] <= m:
                num = nums[ptr]
                node = trie
                for i in range(30, -1, -1):
                    bit = (num >> i) & 1
                    if bit not in node:
                        node[bit] = {}
                    node = node[bit]
                ptr += 1
            
            if not trie:
                continue
            
            node = trie
            max_xor = 0
            for i in range(30, -1, -1):
                bit = (x >> i) & 1
                toggled_bit = 1 - bit
                if toggled_bit in node:
                    max_xor += (1 << i)
                    node = node[toggled_bit]
                else:
                    node = node.get(bit, {})
            res[idx] = max_xor
        
        return res
```",Y,
find-minimum-time-to-finish-all-jobs,Find Minimum Time to Finish All Jobs,"```python
class Solution:
    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:
        workers = [0] * k
        self.res = float('inf')
        jobs.sort(reverse=True)
        
        def dfs(index):
            if index == len(jobs):
                self.res = min(self.res, max(workers))
                return
            for i in range(k):
                if workers[i] + jobs[index] >= self.res:
                    continue
                workers[i] += jobs[index]
                dfs(index + 1)
                workers[i] -= jobs[index]
                if workers[i] == 0:
                    break
        dfs(0)
        return self.res
```",Y,
number-of-ways-to-reconstruct-a-tree,Number Of Ways To Reconstruct A Tree,"```python
from collections import defaultdict

class Solution:
    def checkWays(self, pairs: List[List[int]]) -> int:
        adj = defaultdict(set)
        nodes = set()
        for x, y in pairs:
            adj[x].add(y)
            adj[y].add(x)
            nodes.add(x)
            nodes.add(y)
        
        root = -1
        for node in nodes:
            if len(adj[node]) == len(nodes) - 1:
                root = node
                break
        if root == -1:
            return 0
        
        res = 1
        for node in nodes:
            if node == root:
                continue
            parent = -1
            parent_degree = float('inf')
            for neighbor in adj[node]:
                if len(adj[neighbor]) < parent_degree and len(adj[neighbor]) >= len(adj[node]):
                    parent = neighbor
                    parent_degree = len(adj[neighbor])
            if parent == -1:
                return 0
            for neighbor in adj[node]:
                if neighbor != parent and neighbor not in adj[parent]:
                    return 0
            if parent_degree == len(adj[node]):
                res = 2
        return res
```",Y,
checking-existence-of-edge-length-limited-paths,Checking Existence of Edge Length Limited Paths,"```python
class Solution:
    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:
        parent = list(range(n))
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root != v_root:
                parent[v_root] = u_root
        
        edgeList.sort(key=lambda x: x[2])
        
        indexed_queries = [(i, p, q, limit) for i, (p, q, limit) in enumerate(queries)]
        indexed_queries.sort(key=lambda x: x[3])
        
        answer = [False] * len(queries)
        edge_idx = 0
        m = len(edgeList)
        
        for i, p, q, limit in indexed_queries:
            while edge_idx < m and edgeList[edge_idx][2] < limit:
                u, v, _ = edgeList[edge_idx]
                union(u, v)
                edge_idx += 1
            answer[i] = (find(p) == find(q))
        
        return answer
```",Y,
minimum-adjacent-swaps-for-k-consecutive-ones,Minimum Adjacent Swaps for K Consecutive Ones,"```python
from typing import List

class Solution:
    def minMoves(self, nums: List[int], k: int) -> int:
        ones = [i for i, num in enumerate(nums) if num == 1]
        n = len(ones)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i+1] = prefix[i] + ones[i]
        
        res = float('inf')
        radius = (k - 1) // 2
        
        for i in range(n - k + 1):
            j = i + k - 1
            mid = (i + j) // 2
            left = ones[mid] * (mid - i) - (prefix[mid] - prefix[i])
            right = (prefix[j+1] - prefix[mid+1]) - ones[mid] * (j - mid)
            total = left + right
            if k % 2 == 0:
                total += ones[mid+1] - ones[mid] - 1
                total -= radius
            res = min(res, total)
        
        return res
```",Y,
minimum-incompatibility,Minimum Incompatibility,"```python
from typing import List
from itertools import combinations
from collections import defaultdict

class Solution:
    def minimumIncompatibility(self, nums: List[int], k: int) -> int:
        n = len(nums)
        m = n // k
        freq = defaultdict(int)
        for num in nums:
            freq[num] += 1
            if freq[num] > k:
                return -1
        
        nums_sorted = sorted(nums)
        used = [False] * n
        self.res = float('inf')
        
        def backtrack(start, groups, current_sum):
            if len(groups) == k:
                self.res = min(self.res, current_sum)
                return
            if current_sum >= self.res:
                return
            
            if not groups or len(groups[-1]) == m:
                for i in range(n):
                    if not used[i]:
                        used[i] = True
                        backtrack(i + 1, groups + [[nums_sorted[i]]], current_sum)
                        used[i] = False
                        break
            else:
                last_group = groups[-1]
                last_num = last_group[-1]
                prev = -1
                for i in range(start, n):
                    if not used[i] and nums_sorted[i] > last_num and nums_sorted[i] != prev:
                        prev = nums_sorted[i]
                        used[i] = True
                        new_group = last_group + [nums_sorted[i]]
                        new_sum = current_sum + (new_group[-1] - new_group[0]) if len(new_group) == m else current_sum
                        backtrack(i + 1, groups[:-1] + [new_group], new_sum)
                        used[i] = False
        
        backtrack(0, [], 0)
        return self.res if self.res != float('inf') else -1
```",Y,
minimize-deviation-in-array,Minimize Deviation in Array,"```python
import heapq

class Solution:
    def minimumDeviation(self, nums: List[int]) -> int:
        max_heap = []
        min_val = float('inf')
        
        for num in nums:
            if num % 2 == 1:
                num *= 2
            heapq.heappush(max_heap, -num)
            min_val = min(min_val, num)
        
        min_deviation = float('inf')
        
        while True:
            current_max = -heapq.heappop(max_heap)
            min_deviation = min(min_deviation, current_max - min_val)
            
            if current_max % 2 == 1:
                break
            
            new_num = current_max // 2
            min_val = min(min_val, new_num)
            heapq.heappush(max_heap, -new_num)
        
        return min_deviation
```",Y,
delivering-boxes-from-storage-to-ports,Delivering Boxes from Storage to Ports,"```python
from typing import List

class Solution:
    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:
        n = len(boxes)
        dp = [0] * (n + 1)
        left = 0
        total_weight = 0
        trips = 0
        
        for right in range(n):
            if right == 0 or boxes[right][0] != boxes[right-1][0]:
                trips += 1
            total_weight += boxes[right][1]
            
            while (right - left + 1) > maxBoxes or total_weight > maxWeight or (left < right and dp[left] == dp[left + 1]):
                total_weight -= boxes[left][1]
                if boxes[left][0] != boxes[left + 1][0]:
                    trips -= 1
                left += 1
            
            dp[right + 1] = dp[left] + trips + 1
        
        return dp[n]
```",Y,
minimum-initial-energy-to-finish-tasks,Minimum Initial Energy to Finish Tasks,"```python
from typing import List

class Solution:
    def minimumEffort(self, tasks: List[List[int]]) -> int:
        tasks.sort(key=lambda x: (x[1] - x[0]))
        res = 0
        curr_energy = 0
        for actual, minimum in tasks:
            if curr_energy < minimum:
                res += minimum - curr_energy
                curr_energy = minimum
            curr_energy -= actual
        return res
```",Y,
maximize-grid-happiness,Maximize Grid Happiness,"```python
class Solution:
    def getMaxGridHappiness(self, m: int, n: int, introvertsCount: int, extrovertsCount: int) -> int:
        from functools import lru_cache
        
        total_positions = m * n
        neighbors = [(0, -1), (-1, 0)]
        
        @lru_cache(maxsize=None)
        def dp(position, intro_remain, extro_remain, prev_n):
            if position == total_positions or (intro_remain == 0 and extro_remain == 0):
                return 0
            
            row, col = position // n, position % n
            res = dp(position + 1, intro_remain, extro_remain, prev_n[1:] + (0,))
            
            if intro_remain > 0:
                temp = 120
                up = prev_n[0] if row > 0 else 0
                left = prev_n[-1] if col > 0 else 0
                for neighbor in (up, left):
                    if neighbor == 1:  # introvert neighbor
                        temp -= 30
                    elif neighbor == 2:  # extrovert neighbor
                        temp -= 30
                for neighbor in (up, left):
                    if neighbor == 1:  # introvert neighbor
                        temp -= 30
                    elif neighbor == 2:  # extrovert neighbor
                        temp += 20
                new_prev_n = prev_n[1:] + (1,)
                res = max(res, temp + dp(position + 1, intro_remain - 1, extro_remain, new_prev_n))
            
            if extro_remain > 0:
                temp = 40
                up = prev_n[0] if row > 0 else 0
                left = prev_n[-1] if col > 0 else 0
                for neighbor in (up, left):
                    if neighbor == 1:  # introvert neighbor
                        temp += 20
                    elif neighbor == 2:  # extrovert neighbor
                        temp += 20
                new_prev_n = prev_n[1:] + (2,)
                res = max(res, temp + dp(position + 1, intro_remain, extro_remain - 1, new_prev_n))
            
            return res
        
        return dp(0, introvertsCount, extrovertsCount, tuple([0] * n))
```",Y,
create-sorted-array-through-instructions,Create Sorted Array through Instructions,"```python
import bisect

class Solution:
    def createSortedArray(self, instructions: List[int]) -> int:
        nums = []
        total_cost = 0
        mod = 10**9 + 7
        
        for num in instructions:
            left = bisect.bisect_left(nums, num)
            right = bisect.bisect_right(nums, num)
            cost = min(left, len(nums) - right)
            total_cost = (total_cost + cost) % mod
            bisect.insort(nums, num)
        
        return total_cost
```",Y,
minimum-number-of-removals-to-make-mountain-array,Minimum Number of Removals to Make Mountain Array,"```python
from typing import List

class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        n = len(nums)
        left = [1] * n
        right = [1] * n
        
        for i in range(1, n):
            for j in range(i):
                if nums[j] < nums[i]:
                    left[i] = max(left[i], left[j] + 1)
        
        for i in range(n-2, -1, -1):
            for j in range(n-1, i, -1):
                if nums[j] < nums[i]:
                    right[i] = max(right[i], right[j] + 1)
        
        max_len = 0
        for i in range(1, n-1):
            if left[i] > 1 and right[i] > 1:
                max_len = max(max_len, left[i] + right[i] - 1)
        
        return n - max_len
```",Y,
distribute-repeating-integers,Distribute Repeating Integers,"```python
from collections import Counter
from typing import List

class Solution:
    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:
        freq = list(Counter(nums).values())
        quantity.sort(reverse=True)
        
        def backtrack(index: int) -> bool:
            if index == len(quantity):
                return True
            for i in range(len(freq)):
                if freq[i] >= quantity[index]:
                    freq[i] -= quantity[index]
                    if backtrack(index + 1):
                        return True
                    freq[i] += quantity[index]
            return False
        
        return backtrack(0)
```",Y,
number-of-ways-to-form-a-target-string-given-a-dictionary,Number of Ways to Form a Target String Given a Dictionary,"```python
class Solution:
    def numWays(self, words: List[str], target: str) -> int:
        MOD = 10**9 + 7
        word_len = len(words[0])
        target_len = len(target)
        
        freq = [[0] * 26 for _ in range(word_len)]
        for word in words:
            for i, c in enumerate(word):
                freq[i][ord(c) - ord('a')] += 1
        
        dp = [[0] * (word_len + 1) for _ in range(target_len + 1)]
        dp[0][0] = 1
        
        for i in range(target_len + 1):
            for k in range(word_len + 1):
                if i == 0 and k == 0:
                    continue
                if i == 0:
                    dp[i][k] = 1
                elif k == 0:
                    dp[i][k] = 0
                else:
                    dp[i][k] = dp[i][k-1]
                    if i > 0 and k > 0:
                        c = target[i-1]
                        cnt = freq[k-1][ord(c) - ord('a')]
                        dp[i][k] += dp[i-1][k-1] * cnt
                    dp[i][k] %= MOD
        
        return dp[target_len][word_len]
```",Y,
count-subtrees-with-max-distance-between-cities,Count Subtrees With Max Distance Between Cities,"```python
from typing import List
from collections import deque

class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        adj = [[] for _ in range(n)]
        for u, v in edges:
            u -= 1
            v -= 1
            adj[u].append(v)
            adj[v].append(u)
        
        res = [0] * (n - 1)
        
        for mask in range(1, 1 << n):
            nodes = []
            for i in range(n):
                if mask & (1 << i):
                    nodes.append(i)
            if len(nodes) < 2:
                continue
            
            visited = 0
            q = deque()
            q.append(nodes[0])
            visited |= 1 << nodes[0]
            
            while q:
                u = q.popleft()
                for v in adj[u]:
                    if (mask & (1 << v)) and not (visited & (1 << v)):
                        visited |= 1 << v
                        q.append(v)
            
            if visited != mask:
                continue
            
            max_dist = 0
            for start in nodes:
                dist = [-1] * n
                q = deque()
                q.append(start)
                dist[start] = 0
                while q:
                    u = q.popleft()
                    for v in adj[u]:
                        if (mask & (1 << v)) and dist[v] == -1:
                            dist[v] = dist[u] + 1
                            q.append(v)
                current_max = max(d for d in dist if d != -1)
                if current_max > max_dist:
                    max_dist = current_max
            
            if max_dist > 0:
                res[max_dist - 1] += 1
        
        return res
```",Y,
maximum-number-of-visible-points,Maximum Number of Visible Points,"```python
import math
from bisect import bisect_right
from typing import List

class Solution:
    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:
        pos_x, pos_y = location
        angles = []
        same = 0
        
        for x, y in points:
            dx = x - pos_x
            dy = y - pos_y
            if dx == 0 and dy == 0:
                same += 1
                continue
            rad = math.atan2(dy, dx)
            deg = math.degrees(rad)
            angles.append(deg)
        
        angles.sort()
        angles += [deg + 360 for deg in angles]
        max_count = 0
        right = 0
        n = len(angles)
        if n == 0:
            return same
        
        for left in range(n // 2):
            while right < n and angles[right] - angles[left] <= angle + 1e-9:
                right += 1
            max_count = max(max_count, right - left)
        
        return max_count + same
```",Y,
minimum-one-bit-operations-to-make-integers-zero,Minimum One Bit Operations to Make Integers Zero,"```python
class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        res = 0
        while n > 0:
            res ^= n
            n >>= 1
        return res
```",Y,
fancy-sequence,Fancy Sequence,"```python
MOD = 10**9 + 7

class Fancy:

    def __init__(self):
        self.sequence = []
        self.add = 0
        self.mul = 1

    def append(self, val: int) -> None:
        adjusted_val = (val - self.add) * pow(self.mul, -1, MOD) % MOD
        self.sequence.append(adjusted_val)

    def addAll(self, inc: int) -> None:
        self.add = (self.add + inc) % MOD

    def multAll(self, m: int) -> None:
        self.add = (self.add * m) % MOD
        self.mul = (self.mul * m) % MOD

    def getIndex(self, idx: int) -> int:
        if idx >= len(self.sequence):
            return -1
        return (self.sequence[idx] * self.mul + self.add) % MOD
```",E,生成的代码不包含预期函数名 '__init__'或类名不正确
cat-and-mouse-ii,Cat and Mouse II,"```python
from typing import List
from functools import lru_cache

class Solution:
    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:
        rows = len(grid)
        cols = len(grid[0]) if rows > 0 else 0
        
        cat_pos = None
        mouse_pos = None
        food_pos = None
        for i in range(rows):
            for j in range(cols):
                if grid[i][j] == 'C':
                    cat_pos = (i, j)
                elif grid[i][j] == 'M':
                    mouse_pos = (i, j)
                elif grid[i][j] == 'F':
                    food_pos = (i, j)
        
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        @lru_cache(maxsize=None)
        def dfs(turn, cat, mouse):
            if turn > 100:
                return False
            if cat == mouse:
                return False
            if cat == food_pos:
                return False
            if mouse == food_pos:
                return True
            
            if turn % 2 == 0:  # Mouse's turn
                i, j = mouse
                for di, dj in directions:
                    for step in range(1, mouseJump + 1):
                        ni, nj = i + di * step, j + dj * step
                        if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] != '#':
                            if dfs(turn + 1, cat, (ni, nj)):
                                return True
                        else:
                            break
                if dfs(turn + 1, cat, mouse):
                    return True
                return False
            else:  # Cat's turn
                i, j = cat
                for di, dj in directions:
                    for step in range(1, catJump + 1):
                        ni, nj = i + di * step, j + dj * step
                        if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] != '#':
                            if not dfs(turn + 1, (ni, nj), mouse):
                                return False
                        else:
                            break
                if not dfs(turn + 1, cat, mouse):
                    return False
                return True
        
        return dfs(0, cat_pos, mouse_pos)
```",Y,
maximum-number-of-achievable-transfer-requests,Maximum Number of Achievable Transfer Requests,"```python
from typing import List

class Solution:
    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:
        max_requests = 0
        m = len(requests)
        
        for mask in range(1 << m):
            count = bin(mask).count('1')
            if count <= max_requests:
                continue
            
            balance = [0] * n
            for i in range(m):
                if mask & (1 << i):
                    from_b, to_b = requests[i]
                    balance[from_b] -= 1
                    balance[to_b] += 1
            
            if all(b == 0 for b in balance):
                max_requests = count
        
        return max_requests
```",Y,
minimum-cost-to-connect-two-groups-of-points,Minimum Cost to Connect Two Groups of Points,"```python
class Solution:
    def connectTwoGroups(self, cost: List[List[int]]) -> int:
        size1, size2 = len(cost), len(cost[0])
        min_cost2 = [min(cost[i][j] for i in range(size1)) for j in range(size2)]
        
        dp = [[float('inf')] * (1 << size2) for _ in range(size1 + 1)]
        dp[0][0] = 0
        
        for i in range(1, size1 + 1):
            for mask in range(1 << size2):
                for j in range(size2):
                    new_mask = mask | (1 << j)
                    if dp[i - 1][mask] + cost[i - 1][j] < dp[i][new_mask]:
                        dp[i][new_mask] = dp[i - 1][mask] + cost[i - 1][j]
                if dp[i - 1][mask] + min_cost2[j] < dp[i][mask]:
                    dp[i][mask] = dp[i - 1][mask] + min_cost2[j]
        
        return dp[size1][(1 << size2) - 1]
```",Y,
find-servers-that-handled-most-number-of-requests,Find Servers That Handled Most Number of Requests,"```python
import heapq
from typing import List

class Solution:
    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
        available = list(range(k))
        heapq.heapify(available)
        busy = []
        count = [0] * k
        
        for i, (start, duration) in enumerate(zip(arrival, load)):
            while busy and busy[0][0] <= start:
                _, server = heapq.heappop(busy)
                heapq.heappush(available, server)
            
            if not available:
                continue
            
            idx = i % k
            temp = []
            found = None
            while available:
                server = heapq.heappop(available)
                temp.append(server)
                if server >= idx:
                    found = server
                    break
            for server in temp:
                if server != found:
                    heapq.heappush(available, server)
            
            if found is not None:
                selected = found
            else:
                selected = heapq.heappop(available)
            
            count[selected] += 1
            heapq.heappush(busy, (start + duration, selected))
        
        max_requests = max(count)
        return [i for i, c in enumerate(count) if c == max_requests]
```",Y,
check-if-string-is-transformable-with-substring-sort-operations,Check If String Is Transformable With Substring Sort Operations,"```python
from collections import defaultdict, deque

class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if sorted(s) != sorted(t):
            return False
        
        pos = defaultdict(deque)
        for idx, ch in enumerate(s):
            pos[int(ch)].append(idx)
        
        for ch in t:
            d = int(ch)
            if not pos[d]:
                return False
            for smaller in range(d):
                if pos[smaller] and pos[smaller][0] < pos[d][0]:
                    return False
            pos[d].popleft()
        
        return True
```",Y,
remove-max-number-of-edges-to-keep-graph-fully-traversable,Remove Max Number of Edges to Keep Graph Fully Traversable,"```python
class Solution:
    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
        parent_alice = list(range(n + 1))
        parent_bob = list(range(n + 1))
        
        def find(parent, x):
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x
        
        def union(parent, x, y):
            x_root = find(parent, x)
            y_root = find(parent, y)
            if x_root == y_root:
                return False
            parent[y_root] = x_root
            return True
        
        edges.sort(reverse=True)
        removed = 0
        alice_components = n
        bob_components = n
        
        for typ, u, v in edges:
            if typ == 3:
                alice_union = union(parent_alice, u, v)
                bob_union = union(parent_bob, u, v)
                if alice_union and bob_union:
                    alice_components -= 1
                    bob_components -= 1
                elif not alice_union and not bob_union:
                    removed += 1
            elif typ == 2:
                if union(parent_bob, u, v):
                    bob_components -= 1
                else:
                    removed += 1
            elif typ == 1:
                if union(parent_alice, u, v):
                    alice_components -= 1
                else:
                    removed += 1
        
        if alice_components != 1 or bob_components != 1:
            return -1
        return removed
```",Y,
strange-printer-ii,Strange Printer II,"```python
from typing import List

class Solution:
    def isPrintable(self, targetGrid: List[List[int]]) -> bool:
        m = len(targetGrid)
        n = len(targetGrid[0]) if m > 0 else 0
        
        color_rect = {}
        
        for i in range(m):
            for j in range(n):
                color = targetGrid[i][j]
                if color not in color_rect:
                    color_rect[color] = [i, i, j, j]  # min_row, max_row, min_col, max_col
                else:
                    rect = color_rect[color]
                    rect[0] = min(rect[0], i)
                    rect[1] = max(rect[1], i)
                    rect[2] = min(rect[2], j)
                    rect[3] = max(rect[3], j)
        
        graph = {}
        colors = color_rect.keys()
        
        for color in colors:
            graph[color] = set()
        
        for color in colors:
            min_row, max_row, min_col, max_col = color_rect[color]
            for i in range(min_row, max_row + 1):
                for j in range(min_col, max_col + 1):
                    other_color = targetGrid[i][j]
                    if other_color != color:
                        graph[other_color].add(color)
        
        visited = {}
        recursion_stack = {}
        
        def has_cycle(node):
            visited[node] = True
            recursion_stack[node] = True
            for neighbor in graph[node]:
                if neighbor not in visited:
                    if has_cycle(neighbor):
                        return True
                elif recursion_stack[neighbor]:
                    return True
            recursion_stack[node] = False
            return False
        
        for node in graph:
            if node not in visited:
                if has_cycle(node):
                    return False
        return True
```",Y,
number-of-ways-to-reorder-array-to-get-same-bst,Number of Ways to Reorder Array to Get Same BST,"```python
import math
from typing import List

class Solution:
    def numOfWays(self, nums: List[int]) -> int:
        mod = 10**9 + 7
        
        def dfs(nums):
            if len(nums) <= 2:
                return 1
            root = nums[0]
            left = [x for x in nums if x < root]
            right = [x for x in nums if x > root]
            m = len(left)
            n = len(right)
            left_ways = dfs(left)
            right_ways = dfs(right)
            return math.comb(m + n, m) * left_ways * right_ways % mod
        
        return (dfs(nums) - 1) % mod
```",Y,
minimum-number-of-days-to-disconnect-island,Minimum Number of Days to Disconnect Island,"```python
from typing import List

class Solution:
    def minDays(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        
        def count_islands():
            visited = [[False for _ in range(n)] for _ in range(m)]
            count = 0
            for i in range(m):
                for j in range(n):
                    if grid[i][j] == 1 and not visited[i][j]:
                        count += 1
                        if count > 1:
                            return count
                        stack = [(i, j)]
                        visited[i][j] = True
                        while stack:
                            x, y = stack.pop()
                            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                                nx, ny = x + dx, y + dy
                                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and not visited[nx][ny]:
                                    visited[nx][ny] = True
                                    stack.append((nx, ny))
            return count
        
        islands = count_islands()
        if islands != 1:
            return 0
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    grid[i][j] = 0
                    islands = count_islands()
                    grid[i][j] = 1
                    if islands != 1:
                        return 1
        
        return 2
```",Y,
stone-game-v,Stone Game V,"```python
class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        n = len(stoneValue)
        prefix = [0] * (n + 1)
        for i in range(n):
            prefix[i + 1] = prefix[i] + stoneValue[i]
        
        memo = [[-1 for _ in range(n)] for __ in range(n)]
        
        def dfs(left, right):
            if left == right:
                return 0
            if memo[left][right] != -1:
                return memo[left][right]
            
            res = 0
            for k in range(left, right):
                left_sum = prefix[k + 1] - prefix[left]
                right_sum = prefix[right + 1] - prefix[k + 1]
                
                if left_sum < right_sum:
                    res = max(res, left_sum + dfs(left, k))
                elif left_sum > right_sum:
                    res = max(res, right_sum + dfs(k + 1, right))
                else:
                    res = max(res, left_sum + max(dfs(left, k), dfs(k + 1, right)))
            
            memo[left][right] = res
            return res
        
        return dfs(0, n - 1)
```",Y,
count-all-possible-routes,Count All Possible Routes,"```python
class Solution:
    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:
        MOD = 10**9 + 7
        n = len(locations)
        dp = [[0] * n for _ in range(fuel + 1)]
        dp[0][start] = 1
        
        for f in range(fuel + 1):
            for i in range(n):
                if dp[f][i] == 0:
                    continue
                for j in range(n):
                    if i == j:
                        continue
                    cost = abs(locations[i] - locations[j])
                    if f + cost <= fuel:
                        dp[f + cost][j] = (dp[f + cost][j] + dp[f][i]) % MOD
        
        total = 0
        for f in range(fuel + 1):
            total = (total + dp[f][finish]) % MOD
        return total
```",Y,
minimum-number-of-days-to-eat-n-oranges,Minimum Number of Days to Eat N Oranges,"```python
from functools import lru_cache

class Solution:
    def minDays(self, n: int) -> int:
        @lru_cache(maxsize=None)
        def dfs(m):
            if m <= 1:
                return m
            return 1 + min(
                m % 2 + dfs(m // 2),
                m % 3 + dfs(m // 3)
        return dfs(n)
```",Y,
minimum-cost-to-cut-a-stick,Minimum Cost to Cut a Stick,"```python
from typing import List

class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        cuts = sorted(cuts)
        cuts = [0] + cuts + [n]
        m = len(cuts)
        dp = [[0] * m for _ in range(m)]
        
        for length in range(2, m):
            for i in range(m - length):
                j = i + length
                dp[i][j] = float('inf')
                for k in range(i + 1, j):
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])
        
        return dp[0][m - 1]
```",Y,
find-longest-awesome-substring,Find Longest Awesome Substring,"```python
class Solution:
    def longestAwesome(self, s: str) -> int:
        mask = 0
        mask_dict = {0: -1}
        max_len = 1
        
        for i, ch in enumerate(s):
            digit = ord(ch) - ord('0')
            mask ^= 1 << digit
            
            if mask in mask_dict:
                max_len = max(max_len, i - mask_dict[mask])
            else:
                mask_dict[mask] = i
            
            for d in range(10):
                temp_mask = mask ^ (1 << d)
                if temp_mask in mask_dict:
                    max_len = max(max_len, i - mask_dict[temp_mask])
        
        return max_len
```",Y,
get-the-maximum-score,Get the Maximum Score,"```python
class Solution:
    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:
        MOD = 10**9 + 7
        i, j = 0, 0
        m, n = len(nums1), len(nums2)
        sum1, sum2 = 0, 0
        max_sum = 0
        
        while i < m or j < n:
            if i < m and (j >= n or nums1[i] < nums2[j]):
                sum1 += nums1[i]
                i += 1
            elif j < n and (i >= m or nums2[j] < nums1[i]):
                sum2 += nums2[j]
                j += 1
            else:
                max_sum += max(sum1, sum2) + nums1[i]
                sum1, sum2 = 0, 0
                i += 1
                j += 1
        
        max_sum += max(sum1, sum2)
        return max_sum % MOD
```",Y,
find-a-value-of-a-mysterious-function-closest-to-target,Find a Value of a Mysterious Function Closest to Target,"```python
class Solution:
    def closestToTarget(self, arr: List[int], target: int) -> int:
        result = float('inf')
        current_ands = set()
        
        for num in arr:
            next_ands = set()
            next_ands.add(num)
            for val in current_ands:
                next_ands.add(val & num)
            for val in next_ands:
                result = min(result, abs(val - target))
            current_ands = next_ands
        
        return result
```",Y,
maximum-number-of-non-overlapping-substrings,Maximum Number of Non-Overlapping Substrings,"```python
class Solution:
    def maxNumOfSubstrings(self, s: str) -> List[str]:
        first = {}
        last = {}
        for i, c in enumerate(s):
            if c not in first:
                first[c] = i
            last[c] = i
        
        intervals = []
        for c in first:
            start = first[c]
            end = last[c]
            left, right = start, end
            changed = True
            while changed:
                changed = False
                new_left, new_right = left, right
                for i in range(left, right + 1):
                    char = s[i]
                    new_left = min(new_left, first[char])
                    new_right = max(new_right, last[char])
                if new_left != left or new_right != right:
                    changed = True
                    left, right = new_left, new_right
            intervals.append((left, right))
        
        intervals = list(set(intervals))
        intervals.sort(key=lambda x: x[1])
        
        res = []
        prev_end = -1
        for start, end in intervals:
            if start > prev_end:
                res.append(s[start:end+1])
                prev_end = end
        
        return res
```",Y,
best-position-for-a-service-centre,Best Position for a Service Centre,"```python
import math

class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        n = len(positions)
        if n == 0:
            return 0.0
        
        x = sum(p[0] for p in positions) / n
        y = sum(p[1] for p in positions) / n
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        step = 1.0
        eps = 1e-6
        decay = 0.9
        
        while step > eps:
            improved = False
            for dx, dy in directions:
                nx = x + step * dx
                ny = y + step * dy
                current_sum = 0.0
                new_sum = 0.0
                for px, py in positions:
                    current_sum += math.sqrt((x - px)**2 + (y - py)**2)
                    new_sum += math.sqrt((nx - px)**2 + (ny - py)**2)
                if new_sum < current_sum:
                    x, y = nx, ny
                    improved = True
                    break
            if not improved:
                step *= decay
        
        total = 0.0
        for px, py in positions:
            total += math.sqrt((x - px)**2 + (y - py)**2)
        return total
```",Y,
string-compression-ii,String Compression II,"```python
class Solution:
    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        memo = {}
        
        def dp(i, last_char, last_count, left):
            if (i, last_char, last_count, left) in memo:
                return memo[(i, last_char, last_count, left)]
            if left < 0:
                return float('inf')
            if i == len(s):
                return 0
            res = float('inf')
            res = min(res, dp(i + 1, last_char, last_count, left - 1))
            if s[i] == last_char:
                carry = 0
                if last_count == 1 or last_count == 9 or last_count == 99:
                    carry = 1
                res = min(res, carry + dp(i + 1, last_char, last_count + 1, left))
            else:
                res = min(res, 1 + dp(i + 1, s[i], 1, left))
            memo[(i, last_char, last_count, left)] = res
            return res
        
        return dp(0, """", 0, k)
```",Y,
minimum-number-of-increments-on-subarrays-to-form-a-target-array,Minimum Number of Increments on Subarrays to Form a Target Array,"```python
class Solution:
    def minNumberOperations(self, target: List[int]) -> int:
        operations = target[0]
        for i in range(1, len(target)):
            if target[i] > target[i-1]:
                operations += target[i] - target[i-1]
        return operations
```",Y,
minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits,Minimum Possible Integer After at Most K Adjacent Swaps On Digits,"```python
import bisect

class Solution:
    def minInteger(self, num: str, k: int) -> str:
        num = list(num)
        n = len(num)
        pos = [[] for _ in range(10)]
        for idx, ch in enumerate(num):
            pos[int(ch)].append(idx)
        
        res = []
        bit = [0] * (n + 2)
        
        def update(i, delta):
            while i <= n:
                bit[i] += delta
                i += i & -i
        
        def query(i):
            res = 0
            while i > 0:
                res += bit[i]
                i -= i & -i
            return res
        
        for i in range(n):
            if k <= 0:
                break
            for d in range(10):
                if not pos[d]:
                    continue
                original_pos = pos[d][0]
                cost = original_pos - query(original_pos + 1)
                if cost <= k:
                    k -= cost
                    res.append(str(d))
                    update(original_pos + 1, 1)
                    pos[d].pop(0)
                    break
        
        remaining_indices = []
        for d in range(10):
            for p in pos[d]:
                remaining_indices.append((p, str(d)))
        remaining_indices.sort()
        res.extend([ch for _, ch in remaining_indices])
        
        return ''.join(res)
```",Y,
max-value-of-equation,Max Value of Equation,"```python
from collections import deque

class Solution:
    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
        q = deque()
        res = -float('inf')
        for x, y in points:
            while q and x - q[0][1] > k:
                q.popleft()
            if q:
                res = max(res, q[0][0] + y + x)
            while q and y - x >= q[-1][0]:
                q.pop()
            q.append((y - x, x))
        return res
```",Y,
stone-game-iv,Stone Game IV,"```python
class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        dp = [False] * (n + 1)
        for i in range(1, n + 1):
            j = 1
            while j * j <= i:
                if not dp[i - j * j]:
                    dp[i] = True
                    break
                j += 1
        return dp[n]
```",Y,
find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree,Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree,"```python
class Solution:
    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        parent = list(range(n))
        
        def find(u):
            while parent[u] != u:
                parent[u] = parent[parent[u]]
                u = parent[u]
            return u
        
        def union(u, v):
            u_root = find(u)
            v_root = find(v)
            if u_root == v_root:
                return False
            parent[v_root] = u_root
            return True
        
        edges_with_index = [(u, v, w, i) for i, (u, v, w) in enumerate(edges)]
        edges_with_index.sort(key=lambda x: x[2])
        
        original_mst_weight = 0
        parent = list(range(n))
        for u, v, w, _ in edges_with_index:
            if union(u, v):
                original_mst_weight += w
        
        critical = []
        pseudo_critical = []
        
        for i in range(len(edges_with_index)):
            parent = list(range(n))
            mst_weight = 0
            for j in range(len(edges_with_index)):
                if i == j:
                    continue
                u, v, w, _ = edges_with_index[j]
                if union(u, v):
                    mst_weight += w
            if mst_weight != original_mst_weight:
                critical.append(edges_with_index[i][3])
                continue
            
            parent = list(range(n))
            u, v, w, _ = edges_with_index[i]
            union(u, v)
            mst_weight = w
            for j in range(len(edges_with_index)):
                if i == j:
                    continue
                u, v, w, _ = edges_with_index[j]
                if union(u, v):
                    mst_weight += w
            if mst_weight == original_mst_weight:
                pseudo_critical.append(edges_with_index[i][3])
        
        pseudo_critical = [edge for edge in pseudo_critical if edge not in critical]
        
        return [critical, pseudo_critical]
```",Y,
parallel-courses-ii,Parallel Courses II,"```python
from typing import List
from collections import deque

class Solution:
    def minNumberOfSemesters(self, n: int, relations: List[List[int]], k: int) -> int:
        graph = [[] for _ in range(n + 1)]
        in_degree = [0] * (n + 1)
        for u, v in relations:
            graph[u].append(v)
            in_degree[v] += 1
        
        queue = deque()
        for i in range(1, n + 1):
            if in_degree[i] == 0:
                queue.append(i)
        
        semesters = 0
        while queue:
            semester_courses = []
            for _ in range(min(k, len(queue))):
                course = queue.popleft()
                semester_courses.append(course)
            
            for course in semester_courses:
                for neighbor in graph[course]:
                    in_degree[neighbor] -= 1
                    if in_degree[neighbor] == 0:
                        queue.append(neighbor)
            
            semesters += 1
        
        return semesters
```",Y,
paint-house-iii,Paint House III,"```python
class Solution:
    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -> int:
        dp = [[[float('inf')] * (target + 1) for _ in range(n + 1)] for __ in range(m + 1)]
        
        for j in range(n + 1):
            dp[0][j][0] = 0
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                for k in range(1, target + 1):
                    if houses[i - 1] != 0 and houses[i - 1] != j:
                        continue  # can't paint to color j if already painted to another color
                    
                    current_cost = 0
                    if houses[i - 1] == 0:
                        current_cost = cost[i - 1][j - 1]  # j is 1-based, cost is 0-based
                    
                    min_cost = dp[i - 1][j][k]
                    
                    for prev_color in range(1, n + 1):
                        if prev_color != j:
                            if dp[i - 1][prev_color][k - 1] < min_cost:
                                min_cost = dp[i - 1][prev_color][k - 1]
                    
                    dp[i][j][k] = min_cost + current_cost
        
        result = min(dp[m][j][target] for j in range(1, n + 1))
        return result if result != float('inf') else -1
```",Y,
probability-of-a-two-boxes-having-the-same-number-of-distinct-balls,Probability of a Two Boxes Having The Same Number of Distinct Balls,"```python
import math
from typing import List

class Solution:
    def getProbability(self, balls: List[int]) -> float:
        total_balls = sum(balls)
        n = total_balls // 2
        k = len(balls)
        
        max_fact = total_balls
        fact = [1] * (max_fact + 1)
        for i in range(1, max_fact + 1):
            fact[i] = fact[i-1] * i
        
        total = fact[total_balls]
        for b in balls:
            total //= fact[b]
        
        self.valid = 0
        
        def backtrack(pos, box1_count, box1_distinct, box2_distinct, box1_comb, box2_comb):
            if pos == k:
                if box1_count == n and box1_distinct == box2_distinct:
                    self.valid += box1_comb * box2_comb
                return
            
            current_ball = balls[pos]
            for i in range(0, current_ball + 1):
                if box1_count + i > n:
                    continue
                new_box1_distinct = box1_distinct + (1 if i > 0 else 0)
                new_box2_distinct = box2_distinct + (1 if (current_ball - i) > 0 else 0)
                new_box1_comb = box1_comb // fact[i]
                new_box2_comb = box2_comb // fact[current_ball - i]
                backtrack(pos + 1, box1_count + i, new_box1_distinct, new_box2_distinct, new_box1_comb, new_box2_comb)
        
        initial_box1_comb = fact[n] * fact[n]
        initial_box2_comb = 1
        for b in balls:
            initial_box1_comb //= fact[b]
        
        backtrack(0, 0, 0, 0, fact[n] * fact[n], 1)
        
        return self.valid / total
```",Y,
allocate-mailboxes,Allocate Mailboxes,"```python
class Solution:
    def minDistance(self, houses: List[int], k: int) -> int:
        houses.sort()
        n = len(houses)
        
        cost = [[0] * n for _ in range(n)]
        for i in range(n):
            for j in range(i, n):
                median = houses[(i + j) // 2]
                total = 0
                for m in range(i, j + 1):
                    total += abs(houses[m] - median)
                cost[i][j] = total
        
        dp = [[float('inf')] * k for _ in range(n)]
        for i in range(n):
            dp[i][0] = cost[0][i]
        
        for l in range(1, k):
            for i in range(n):
                for j in range(i):
                    if dp[j][l-1] + cost[j+1][i] < dp[i][l]:
                        dp[i][l] = dp[j][l-1] + cost[j+1][i]
        
        return dp[n-1][k-1]
```",Y,
max-dot-product-of-two-subsequences,Max Dot Product of Two Subsequences,"```python
from typing import List

class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:
        m, n = len(nums1), len(nums2)
        dp = [[-float('inf')] * (n + 1) for _ in range(m + 1)]
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                product = nums1[i-1] * nums2[j-1]
                dp[i][j] = max(
                    product,
                    dp[i-1][j-1] + product,
                    dp[i-1][j],
                    dp[i][j-1]
                )
        
        return dp[m][n]
```",Y,
maximum-number-of-darts-inside-of-a-circular-dartboard,Maximum Number of Darts Inside of a Circular Dartboard,"```python
import math

class Solution:
    def numPoints(self, darts: List[List[int]], r: int) -> int:
        max_points = 1
        n = len(darts)
        for i in range(n):
            for j in range(i + 1, n):
                x1, y1 = darts[i]
                x2, y2 = darts[j]
                dx, dy = x2 - x1, y2 - y1
                d_squared = dx**2 + dy**2
                if d_squared > (2 * r) ** 2 + 1e-8:
                    continue
                d = math.sqrt(d_squared)
                mid_x, mid_y = (x1 + x2) / 2, (y1 + y2) / 2
                if d_squared == 0:
                    h = 0
                else:
                    h = math.sqrt(r**2 - d_squared / 4)
                for sign in (-1, 1):
                    cx = mid_x - sign * h * dy / d
                    cy = mid_y + sign * h * dx / d
                    count = 0
                    for (x, y) in darts:
                        if (x - cx)**2 + (y - cy)**2 <= r**2 + 1e-8:
                            count += 1
                    if count > max_points:
                        max_points = count
        return max_points
```",Y,
cherry-pickup-ii,Cherry Pickup II,"```python
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        rows = len(grid)
        cols = len(grid[0])
        
        dp = [[[ -1 for _ in range(cols) ] for __ in range(cols)] for ___ in range(rows)]
        
        dp[0][0][cols-1] = grid[0][0] + grid[0][cols-1]
        
        for i in range(1, rows):
            for j1 in range(cols):
                for j2 in range(cols):
                    max_prev = -1
                    for dj1 in [-1, 0, 1]:
                        prev_j1 = j1 + dj1
                        if prev_j1 < 0 or prev_j1 >= cols:
                            continue
                        for dj2 in [-1, 0, 1]:
                            prev_j2 = j2 + dj2
                            if prev_j2 < 0 or prev_j2 >= cols:
                                continue
                            if dp[i-1][prev_j1][prev_j2] > max_prev:
                                max_prev = dp[i-1][prev_j1][prev_j2]
                    if max_prev == -1:
                        continue
                    if j1 == j2:
                        current = grid[i][j1]
                    else:
                        current = grid[i][j1] + grid[i][j2]
                    dp[i][j1][j2] = max_prev + current
        
        max_cherries = 0
        for j1 in range(cols):
            for j2 in range(cols):
                if dp[rows-1][j1][j2] > max_cherries:
                    max_cherries = dp[rows-1][j1][j2]
        return max_cherries
```",Y,
number-of-ways-of-cutting-a-pizza,Number of Ways of Cutting a Pizza,"```python
class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        rows = len(pizza)
        cols = len(pizza[0])
        mod = 10**9 + 7
        
        prefix = [[0] * (cols + 1) for _ in range(rows + 1)]
        for i in range(rows - 1, -1, -1):
            for j in range(cols - 1, -1, -1):
                prefix[i][j] = prefix[i + 1][j] + prefix[i][j + 1] - prefix[i + 1][j + 1] + (1 if pizza[i][j] == 'A' else 0)
        
        dp = [[[0] * cols for _ in range(rows)] for __ in range(k + 1)]
        
        for i in range(rows):
            for j in range(cols):
                if prefix[i][j] > 0:
                    dp[1][i][j] = 1
        
        for m in range(2, k + 1):
            for i in range(rows):
                for j in range(cols):
                    total = 0
                    for x in range(i + 1, rows):
                        if prefix[i][j] - prefix[x][j] > 0:
                            total += dp[m - 1][x][j]
                            total %= mod
                    for y in range(j + 1, cols):
                        if prefix[i][j] - prefix[i][y] > 0:
                            total += dp[m - 1][i][y]
                            total %= mod
                    dp[m][i][j] = total
        
        return dp[k][0][0] % mod
```",Y,
find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows,Find the Kth Smallest Sum of a Matrix With Sorted Rows,"```python
import heapq

class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        
        min_heap = []
        initial_sum = sum(row[0] for row in mat)
        indices = tuple([0] * m)
        heapq.heappush(min_heap, (initial_sum, indices))
        
        visited = set()
        visited.add(indices)
        
        count = 0
        while min_heap and count < k:
            current_sum, current_indices = heapq.heappop(min_heap)
            count += 1
            if count == k:
                return current_sum
            
            for i in range(m):
                if current_indices[i] + 1 < n:
                    new_indices = list(current_indices)
                    new_indices[i] += 1
                    new_indices_tuple = tuple(new_indices)
                    if new_indices_tuple not in visited:
                        new_sum = current_sum - mat[i][current_indices[i]] + mat[i][new_indices[i]]
                        heapq.heappush(min_heap, (new_sum, new_indices_tuple))
                        visited.add(new_indices_tuple)
        
        return -1
```",Y,
form-largest-integer-with-digits-that-add-up-to-target,Form Largest Integer With Digits That Add up to Target,"```python
class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        dp = [-1] * (target + 1)
        dp[0] = 0
        
        for t in range(1, target + 1):
            for i in range(9):
                if t >= cost[i] and dp[t - cost[i]] != -1:
                    if dp[t] < dp[t - cost[i]] + 1:
                        dp[t] = dp[t - cost[i]] + 1
        
        if dp[target] == -1:
            return ""0""
        
        res = []
        remaining = target
        
        for i in range(8, -1, -1):
            while remaining >= cost[i] and dp[remaining] == dp[remaining - cost[i]] + 1:
                res.append(str(i + 1))
                remaining -= cost[i]
        
        return ''.join(res)
```",Y,
build-array-where-you-can-find-the-maximum-exactly-k-comparisons,Build Array Where You Can Find The Maximum Exactly K Comparisons,"```python
class Solution:
    def numOfArrays(self, n: int, m: int, k: int) -> int:
        MOD = 10**9 + 7
        if k == 0:
            return 0
        
        dp = [[[0] * (m + 1) for _ in range(k + 1)] for __ in range(n + 1)]
        
        for num in range(1, m + 1):
            dp[1][1][num] = 1
        
        for i in range(2, n + 1):
            for cost in range(1, k + 1):
                for max_num in range(1, m + 1):
                    dp[i][cost][max_num] = dp[i - 1][cost][max_num] * max_num % MOD
                    for prev_max in range(1, max_num):
                        dp[i][cost][max_num] = (dp[i][cost][max_num] + dp[i - 1][cost - 1][prev_max]) % MOD
        
        total = 0
        for num in range(1, m + 1):
            total = (total + dp[n][k][num]) % MOD
        
        return total
```",Y,
number-of-ways-to-wear-different-hats-to-each-other,Number of Ways to Wear Different Hats to Each Other,"```python
class Solution:
    def numberWays(self, hats: List[List[int]]) -> int:
        MOD = 10**9 + 7
        n = len(hats)
        hat_to_people = [[] for _ in range(41)]
        for person in range(n):
            for hat in hats[person]:
                hat_to_people[hat].append(person)
        
        dp = [0] * (1 << n)
        dp[0] = 1
        
        for hat in range(1, 41):
            for mask in range((1 << n) - 1, -1, -1):
                for person in hat_to_people[hat]:
                    if not (mask & (1 << person)):
                        new_mask = mask | (1 << person)
                        dp[new_mask] = (dp[new_mask] + dp[mask]) % MOD
        return dp[(1 << n) - 1] % MOD
```",Y,
number-of-ways-to-paint-n-3-grid,Number of Ways to Paint N × 3 Grid,"```python
class Solution:
    def numOfWays(self, n: int) -> int:
        MOD = 10**9 + 7
        aba = 6
        abc = 6
        
        for _ in range(2, n+1):
            new_aba = (aba * 3 + abc * 2) % MOD
            new_abc = (aba * 2 + abc * 2) % MOD
            aba, abc = new_aba, new_abc
        
        return (aba + abc) % MOD
```",Y,
stone-game-iii,Stone Game III,"```python
class Solution:
    def stoneGameIII(self, stoneValue: List[int]) -> str:
        n = len(stoneValue)
        dp = [0] * (n + 1)
        
        for i in range(n - 1, -1, -1):
            dp[i] = -float('inf')
            take = 0
            for k in range(3):
                if i + k >= n:
                    break
                take += stoneValue[i + k]
                dp[i] = max(dp[i], take - dp[i + k + 1])
        
        if dp[0] > 0:
            return ""Alice""
        elif dp[0] < 0:
            return ""Bob""
        else:
            return ""Tie""
```",Y,
restore-the-array,Restore The Array,"```python
class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        n = len(s)
        mod = 10**9 + 7
        dp = [0] * (n + 1)
        dp[n] = 1  # empty string has one way
        
        for i in range(n - 1, -1, -1):
            if s[i] == '0':
                dp[i] = 0
                continue
            num = 0
            res = 0
            for j in range(i, n):
                num = num * 10 + int(s[j])
                if num > k:
                    break
                res += dp[j + 1]
                res %= mod
            dp[i] = res
        return dp[0]
```",Y,
